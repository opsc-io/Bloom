module.exports = [
"[project]/node_modules/typeorm/query-builder/Alias.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Alias = void 0;
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 */ class Alias {
    constructor(alias){
        ObjectUtils_1.ObjectUtils.assign(this, alias || {});
    }
    get target() {
        return this.metadata.target;
    }
    get hasMetadata() {
        return !!this._metadata;
    }
    set metadata(metadata) {
        this._metadata = metadata;
    }
    get metadata() {
        if (!this._metadata) throw new error_1.TypeORMError(`Cannot get entity metadata for the given alias "${this.name}"`);
        return this._metadata;
    }
}
exports.Alias = Alias; //# sourceMappingURL=Alias.js.map
}),
"[project]/node_modules/typeorm/query-builder/QueryBuilderUtils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryBuilderUtils = void 0;
/**
 * Helper utility functions for QueryBuilder.
 */ class QueryBuilderUtils {
    /**
     * Checks if given value is a string representation of alias property,
     * e.g. "post.category" or "post.id".
     */ static isAliasProperty(str) {
        // alias property must be a string and must have a dot separator
        if (typeof str !== "string" || str.indexOf(".") === -1) return false;
        // extra alias and its property relation
        const [aliasName, propertyName] = str.split("."); // todo: what about relations in embedded?
        if (!aliasName || !propertyName) return false;
        // alias and property must be represented in a special format
        // const aliasNameRegexp = /^[a-zA-Z0-9_-]+$/;
        // if (!aliasNameRegexp.test(aliasName) || !aliasNameRegexp.test(propertyName))
        //     return false;
        // make sure string is not a subquery
        if (str.indexOf("(") !== -1 || str.indexOf(")") !== -1) return false;
        return true;
    }
}
exports.QueryBuilderUtils = QueryBuilderUtils; //# sourceMappingURL=QueryBuilderUtils.js.map
}),
"[project]/node_modules/typeorm/query-builder/JoinAttribute.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JoinAttribute = void 0;
const QueryBuilderUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilderUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/**
 * Stores all join attributes which will be used to build a JOIN query.
 */ class JoinAttribute {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryExpressionMap, joinAttribute){
        this.connection = connection;
        this.queryExpressionMap = queryExpressionMap;
        this.isSelectedEvaluated = false;
        this.relationEvaluated = false;
        if (joinAttribute) {
            ObjectUtils_1.ObjectUtils.assign(this, joinAttribute);
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    get isMany() {
        if (this.isMappingMany !== undefined) return this.isMappingMany;
        if (this.relation) return this.relation.isManyToMany || this.relation.isOneToMany;
        return false;
    }
    /**
     * Indicates if this join is selected.
     */ get isSelected() {
        if (!this.isSelectedEvaluated) {
            const getValue = ()=>{
                for (const select of this.queryExpressionMap.selects){
                    if (select.selection === this.alias.name) return true;
                    if (this.metadata && !!this.metadata.columns.find((column)=>select.selection === this.alias.name + "." + column.propertyPath)) return true;
                }
                return false;
            };
            this.isSelectedCache = getValue();
            this.isSelectedEvaluated = true;
        }
        return this.isSelectedCache;
    }
    /**
     * Name of the table which we should join.
     */ get tablePath() {
        return this.metadata ? this.metadata.tablePath : this.entityOrProperty;
    }
    /**
     * Alias of the parent of this join.
     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
     * This value is extracted from entityOrProperty value.
     * This is available when join was made using "post.category" syntax.
     */ get parentAlias() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;
        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
    }
    /**
     * Relation property name of the parent.
     * This is used to understand what is joined.
     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
     * This value is extracted from entityOrProperty value.
     * This is available when join was made using "post.category" syntax.
     */ get relationPropertyPath() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;
        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(".") + 1);
    }
    /**
     * Relation of the parent.
     * This is used to understand what is joined.
     * This is available when join was made using "post.category" syntax.
     * Relation can be undefined if entityOrProperty is regular entity or custom table.
     */ get relation() {
        if (!this.relationEvaluated) {
            const getValue = ()=>{
                if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;
                const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
                let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
                if (relation) {
                    return relation;
                }
                if (relationOwnerSelection.metadata.parentEntityMetadata) {
                    relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);
                    if (relation) {
                        return relation;
                    }
                }
                throw new error_1.TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);
            };
            this.relationCache = getValue.bind(this)();
            this.relationEvaluated = true;
        }
        return this.relationCache;
    }
    /**
     * Metadata of the joined entity.
     * If table without entity was joined, then it will return undefined.
     */ get metadata() {
        // entityOrProperty is relation, e.g. "post.category"
        if (this.relation) return this.relation.inverseEntityMetadata;
        // entityOrProperty is Entity class
        if (this.connection.hasMetadata(this.entityOrProperty)) return this.connection.getMetadata(this.entityOrProperty);
        // Overriden mapping entity provided for leftJoinAndMapOne with custom query builder
        if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {
            return this.connection.getMetadata(this.mapAsEntity);
        }
        return undefined;
    /*if (typeof this.entityOrProperty === "string") { // entityOrProperty is a custom table

            // first try to find entity with such name, this is needed when entity does not have a target class,
            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)
            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);
            if (metadata)
                return metadata;

            // check if we have entity with such table name, and use its metadata if found
            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);
        }*/ }
    /**
     * Generates alias of junction table, whose ids we get.
     */ get junctionAlias() {
        if (!this.relation) {
            throw new error_1.TypeORMError(`Cannot get junction table for join without relation.`);
        }
        if (typeof this.entityOrProperty !== "string") {
            throw new error_1.TypeORMError(`Junction property is not defined.`);
        }
        const aliasProperty = this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
        if (this.relation.isOwning) {
            return DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, aliasProperty, this.alias.name);
        } else {
            return DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, this.alias.name, aliasProperty);
        }
    }
    get mapToPropertyParentAlias() {
        if (!this.mapToProperty) return undefined;
        return this.mapToProperty.split(".")[0];
    }
    get mapToPropertyPropertyName() {
        if (!this.mapToProperty) return undefined;
        return this.mapToProperty.split(".")[1];
    }
}
exports.JoinAttribute = JoinAttribute; //# sourceMappingURL=JoinAttribute.js.map
}),
"[project]/node_modules/typeorm/query-builder/relation-id/RelationIdAttribute.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationIdAttribute = void 0;
const QueryBuilderUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilderUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Stores all join relation id attributes which will be used to build a JOIN query.
 */ class RelationIdAttribute {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryExpressionMap, relationIdAttribute){
        this.queryExpressionMap = queryExpressionMap;
        /**
         * Indicates if relation id should NOT be loaded as id map.
         */ this.disableMixedMap = false;
        ObjectUtils_1.ObjectUtils.assign(this, relationIdAttribute || {});
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    get joinInverseSideMetadata() {
        return this.relation.inverseEntityMetadata;
    }
    /**
     * Alias of the parent of this join.
     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
     * This value is extracted from entityOrProperty value.
     * This is available when join was made using "post.category" syntax.
     */ get parentAlias() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        return this.relationName.substr(0, this.relationName.indexOf("."));
    }
    /**
     * Relation property name of the parent.
     * This is used to understand what is joined.
     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
     * This value is extracted from entityOrProperty value.
     * This is available when join was made using "post.category" syntax.
     */ get relationPropertyPath() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        return this.relationName.substr(this.relationName.indexOf(".") + 1);
    }
    /**
     * Relation of the parent.
     * This is used to understand what is joined.
     * This is available when join was made using "post.category" syntax.
     */ get relation() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
        const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
        if (!relation) throw new TypeORMError_1.TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);
        return relation;
    }
    /**
     * Generates alias of junction table, whose ids we get.
     */ get junctionAlias() {
        const [parentAlias, relationProperty] = this.relationName.split(".");
        return parentAlias + "_" + relationProperty + "_rid";
    }
    /**
     * Metadata of the joined entity.
     * If extra condition without entity was joined, then it will return undefined.
     */ get junctionMetadata() {
        return this.relation.junctionEntityMetadata;
    }
    get mapToPropertyParentAlias() {
        return this.mapToProperty.substr(0, this.mapToProperty.indexOf("."));
    }
    get mapToPropertyPropertyPath() {
        return this.mapToProperty.substr(this.mapToProperty.indexOf(".") + 1);
    }
}
exports.RelationIdAttribute = RelationIdAttribute; //# sourceMappingURL=RelationIdAttribute.js.map
}),
"[project]/node_modules/typeorm/query-builder/relation-count/RelationCountAttribute.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationCountAttribute = void 0;
const QueryBuilderUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilderUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class RelationCountAttribute {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(expressionMap, relationCountAttribute){
        this.expressionMap = expressionMap;
        ObjectUtils_1.ObjectUtils.assign(this, relationCountAttribute || {});
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    get joinInverseSideMetadata() {
        return this.relation.inverseEntityMetadata;
    }
    /**
     * Alias of the parent of this join.
     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
     * This value is extracted from entityOrProperty value.
     * This is available when join was made using "post.category" syntax.
     */ get parentAlias() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        return this.relationName.split(".")[0];
    }
    /**
     * Relation property name of the parent.
     * This is used to understand what is joined.
     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
     * This value is extracted from entityOrProperty value.
     * This is available when join was made using "post.category" syntax.
     */ get relationProperty() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value is a string representation of alias property`);
        return this.relationName.split(".")[1];
    }
    get junctionAlias() {
        const [parentAlias, relationProperty] = this.relationName.split(".");
        return parentAlias + "_" + relationProperty + "_rc";
    }
    /**
     * Relation of the parent.
     * This is used to understand what is joined.
     * This is available when join was made using "post.category" syntax.
     */ get relation() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value is a string representation of alias property`);
        const [parentAlias, propertyPath] = this.relationName.split(".");
        const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);
        const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);
        if (!relation) throw new TypeORMError_1.TypeORMError(`Relation with property path ${propertyPath} in entity was not found.`);
        return relation;
    }
    /**
     * Metadata of the joined entity.
     * If table without entity was joined, then it will return undefined.
     */ get metadata() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError_1.TypeORMError(`Given value is a string representation of alias property`);
        const parentAlias = this.relationName.split(".")[0];
        const selection = this.expressionMap.findAliasByName(parentAlias);
        return selection.metadata;
    }
    get mapToPropertyPropertyName() {
        return this.mapToProperty.split(".")[1];
    }
}
exports.RelationCountAttribute = RelationCountAttribute; //# sourceMappingURL=RelationCountAttribute.js.map
}),
"[project]/node_modules/typeorm/query-builder/QueryExpressionMap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryExpressionMap = void 0;
const Alias_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/Alias.js [app-route] (ecmascript)");
const JoinAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/JoinAttribute.js [app-route] (ecmascript)");
const RelationIdAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-id/RelationIdAttribute.js [app-route] (ecmascript)");
const RelationCountAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-count/RelationCountAttribute.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Contains all properties of the QueryBuilder that needs to be build a final query.
 */ class QueryExpressionMap {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
        // -------------------------------------------------------------------------
        // Public Properties
        // -------------------------------------------------------------------------
        /**
         * Strategy to load relations.
         */ this.relationLoadStrategy = "join";
        /**
         * Indicates if QueryBuilder used to select entities and not a raw results.
         */ this.queryEntity = false;
        /**
         * All aliases (including main alias) used in the query.
         */ this.aliases = [];
        /**
         * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.
         */ this.queryType = "select";
        /**
         * Data needs to be SELECT-ed.
         */ this.selects = [];
        /**
         * Max execution time in millisecond.
         */ this.maxExecutionTime = 0;
        /**
         * Whether SELECT is DISTINCT.
         */ this.selectDistinct = false;
        /**
         * SELECT DISTINCT ON query (postgres).
         */ this.selectDistinctOn = [];
        /**
         * Extra returning columns to be added to the returning statement if driver supports it.
         */ this.extraReturningColumns = [];
        /**
         * Optional on conflict statement used in insertion query in postgres.
         */ this.onConflict = "";
        /**
         * Optional on ignore statement used in insertion query in databases.
         */ this.onIgnore = false;
        /**
         * JOIN queries.
         */ this.joinAttributes = [];
        /**
         * RelationId queries.
         */ this.relationIdAttributes = [];
        /**
         * Relation count queries.
         */ this.relationCountAttributes = [];
        /**
         * WHERE queries.
         */ this.wheres = [];
        /**
         * HAVING queries.
         */ this.havings = [];
        /**
         * ORDER BY queries.
         */ this.orderBys = {};
        /**
         * GROUP BY queries.
         */ this.groupBys = [];
        /**
         * Indicates if soft-deleted rows should be included in entity result.
         * By default the soft-deleted rows are not included.
         */ this.withDeleted = false;
        /**
         * Parameters used to be escaped in final query.
         */ this.parameters = {};
        /**
         * Indicates if alias, table names and column names will be escaped by driver, or not.
         *
         * todo: rename to isQuotingDisabled, also think if it should be named "escaping"
         */ this.disableEscaping = true;
        /**
         * Indicates if virtual columns should be included in entity result.
         *
         * todo: what to do with it? is it properly used? what about persistence?
         */ this.enableRelationIdValues = false;
        /**
         * Extra where condition appended to the end of original where conditions with AND keyword.
         * Original condition will be wrapped into brackets.
         */ this.extraAppendedAndWhereCondition = "";
        /**
         * Indicates if query builder creates a subquery.
         */ this.subQuery = false;
        /**
         * Indicates if property names are prefixed with alias names during property replacement.
         * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,
         * but user can use them in WHERE expressions.
         */ this.aliasNamePrefixingEnabled = true;
        /**
         * Options that define QueryBuilder behaviour.
         */ this.options = [];
        /**
         * List of columns where data should be inserted.
         * Used in INSERT query.
         */ this.insertColumns = [];
        /**
         * Used if user wants to update or delete a specific entities.
         */ this.whereEntities = [];
        /**
         * Indicates if entity must be updated after insertion / updation.
         * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
         */ this.updateEntity = true;
        /**
         * Indicates if listeners and subscribers must be called before and after query execution.
         */ this.callListeners = true;
        /**
         * Indicates if query must be wrapped into transaction.
         */ this.useTransaction = false;
        /**
         * Extra parameters.
         *
         * @deprecated Use standard parameters instead
         */ this.nativeParameters = {};
        /**
         * Items from an entity that have been locally generated & are recorded here for later use.
         * Examples include the UUID generation when the database does not natively support it.
         * These are included in the entity index order.
         */ this.locallyGenerated = {};
        this.commonTableExpressions = [];
        if (connection.options.relationLoadStrategy) {
            this.relationLoadStrategy = connection.options.relationLoadStrategy;
        }
        this.timeTravel = connection.options?.timeTravelQueries || false;
    }
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    /**
     * Get all ORDER BY queries - if order by is specified by user then it uses them,
     * otherwise it uses default entity order by if it was set.
     */ get allOrderBys() {
        if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata && this.options.indexOf("disable-global-order") === -1) {
            const entityOrderBy = this.mainAlias.metadata.orderBy || {};
            return Object.keys(entityOrderBy).reduce((orderBy, key)=>{
                orderBy[this.mainAlias.name + "." + key] = entityOrderBy[key];
                return orderBy;
            }, {});
        }
        return this.orderBys;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a main alias and adds it to the current expression map.
     */ setMainAlias(alias) {
        // if main alias is already set then remove it from the array
        // if (this.mainAlias)
        //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));
        // set new main alias
        this.mainAlias = alias;
        return alias;
    }
    /**
     * Creates a new alias and adds it to the current expression map.
     */ createAlias(options) {
        let aliasName = options.name;
        if (!aliasName && options.tablePath) aliasName = options.tablePath;
        if (!aliasName && typeof options.target === "function") aliasName = options.target.name;
        if (!aliasName && typeof options.target === "string") aliasName = options.target;
        const alias = new Alias_1.Alias();
        alias.type = options.type;
        if (aliasName) alias.name = aliasName;
        if (options.metadata) alias.metadata = options.metadata;
        if (options.target && !alias.hasMetadata) alias.metadata = this.connection.getMetadata(options.target);
        if (options.tablePath) alias.tablePath = options.tablePath;
        if (options.subQuery) alias.subQuery = options.subQuery;
        this.aliases.push(alias);
        return alias;
    }
    /**
     * Finds alias with the given name.
     * If alias was not found it throw an exception.
     */ findAliasByName(aliasName) {
        const alias = this.aliases.find((alias)=>alias.name === aliasName);
        if (!alias) throw new error_1.TypeORMError(`"${aliasName}" alias was not found. Maybe you forgot to join it?`);
        return alias;
    }
    findColumnByAliasExpression(aliasExpression) {
        const [aliasName, propertyPath] = aliasExpression.split(".");
        const alias = this.findAliasByName(aliasName);
        return alias.metadata.findColumnWithPropertyName(propertyPath);
    }
    /**
     * Gets relation metadata of the relation this query builder works with.
     *
     * todo: add proper exceptions
     */ get relationMetadata() {
        if (!this.mainAlias) throw new error_1.TypeORMError(`Entity to work with is not specified!`); // todo: better message
        const relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
        if (!relationMetadata) throw new error_1.TypeORMError(`Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`); // todo: better message
        return relationMetadata;
    }
    /**
     * Copies all properties of the current QueryExpressionMap into a new one.
     * Useful when QueryBuilder needs to create a copy of itself.
     */ clone() {
        const map = new QueryExpressionMap(this.connection);
        map.queryType = this.queryType;
        map.selects = this.selects.map((select)=>select);
        map.maxExecutionTime = this.maxExecutionTime;
        map.selectDistinct = this.selectDistinct;
        map.selectDistinctOn = this.selectDistinctOn;
        this.aliases.forEach((alias)=>map.aliases.push(new Alias_1.Alias(alias)));
        map.relationLoadStrategy = this.relationLoadStrategy;
        map.mainAlias = this.mainAlias;
        map.valuesSet = this.valuesSet;
        map.returning = this.returning;
        map.onConflict = this.onConflict;
        map.onIgnore = this.onIgnore;
        map.onUpdate = this.onUpdate;
        map.joinAttributes = this.joinAttributes.map((join)=>new JoinAttribute_1.JoinAttribute(this.connection, this, join));
        map.relationIdAttributes = this.relationIdAttributes.map((relationId)=>new RelationIdAttribute_1.RelationIdAttribute(this, relationId));
        map.relationCountAttributes = this.relationCountAttributes.map((relationCount)=>new RelationCountAttribute_1.RelationCountAttribute(this, relationCount));
        map.wheres = this.wheres.map((where)=>({
                ...where
            }));
        map.havings = this.havings.map((having)=>({
                ...having
            }));
        map.orderBys = Object.assign({}, this.orderBys);
        map.groupBys = this.groupBys.map((groupBy)=>groupBy);
        map.limit = this.limit;
        map.offset = this.offset;
        map.skip = this.skip;
        map.take = this.take;
        map.useIndex = this.useIndex;
        map.lockMode = this.lockMode;
        map.onLocked = this.onLocked;
        map.lockVersion = this.lockVersion;
        map.lockTables = this.lockTables;
        map.withDeleted = this.withDeleted;
        map.parameters = Object.assign({}, this.parameters);
        map.disableEscaping = this.disableEscaping;
        map.enableRelationIdValues = this.enableRelationIdValues;
        map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;
        map.subQuery = this.subQuery;
        map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;
        map.cache = this.cache;
        map.cacheId = this.cacheId;
        map.cacheDuration = this.cacheDuration;
        map.relationPropertyPath = this.relationPropertyPath;
        map.of = this.of;
        map.insertColumns = this.insertColumns;
        map.whereEntities = this.whereEntities;
        map.updateEntity = this.updateEntity;
        map.callListeners = this.callListeners;
        map.useTransaction = this.useTransaction;
        map.timeTravel = this.timeTravel;
        map.nativeParameters = Object.assign({}, this.nativeParameters);
        map.comment = this.comment;
        map.commonTableExpressions = this.commonTableExpressions.map((cteOptions)=>({
                alias: cteOptions.alias,
                queryBuilder: typeof cteOptions.queryBuilder === "string" ? cteOptions.queryBuilder : cteOptions.queryBuilder.clone(),
                options: cteOptions.options
            }));
        return map;
    }
}
exports.QueryExpressionMap = QueryExpressionMap; //# sourceMappingURL=QueryExpressionMap.js.map
}),
"[project]/node_modules/typeorm/query-builder/Brackets.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Brackets = void 0;
/**
 * Syntax sugar.
 * Allows to use brackets in WHERE expressions for better syntax.
 */ class Brackets {
    /**
     * Given WHERE query builder that will build a WHERE expression that will be taken into brackets.
     */ constructor(whereFactory){
        this["@instanceof"] = Symbol.for("Brackets");
        this.whereFactory = whereFactory;
    }
}
exports.Brackets = Brackets; //# sourceMappingURL=Brackets.js.map
}),
"[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryBuilder = void 0;
const QueryExpressionMap_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryExpressionMap.js [app-route] (ecmascript)");
const Brackets_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/Brackets.js [app-route] (ecmascript)");
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
const In_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/In.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const EntityPropertyNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/EntityPropertyNotFoundError.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const escapeRegExp_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/escapeRegExp.js [app-route] (ecmascript)");
// todo: completely cover query builder with tests
// todo: entityOrProperty can be target name. implement proper behaviour if it is.
// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)
// todo: fix problem with long aliases eg getMaxIdentifierLength
// todo: fix replacing in .select("COUNT(post.id) AS cnt") statement
// todo: implement joinAlways in relations and relationId
// todo: finish partial selection
// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...
// todo: implement @Select decorator
// todo: add select and map functions
// todo: implement relation/entity loading and setting them into properties within a separate query
// .loadAndMap("post.categories", "post.categories", qb => ...)
// .loadAndMap("post.categories", Category, qb => ...)
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */ class QueryBuilder {
    /**
     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.
     */ constructor(connectionOrQueryBuilder, queryRunner){
        this["@instanceof"] = Symbol.for("QueryBuilder");
        /**
         * Memo to help keep place of current parameter index for `createParameter`
         */ this.parameterIndex = 0;
        if (InstanceChecker_1.InstanceChecker.isDataSource(connectionOrQueryBuilder)) {
            this.connection = connectionOrQueryBuilder;
            this.queryRunner = queryRunner;
            this.expressionMap = new QueryExpressionMap_1.QueryExpressionMap(this.connection);
        } else {
            this.connection = connectionOrQueryBuilder.connection;
            this.queryRunner = connectionOrQueryBuilder.queryRunner;
            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();
        }
    }
    static registerQueryBuilderClass(name, factory) {
        QueryBuilder.queryBuilderRegistry[name] = factory;
    }
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    /**
     * Gets the main alias string used in this query builder.
     */ get alias() {
        if (!this.expressionMap.mainAlias) throw new error_1.TypeORMError(`Main alias is not set`); // todo: better exception
        return this.expressionMap.mainAlias.name;
    }
    /**
     * Creates SELECT query and selects given data.
     * Replaces all previous selections if they exist.
     */ select(selection, selectionAliasName) {
        this.expressionMap.queryType = "select";
        if (Array.isArray(selection)) {
            this.expressionMap.selects = selection.map((selection)=>({
                    selection: selection
                }));
        } else if (selection) {
            this.expressionMap.selects = [
                {
                    selection: selection,
                    aliasName: selectionAliasName
                }
            ];
        }
        if (InstanceChecker_1.InstanceChecker.isSelectQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["SelectQueryBuilder"](this);
    }
    /**
     * Creates INSERT query.
     */ insert() {
        this.expressionMap.queryType = "insert";
        if (InstanceChecker_1.InstanceChecker.isInsertQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["InsertQueryBuilder"](this);
    }
    /**
     * Creates UPDATE query and applies given update values.
     */ update(entityOrTableNameUpdateSet, maybeUpdateSet) {
        const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;
        entityOrTableNameUpdateSet = InstanceChecker_1.InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet) ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;
        if (typeof entityOrTableNameUpdateSet === "function" || typeof entityOrTableNameUpdateSet === "string") {
            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);
            this.expressionMap.setMainAlias(mainAlias);
        }
        this.expressionMap.queryType = "update";
        this.expressionMap.valuesSet = updateSet;
        if (InstanceChecker_1.InstanceChecker.isUpdateQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["UpdateQueryBuilder"](this);
    }
    /**
     * Creates DELETE query.
     */ delete() {
        this.expressionMap.queryType = "delete";
        if (InstanceChecker_1.InstanceChecker.isDeleteQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["DeleteQueryBuilder"](this);
    }
    softDelete() {
        this.expressionMap.queryType = "soft-delete";
        if (InstanceChecker_1.InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["SoftDeleteQueryBuilder"](this);
    }
    restore() {
        this.expressionMap.queryType = "restore";
        if (InstanceChecker_1.InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["SoftDeleteQueryBuilder"](this);
    }
    /**
     * Sets entity's relation with which this query builder gonna work.
     */ relation(entityTargetOrPropertyPath, maybePropertyPath) {
        const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;
        const propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;
        this.expressionMap.queryType = "relation";
        this.expressionMap.relationPropertyPath = propertyPath;
        if (entityTarget) {
            const mainAlias = this.createFromAlias(entityTarget);
            this.expressionMap.setMainAlias(mainAlias);
        }
        if (InstanceChecker_1.InstanceChecker.isRelationQueryBuilder(this)) return this;
        return QueryBuilder.queryBuilderRegistry["RelationQueryBuilder"](this);
    }
    /**
     * Checks if given relation or relations exist in the entity.
     * Returns true if relation exists, false otherwise.
     *
     * todo: move this method to manager? or create a shortcut?
     */ hasRelation(target, relation) {
        const entityMetadata = this.connection.getMetadata(target);
        const relations = Array.isArray(relation) ? relation : [
            relation
        ];
        return relations.every((relation)=>{
            return !!entityMetadata.findRelationWithPropertyPath(relation);
        });
    }
    /**
     * Check the existence of a parameter for this query builder.
     */ hasParameter(key) {
        return this.parentQueryBuilder?.hasParameter(key) || key in this.expressionMap.parameters;
    }
    /**
     * Sets parameter name and its value.
     *
     * The key for this parameter may contain numbers, letters, underscores, or periods.
     */ setParameter(key, value) {
        if (typeof value === "function") {
            throw new error_1.TypeORMError(`Function parameter isn't supported in the parameters. Please check "${key}" parameter.`);
        }
        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {
            throw new error_1.TypeORMError("QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.");
        }
        if (this.parentQueryBuilder) {
            this.parentQueryBuilder.setParameter(key, value);
        }
        this.expressionMap.parameters[key] = value;
        return this;
    }
    /**
     * Adds all parameters from the given object.
     */ setParameters(parameters) {
        for (const [key, value] of Object.entries(parameters)){
            this.setParameter(key, value);
        }
        return this;
    }
    createParameter(value) {
        let parameterName;
        do {
            parameterName = `orm_param_${this.parameterIndex++}`;
        }while (this.hasParameter(parameterName))
        this.setParameter(parameterName, value);
        return `:${parameterName}`;
    }
    /**
     * Adds native parameters from the given object.
     *
     * @deprecated Use `setParameters` instead
     */ setNativeParameters(parameters) {
        // set parent query builder parameters as well in sub-query mode
        if (this.parentQueryBuilder) {
            this.parentQueryBuilder.setNativeParameters(parameters);
        }
        Object.keys(parameters).forEach((key)=>{
            this.expressionMap.nativeParameters[key] = parameters[key];
        });
        return this;
    }
    /**
     * Gets all parameters.
     */ getParameters() {
        const parameters = Object.assign({}, this.expressionMap.parameters);
        // add discriminator column parameter if it exist
        if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {
            const metadata = this.expressionMap.mainAlias.metadata;
            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                const values = metadata.childEntityMetadatas.filter((childMetadata)=>childMetadata.discriminatorColumn).map((childMetadata)=>childMetadata.discriminatorValue);
                values.push(metadata.discriminatorValue);
                parameters["discriminatorColumnValues"] = values;
            }
        }
        return parameters;
    }
    /**
     * Prints sql to stdout using console.log.
     */ printSql() {
        // TODO rename to logSql()
        const [query, parameters] = this.getQueryAndParameters();
        this.connection.logger.logQuery(query, parameters);
        return this;
    }
    /**
     * Gets generated sql that will be executed.
     * Parameters in the query are escaped for the currently used driver.
     */ getSql() {
        return this.getQueryAndParameters()[0];
    }
    /**
     * Gets query to be executed with all parameters used in it.
     */ getQueryAndParameters() {
        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values
        const query = this.getQuery();
        const parameters = this.getParameters();
        return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);
    }
    /**
     * Executes sql generated by query builder and returns raw database results.
     */ async execute() {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        try {
            return await queryRunner.query(sql, parameters); // await is needed here because we are using finally
        } finally{
            if (queryRunner !== this.queryRunner) {
                // means we created our own query runner
                await queryRunner.release();
            }
        }
    }
    /**
     * Creates a completely new query builder.
     * Uses same query runner as current QueryBuilder.
     */ createQueryBuilder(queryRunner) {
        return new this.constructor(this.connection, queryRunner ?? this.queryRunner);
    }
    /**
     * Clones query builder as it is.
     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,
     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)
     * where queryBuilder is cloned QueryBuilder.
     */ clone() {
        return new this.constructor(this);
    }
    /**
     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,
     * such as finding a specific query in the database server's logs, or for categorization using
     * an APM product.
     */ comment(comment) {
        this.expressionMap.comment = comment;
        return this;
    }
    /**
     * Disables escaping.
     */ disableEscaping() {
        this.expressionMap.disableEscaping = false;
        return this;
    }
    /**
     * Escapes table name, column name or alias name using current database's escaping character.
     */ escape(name) {
        if (!this.expressionMap.disableEscaping) return name;
        return this.connection.driver.escape(name);
    }
    /**
     * Sets or overrides query builder's QueryRunner.
     */ setQueryRunner(queryRunner) {
        this.queryRunner = queryRunner;
        return this;
    }
    /**
     * Indicates if listeners and subscribers must be called before and after query execution.
     * Enabled by default.
     */ callListeners(enabled) {
        this.expressionMap.callListeners = enabled;
        return this;
    }
    /**
     * If set to true the query will be wrapped into a transaction.
     */ useTransaction(enabled) {
        this.expressionMap.useTransaction = enabled;
        return this;
    }
    /**
     * Adds CTE to query
     */ addCommonTableExpression(queryBuilder, alias, options) {
        this.expressionMap.commonTableExpressions.push({
            queryBuilder,
            alias,
            options: options || {}
        });
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Gets escaped table name with schema name if SqlServer driver used with custom
     * schema name, otherwise returns escaped table name.
     */ getTableName(tablePath) {
        return tablePath.split(".").map((i)=>{
            // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string
            if (i === "") return i;
            return this.escape(i);
        }).join(".");
    }
    /**
     * Gets name of the table where insert should be performed.
     */ getMainTableName() {
        if (!this.expressionMap.mainAlias) throw new error_1.TypeORMError(`Entity where values should be inserted is not specified. Call "qb.into(entity)" method to specify it.`);
        if (this.expressionMap.mainAlias.hasMetadata) return this.expressionMap.mainAlias.metadata.tablePath;
        return this.expressionMap.mainAlias.tablePath;
    }
    /**
     * Specifies FROM which entity's table select/update/delete will be executed.
     * Also sets a main string alias of the selection data.
     */ createFromAlias(entityTarget, aliasName) {
        // if table has a metadata then find it to properly escape its properties
        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);
        if (this.connection.hasMetadata(entityTarget)) {
            const metadata = this.connection.getMetadata(entityTarget);
            return this.expressionMap.createAlias({
                type: "from",
                name: aliasName,
                metadata: this.connection.getMetadata(entityTarget),
                tablePath: metadata.tablePath
            });
        } else {
            if (typeof entityTarget === "string") {
                const isSubquery = entityTarget.substr(0, 1) === "(" && entityTarget.substr(-1) === ")";
                return this.expressionMap.createAlias({
                    type: "from",
                    name: aliasName,
                    tablePath: !isSubquery ? entityTarget : undefined,
                    subQuery: isSubquery ? entityTarget : undefined
                });
            }
            const subQueryBuilder = entityTarget(this.subQuery());
            this.setParameters(subQueryBuilder.getParameters());
            const subquery = subQueryBuilder.getQuery();
            return this.expressionMap.createAlias({
                type: "from",
                name: aliasName,
                subQuery: subquery
            });
        }
    }
    /**
     * @deprecated this way of replace property names is too slow.
     *  Instead, we'll replace property names at the end - once query is build.
     */ replacePropertyNames(statement) {
        return statement;
    }
    /**
     * Replaces all entity's propertyName to name in the given SQL string.
     */ replacePropertyNamesForTheWholeQuery(statement) {
        const replacements = {};
        for (const alias of this.expressionMap.aliases){
            if (!alias.hasMetadata) continue;
            const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled && alias.name ? `${alias.name}.` : "";
            if (!replacements[replaceAliasNamePrefix]) {
                replacements[replaceAliasNamePrefix] = {};
            }
            // Insert & overwrite the replacements from least to most relevant in our replacements object.
            // To do this we iterate and overwrite in the order of relevance.
            // Least to Most Relevant:
            // * Relation Property Path to first join column key
            // * Relation Property Path + Column Path
            // * Column Database Name
            // * Column Property Name
            // * Column Property Path
            for (const relation of alias.metadata.relations){
                if (relation.joinColumns.length > 0) replacements[replaceAliasNamePrefix][relation.propertyPath] = relation.joinColumns[0].databaseName;
            }
            for (const relation of alias.metadata.relations){
                const allColumns = [
                    ...relation.joinColumns,
                    ...relation.inverseJoinColumns
                ];
                for (const joinColumn of allColumns){
                    const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;
                    replacements[replaceAliasNamePrefix][propertyKey] = joinColumn.databaseName;
                }
            }
            for (const column of alias.metadata.columns){
                replacements[replaceAliasNamePrefix][column.databaseName] = column.databaseName;
            }
            for (const column of alias.metadata.columns){
                replacements[replaceAliasNamePrefix][column.propertyName] = column.databaseName;
            }
            for (const column of alias.metadata.columns){
                replacements[replaceAliasNamePrefix][column.propertyPath] = column.databaseName;
            }
        }
        const replacementKeys = Object.keys(replacements);
        const replaceAliasNamePrefixes = replacementKeys.map((key)=>(0, escapeRegExp_1.escapeRegExp)(key)).join("|");
        if (replacementKeys.length > 0) {
            statement = statement.replace(new RegExp(// Avoid a lookbehind here since it's not well supported
            `([ =(]|^.{0})` + // any of ' =(' or start of line
            // followed by our prefix, e.g. 'tablename.' or ''
            `${replaceAliasNamePrefixes ? "(" + replaceAliasNamePrefixes + ")" : ""}([^ =(),]+)` + // a possible property name: sequence of anything but ' =(),'
            // terminated by ' =),' or end of line
            `(?=[ =),]|.{0}$)`, "gm"), (...matches)=>{
                let match, pre, p;
                if (replaceAliasNamePrefixes) {
                    match = matches[0];
                    pre = matches[1];
                    p = matches[3];
                    if (replacements[matches[2]][p]) {
                        return `${pre}${this.escape(matches[2].substring(0, matches[2].length - 1))}.${this.escape(replacements[matches[2]][p])}`;
                    }
                } else {
                    match = matches[0];
                    pre = matches[1];
                    p = matches[2];
                    if (replacements[""][p]) {
                        return `${pre}${this.escape(replacements[""][p])}`;
                    }
                }
                return match;
            });
        }
        return statement;
    }
    createComment() {
        if (!this.expressionMap.comment) {
            return "";
        }
        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`
        // In some dialects query nesting is available - but not all.  Because of this, we'll need
        // to scrub "ending" characters from the SQL but otherwise we can leave everything else
        // as-is and it should be valid.
        return `/* ${this.expressionMap.comment.replace(/\*\//g, "")} */ `;
    }
    /**
     * Time travel queries for CockroachDB
     */ createTimeTravelQuery() {
        if (this.expressionMap.queryType === "select" && this.expressionMap.timeTravel) {
            return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`;
        }
        return "";
    }
    /**
     * Creates "WHERE" expression.
     */ createWhereExpression() {
        const conditionsArray = [];
        const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);
        if (whereExpression.length > 0 && whereExpression !== "1=1") {
            conditionsArray.push(this.replacePropertyNames(whereExpression));
        }
        if (this.expressionMap.mainAlias.hasMetadata) {
            const metadata = this.expressionMap.mainAlias.metadata;
            // Adds the global condition of "non-deleted" for the entity with delete date columns in select query.
            if (this.expressionMap.queryType === "select" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {
                const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;
                const condition = `${this.replacePropertyNames(column)} IS NULL`;
                conditionsArray.push(condition);
            }
            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;
                const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;
                conditionsArray.push(condition);
            }
        }
        if (this.expressionMap.extraAppendedAndWhereCondition) {
            const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);
            conditionsArray.push(condition);
        }
        let condition = "";
        // time travel
        condition += this.createTimeTravelQuery();
        if (!conditionsArray.length) {
            condition += "";
        } else if (conditionsArray.length === 1) {
            condition += ` WHERE ${conditionsArray[0]}`;
        } else {
            condition += ` WHERE ( ${conditionsArray.join(" ) AND ( ")} )`;
        }
        return condition;
    }
    /**
     * Creates "RETURNING" / "OUTPUT" expression.
     */ createReturningExpression(returningType) {
        const columns = this.getReturningColumns();
        const driver = this.connection.driver;
        // also add columns we must auto-return to perform entity updation
        // if user gave his own returning
        if (typeof this.expressionMap.returning !== "string" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported(returningType)) {
            columns.push(...this.expressionMap.extraReturningColumns.filter((column)=>{
                return columns.indexOf(column) === -1;
            }));
        }
        if (columns.length) {
            let columnsExpression = columns.map((column)=>{
                const name = this.escape(column.databaseName);
                if (driver.options.type === "mssql") {
                    if (this.expressionMap.queryType === "insert" || this.expressionMap.queryType === "update" || this.expressionMap.queryType === "soft-delete" || this.expressionMap.queryType === "restore") {
                        return "INSERTED." + name;
                    } else {
                        return this.escape(this.getMainTableName()) + "." + name;
                    }
                } else {
                    return name;
                }
            }).join(", ");
            if (driver.options.type === "oracle") {
                columnsExpression += " INTO " + columns.map((column)=>{
                    return this.createParameter({
                        type: driver.columnTypeToNativeParameter(column.type),
                        dir: driver.oracle.BIND_OUT
                    });
                }).join(", ");
            }
            if (driver.options.type === "mssql") {
                if (this.expressionMap.queryType === "insert" || this.expressionMap.queryType === "update") {
                    columnsExpression += " INTO @OutputTable";
                }
            }
            return columnsExpression;
        } else if (typeof this.expressionMap.returning === "string") {
            return this.expressionMap.returning;
        }
        return "";
    }
    /**
     * If returning / output cause is set to array of column names,
     * then this method will return all column metadatas of those column names.
     */ getReturningColumns() {
        const columns = [];
        if (Array.isArray(this.expressionMap.returning)) {
            ;
            this.expressionMap.returning.forEach((columnName)=>{
                if (this.expressionMap.mainAlias.hasMetadata) {
                    columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));
                }
            });
        }
        return columns;
    }
    createWhereClausesExpression(clauses) {
        return clauses.map((clause, index)=>{
            const expression = this.createWhereConditionExpression(clause.condition);
            switch(clause.type){
                case "and":
                    return (index > 0 ? "AND " : "") + `${this.connection.options.isolateWhereStatements ? "(" : ""}${expression}${this.connection.options.isolateWhereStatements ? ")" : ""}`;
                case "or":
                    return (index > 0 ? "OR " : "") + `${this.connection.options.isolateWhereStatements ? "(" : ""}${expression}${this.connection.options.isolateWhereStatements ? ")" : ""}`;
            }
            return expression;
        }).join(" ").trim();
    }
    /**
     * Computes given where argument - transforms to a where string all forms it can take.
     */ createWhereConditionExpression(condition, alwaysWrap = false) {
        if (typeof condition === "string") return condition;
        if (Array.isArray(condition)) {
            if (condition.length === 0) {
                return "1=1";
            }
            // In the future we should probably remove this entire condition
            // but for now to prevent any breaking changes it exists.
            if (condition.length === 1 && !alwaysWrap) {
                return this.createWhereClausesExpression(condition);
            }
            return "(" + this.createWhereClausesExpression(condition) + ")";
        }
        const { driver } = this.connection;
        switch(condition.operator){
            case "lessThan":
                return `${condition.parameters[0]} < ${condition.parameters[1]}`;
            case "lessThanOrEqual":
                return `${condition.parameters[0]} <= ${condition.parameters[1]}`;
            case "arrayContains":
                return `${condition.parameters[0]} @> ${condition.parameters[1]}`;
            case "jsonContains":
                return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`;
            case "arrayContainedBy":
                return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;
            case "arrayOverlap":
                return `${condition.parameters[0]} && ${condition.parameters[1]}`;
            case "moreThan":
                return `${condition.parameters[0]} > ${condition.parameters[1]}`;
            case "moreThanOrEqual":
                return `${condition.parameters[0]} >= ${condition.parameters[1]}`;
            case "notEqual":
                return `${condition.parameters[0]} != ${condition.parameters[1]}`;
            case "equal":
                return `${condition.parameters[0]} = ${condition.parameters[1]}`;
            case "ilike":
                if (driver.options.type === "postgres" || driver.options.type === "cockroachdb") {
                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;
                }
                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;
            case "like":
                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;
            case "between":
                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;
            case "in":
                if (condition.parameters.length <= 1) {
                    return "0=1";
                }
                return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(", ")})`;
            case "any":
                if (driver.options.type === "cockroachdb") {
                    return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;
                }
                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;
            case "isNull":
                return `${condition.parameters[0]} IS NULL`;
            case "not":
                return `NOT(${this.createWhereConditionExpression(condition.condition)})`;
            case "brackets":
                return `${this.createWhereConditionExpression(condition.condition, true)}`;
            case "and":
                return "(" + condition.parameters.join(" AND ") + ")";
            case "or":
                return "(" + condition.parameters.join(" OR ") + ")";
        }
        throw new TypeError(`Unsupported FindOperator ${FindOperator_1.FindOperator.constructor.name}`);
    }
    createCteExpression() {
        if (!this.hasCommonTableExpressions()) {
            return "";
        }
        const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;
        const cteStrings = this.expressionMap.commonTableExpressions.map((cte)=>{
            let cteBodyExpression = typeof cte.queryBuilder === "string" ? cte.queryBuilder : "";
            if (typeof cte.queryBuilder !== "string") {
                if (cte.queryBuilder.hasCommonTableExpressions()) {
                    throw new error_1.TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);
                }
                cteBodyExpression = cte.queryBuilder.getQuery();
                if (!this.connection.driver.cteCapabilities.writable && !InstanceChecker_1.InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {
                    throw new error_1.TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);
                }
                this.setParameters(cte.queryBuilder.getParameters());
            }
            let cteHeader = this.escape(cte.alias);
            if (cte.options.columnNames) {
                const escapedColumnNames = cte.options.columnNames.map((column)=>this.escape(column));
                if (InstanceChecker_1.InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {
                    if (cte.queryBuilder.expressionMap.selects.length && cte.options.columnNames.length !== cte.queryBuilder.expressionMap.selects.length) {
                        throw new error_1.TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);
                    }
                }
                cteHeader += `(${escapedColumnNames.join(", ")})`;
            }
            const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint ? "RECURSIVE" : "";
            let materializeClause = "";
            if (this.connection.driver.cteCapabilities.materializedHint && cte.options.materialized !== undefined) {
                materializeClause = cte.options.materialized ? "MATERIALIZED" : "NOT MATERIALIZED";
            }
            return [
                recursiveClause,
                cteHeader,
                "AS",
                materializeClause,
                `(${cteBodyExpression})`
            ].filter(Boolean).join(" ");
        });
        return "WITH " + cteStrings.join(", ") + " ";
    }
    /**
     * Creates "WHERE" condition for an in-ids condition.
     */ getWhereInIdsCondition(ids) {
        const metadata = this.expressionMap.mainAlias.metadata;
        const normalized = (Array.isArray(ids) ? ids : [
            ids
        ]).map((id)=>metadata.ensureEntityIdMap(id));
        // using in(...ids) for single primary key entities
        if (!metadata.hasMultiplePrimaryKeys) {
            const primaryColumn = metadata.primaryColumns[0];
            // getEntityValue will try to transform `In`, it is a bug
            // todo: remove this transformer check after #2390 is fixed
            // This also fails for embedded & relation, so until that is fixed skip it.
            if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {
                return {
                    [primaryColumn.propertyName]: (0, In_1.In)(normalized.map((id)=>primaryColumn.getEntityValue(id, false)))
                };
            }
        }
        return new Brackets_1.Brackets((qb)=>{
            for (const data of normalized){
                qb.orWhere(new Brackets_1.Brackets((qb)=>qb.where(data)));
            }
        });
    }
    getExistsCondition(subQuery) {
        const query = subQuery.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select("1").setOption("disable-global-order");
        return [
            `EXISTS (${query.getQuery()})`,
            query.getParameters()
        ];
    }
    findColumnsForPropertyPath(propertyPath) {
        // Make a helper to iterate the entity & relations?
        // Use that to set the correct alias?  Or the other way around?
        // Start with the main alias with our property paths
        let alias = this.expressionMap.mainAlias;
        const root = [];
        const propertyPathParts = propertyPath.split(".");
        while(propertyPathParts.length > 1){
            const part = propertyPathParts[0];
            if (!alias?.hasMetadata) {
                break;
            }
            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {
                // If this is an embedded then we should combine the two as part of our lookup.
                // Instead of just breaking, we keep going with this in case there's an embedded/relation
                // inside an embedded.
                propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);
                continue;
            }
            if (alias.metadata.hasRelationWithPropertyPath(part)) {
                // If this is a relation then we should find the aliases
                // that match the relation & then continue further down
                // the property path
                const joinAttr = this.expressionMap.joinAttributes.find((joinAttr)=>joinAttr.relationPropertyPath === part);
                if (!joinAttr?.alias) {
                    const fullRelationPath = root.length > 0 ? `${root.join(".")}.${part}` : part;
                    throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);
                }
                alias = joinAttr.alias;
                root.push(...part.split("."));
                propertyPathParts.shift();
                continue;
            }
            break;
        }
        if (!alias) {
            throw new Error(`Cannot find alias for property ${propertyPath}`);
        }
        // Remaining parts are combined back and used to find the actual property path
        const aliasPropertyPath = propertyPathParts.join(".");
        const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);
        if (!columns.length) {
            throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, alias.metadata);
        }
        return [
            alias,
            root,
            columns
        ];
    }
    /**
     * Creates a property paths for a given ObjectLiteral.
     */ createPropertyPath(metadata, entity, prefix = "") {
        const paths = [];
        for (const key of Object.keys(entity)){
            const path = prefix ? `${prefix}.${key}` : key;
            // There's times where we don't actually want to traverse deeper.
            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.
            if (entity[key] === null || typeof entity[key] !== "object" || InstanceChecker_1.InstanceChecker.isFindOperator(entity[key])) {
                paths.push(path);
                continue;
            }
            if (metadata.hasEmbeddedWithPropertyPath(path)) {
                const subPaths = this.createPropertyPath(metadata, entity[key], path);
                paths.push(...subPaths);
                continue;
            }
            if (metadata.hasRelationWithPropertyPath(path)) {
                const relation = metadata.findRelationWithPropertyPath(path);
                // There's also cases where we don't want to return back all of the properties.
                // These handles the situation where someone passes the model & we don't need to make
                // a HUGE `where` to uniquely look up the entity.
                // In the case of a *-to-one, there's only ever one possible entity on the other side
                // so if the join columns are all defined we can return just the relation itself
                // because it will fetch only the join columns and do the lookup.
                if (relation.relationType === "one-to-one" || relation.relationType === "many-to-one") {
                    const joinColumns = relation.joinColumns.map((j)=>j.referencedColumn).filter((j)=>!!j);
                    const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every((column)=>column.getEntityValue(entity[key], false));
                    if (hasAllJoinColumns) {
                        paths.push(path);
                        continue;
                    }
                }
                if (relation.relationType === "one-to-many" || relation.relationType === "many-to-many") {
                    throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);
                }
                // For any other case, if the `entity[key]` contains all of the primary keys we can do a
                // lookup via these.  We don't need to look up via any other values 'cause these are
                // the unique primary keys.
                // This handles the situation where someone passes the model & we don't need to make
                // a HUGE where.
                const primaryColumns = relation.inverseEntityMetadata.primaryColumns;
                const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every((column)=>column.getEntityValue(entity[key], false));
                if (hasAllPrimaryKeys) {
                    const subPaths = primaryColumns.map((column)=>`${path}.${column.propertyPath}`);
                    paths.push(...subPaths);
                    continue;
                }
                // If nothing else, just return every property that's being passed to us.
                const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map((p)=>`${path}.${p}`);
                paths.push(...subPaths);
                continue;
            }
            paths.push(path);
        }
        return paths;
    }
    *getPredicates(where) {
        if (this.expressionMap.mainAlias.hasMetadata) {
            const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);
            for (const propertyPath of propertyPaths){
                const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);
                for (const column of columns){
                    let containedWhere = where;
                    for (const part of aliasPropertyPath){
                        if (!containedWhere || !(part in containedWhere)) {
                            containedWhere = {};
                            break;
                        }
                        containedWhere = containedWhere[part];
                    }
                    // Use the correct alias & the property path from the column
                    const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.${column.propertyPath}` : column.propertyPath;
                    const parameterValue = column.getEntityValue(containedWhere, true);
                    yield [
                        aliasPath,
                        parameterValue
                    ];
                }
            }
        } else {
            for (const key of Object.keys(where)){
                const parameterValue = where[key];
                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;
                yield [
                    aliasPath,
                    parameterValue
                ];
            }
        }
    }
    getWherePredicateCondition(aliasPath, parameterValue) {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(parameterValue)) {
            const parameters = [];
            if (parameterValue.useParameter) {
                if (parameterValue.objectLiteralParameters) {
                    this.setParameters(parameterValue.objectLiteralParameters);
                } else if (parameterValue.multipleParameters) {
                    for (const v of parameterValue.value){
                        parameters.push(this.createParameter(v));
                    }
                } else {
                    parameters.push(this.createParameter(parameterValue.value));
                }
            }
            if (parameterValue.type === "raw") {
                if (parameterValue.getSql) {
                    return parameterValue.getSql(aliasPath);
                } else {
                    return {
                        operator: "equal",
                        parameters: [
                            aliasPath,
                            parameterValue.value
                        ]
                    };
                }
            } else if (parameterValue.type === "not") {
                if (parameterValue.child) {
                    return {
                        operator: parameterValue.type,
                        condition: this.getWherePredicateCondition(aliasPath, parameterValue.child)
                    };
                } else {
                    return {
                        operator: "notEqual",
                        parameters: [
                            aliasPath,
                            ...parameters
                        ]
                    };
                }
            } else if (parameterValue.type === "and") {
                const values = parameterValue.value;
                return {
                    operator: parameterValue.type,
                    parameters: values.map((operator)=>this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))
                };
            } else if (parameterValue.type === "or") {
                const values = parameterValue.value;
                return {
                    operator: parameterValue.type,
                    parameters: values.map((operator)=>this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))
                };
            } else {
                return {
                    operator: parameterValue.type,
                    parameters: [
                        aliasPath,
                        ...parameters
                    ]
                };
            }
        } else if (parameterValue === null) {
            const nullBehavior = this.connection.options.invalidWhereValuesBehavior?.null || "ignore";
            if (nullBehavior === "sql-null") {
                return {
                    operator: "isNull",
                    parameters: [
                        aliasPath
                    ]
                };
            } else if (nullBehavior === "throw") {
                throw new error_1.TypeORMError(`Null value encountered in property '${aliasPath}' of a where condition. ` + `To match with SQL NULL, the IsNull() operator must be used. ` + `Set 'invalidWhereValuesBehavior.null' to 'ignore' or 'sql-null' in connection options to skip or handle null values.`);
            }
        } else if (parameterValue === undefined) {
            const undefinedBehavior = this.connection.options.invalidWhereValuesBehavior?.undefined || "ignore";
            if (undefinedBehavior === "throw") {
                throw new error_1.TypeORMError(`Undefined value encountered in property '${aliasPath}' of a where condition. ` + `Set 'invalidWhereValuesBehavior.undefined' to 'ignore' in connection options to skip properties with undefined values.`);
            }
        }
        return {
            operator: "equal",
            parameters: [
                aliasPath,
                this.createParameter(parameterValue)
            ]
        };
    }
    getWhereCondition(where) {
        if (typeof where === "string") {
            return where;
        }
        if (InstanceChecker_1.InstanceChecker.isBrackets(where)) {
            const whereQueryBuilder = this.createQueryBuilder();
            whereQueryBuilder.parentQueryBuilder = this;
            whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;
            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;
            whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;
            whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;
            whereQueryBuilder.expressionMap.wheres = [];
            where.whereFactory(whereQueryBuilder);
            return {
                operator: InstanceChecker_1.InstanceChecker.isNotBrackets(where) ? "not" : "brackets",
                condition: whereQueryBuilder.expressionMap.wheres
            };
        }
        if (typeof where === "function") {
            return where(this);
        }
        const wheres = Array.isArray(where) ? where : [
            where
        ];
        const clauses = [];
        for (const where of wheres){
            const conditions = [];
            // Filter the conditions and set up the parameter values
            for (const [aliasPath, parameterValue] of this.getPredicates(where)){
                conditions.push({
                    type: "and",
                    condition: this.getWherePredicateCondition(aliasPath, parameterValue)
                });
            }
            clauses.push({
                type: "or",
                condition: conditions
            });
        }
        if (clauses.length === 1) {
            return clauses[0].condition;
        }
        return clauses;
    }
    /**
     * Creates a query builder used to execute sql queries inside this query builder.
     */ obtainQueryRunner() {
        return this.queryRunner || this.connection.createQueryRunner();
    }
    hasCommonTableExpressions() {
        return this.expressionMap.commonTableExpressions.length > 0;
    }
}
exports.QueryBuilder = QueryBuilder;
/**
 * Contains all registered query builder classes.
 */ QueryBuilder.queryBuilderRegistry = {}; //# sourceMappingURL=QueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/result/DeleteResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeleteResult = void 0;
/**
 * Result object returned by DeleteQueryBuilder execution.
 */ class DeleteResult {
    static from(queryResult) {
        const result = new this();
        result.raw = queryResult.records;
        result.affected = queryResult.affected;
        return result;
    }
}
exports.DeleteResult = DeleteResult; //# sourceMappingURL=DeleteResult.js.map
}),
"[project]/node_modules/typeorm/query-builder/DeleteQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeleteQueryBuilder = void 0;
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const DeleteResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/DeleteResult.js [app-route] (ecmascript)");
const ReturningStatementNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ReturningStatementNotSupportedError.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */ class DeleteQueryBuilder extends QueryBuilder_1.QueryBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connectionOrQueryBuilder, queryRunner){
        super(connectionOrQueryBuilder, queryRunner);
        this["@instanceof"] = Symbol.for("DeleteQueryBuilder");
        this.expressionMap.aliasNamePrefixingEnabled = false;
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated SQL query without parameters being replaced.
     */ getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createDeleteExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
    }
    /**
     * Executes sql generated by query builder and returns raw database results.
     */ async execute() {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            // call before deletion methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                await queryRunner.broadcaster.broadcast("BeforeRemove", this.expressionMap.mainAlias.metadata);
            }
            // execute query
            const queryResult = await queryRunner.query(sql, parameters, true);
            const deleteResult = DeleteResult_1.DeleteResult.from(queryResult);
            // call after deletion methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                await queryRunner.broadcaster.broadcast("AfterRemove", this.expressionMap.mainAlias.metadata);
            }
            // close transaction if we started it
            if (transactionStartedByUs) await queryRunner.commitTransaction();
            return deleteResult;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) {
                // means we created our own query runner
                await queryRunner.release();
            }
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Specifies FROM which entity's table select/update/delete will be executed.
     * Also sets a main string alias of the selection data.
     */ from(entityTarget, aliasName) {
        entityTarget = InstanceChecker_1.InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
    }
    /**
     * Sets WHERE condition in the query builder.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     * Additionally you can add parameters used in where expression.
     */ where(where, parameters) {
        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
        const condition = this.getWhereCondition(where);
        if (condition) this.expressionMap.wheres = [
            {
                type: "simple",
                condition: condition
            }
        ];
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ andWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "and",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new OR WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ orWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "or",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Sets WHERE condition in the query builder with a condition for the given ids.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     */ whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     */ andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new OR WHERE with conditions for the given ids.
     */ orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Optional returning/output clause.
     */ output(output) {
        return this.returning(output);
    }
    /**
     * Optional returning/output clause.
     */ returning(returning) {
        // not all databases support returning/output cause
        if (!this.connection.driver.isReturningSqlSupported("delete")) {
            throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates DELETE express used to perform query.
     */ createDeleteExpression() {
        const tableName = this.getTableName(this.getMainTableName());
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression("delete");
        if (returningExpression === "") {
            return `DELETE FROM ${tableName}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "mssql") {
            return `DELETE FROM ${tableName} OUTPUT ${returningExpression}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "spanner") {
            return `DELETE FROM ${tableName}${whereExpression} THEN RETURN ${returningExpression}`;
        }
        return `DELETE FROM ${tableName}${whereExpression} RETURNING ${returningExpression}`;
    }
}
exports.DeleteQueryBuilder = DeleteQueryBuilder; //# sourceMappingURL=DeleteQueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/result/InsertResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InsertResult = void 0;
/**
 * Result object returned by InsertQueryBuilder execution.
 */ class InsertResult {
    constructor(){
        /**
         * Contains inserted entity id.
         * Has entity-like structure (not just column database name and values).
         */ this.identifiers = [];
        /**
         * Generated values returned by a database.
         * Has entity-like structure (not just column database name and values).
         */ this.generatedMaps = [];
    }
    static from(queryResult) {
        const result = new this();
        result.raw = queryResult.raw;
        return result;
    }
}
exports.InsertResult = InsertResult; //# sourceMappingURL=InsertResult.js.map
}),
"[project]/node_modules/typeorm/query-builder/ReturningResultsEntityUpdator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReturningResultsEntityUpdator = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Updates entity with returning results in the entity insert and update operations.
 */ class ReturningResultsEntityUpdator {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryRunner, expressionMap){
        this.queryRunner = queryRunner;
        this.expressionMap = expressionMap;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Updates entities with a special columns after updation query execution.
     */ async update(updateResult, entities) {
        const metadata = this.expressionMap.mainAlias.metadata;
        await Promise.all(entities.map(async (entity, entityIndex)=>{
            // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query
            if (this.queryRunner.connection.driver.isReturningSqlSupported("update")) {
                if (this.queryRunner.connection.driver.options.type === "oracle" && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {
                    updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex)=>{
                        newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];
                        return newRaw;
                    }, {});
                }
                const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;
                const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);
                if (returningColumns) {
                    this.queryRunner.manager.merge(metadata.target, entity, returningColumns);
                    updateResult.generatedMaps.push(returningColumns);
                }
            } else {
                // for driver which do not support returning/output statement we need to perform separate query and load what we need
                const updationColumns = this.expressionMap.extraReturningColumns;
                if (updationColumns.length > 0) {
                    // get entity id by which we will get needed data
                    const entityId = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);
                    if (!entityId) throw new error_1.TypeORMError(`Cannot update entity because entity id is not set in the entity.`);
                    // execute query to get needed data
                    const loadedReturningColumns = await this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map((column)=>metadata.targetName + "." + column.propertyPath)).addSelect(updationColumns.map((column)=>metadata.targetName + "." + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityId).withDeleted().setOption("create-pojo") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process
                    .getOne();
                    if (loadedReturningColumns) {
                        this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);
                        updateResult.generatedMaps.push(loadedReturningColumns);
                    }
                }
            }
        }));
    }
    /**
     * Updates entities with a special columns after insertion query execution.
     */ async insert(insertResult, entities) {
        const metadata = this.expressionMap.mainAlias.metadata;
        let insertionColumns = metadata.getInsertionReturningColumns();
        // to prevent extra select SQL execution for databases not supporting RETURNING
        // in the case if we have generated column and it's value returned by underlying driver
        // we remove this column from the insertionColumns list
        const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported("insert");
        insertionColumns = insertionColumns.filter((column)=>{
            if (!column.isGenerated) return true;
            return needToCheckGenerated === true;
        });
        const generatedMaps = entities.map((entity, entityIndex)=>{
            if (Array.isArray(insertResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {
                if (this.queryRunner.connection.driver.options.type === "oracle") {
                    insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex)=>{
                        newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];
                        return newRaw;
                    }, {});
                } else if (this.queryRunner.connection.driver.options.type === "spanner") {
                    insertResult.raw = insertResult.raw[0];
                }
            }
            // get all values generated by a database for us
            const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;
            const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};
            if (entityIndex in this.expressionMap.locallyGenerated) {
                this.queryRunner.manager.merge(metadata.target, generatedMap, this.expressionMap.locallyGenerated[entityIndex]);
            }
            this.queryRunner.manager.merge(metadata.target, entity, generatedMap);
            return generatedMap;
        });
        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values
        // for other drivers we have to re-select this data from the database
        if (insertionColumns.length > 0 && !this.queryRunner.connection.driver.isReturningSqlSupported("insert")) {
            const entityIds = entities.map((entity)=>{
                const entityId = metadata.getEntityIdMap(entity);
                // We have to check for an empty `entityId` - if we don't, the query against the database
                // effectively drops the `where` clause entirely and the first record will be returned -
                // not what we want at all.
                if (!entityId) throw new error_1.TypeORMError(`Cannot update entity because entity id is not set in the entity.`);
                return entityId;
            });
            // to select just inserted entities we need a criteria to select by.
            // for newly inserted entities in drivers which do not support returning statement
            // row identifier can only be an increment column
            // (since its the only thing that can be generated by those databases)
            // or (and) other primary key which is defined by a user and inserted value has it
            const returningResult = await this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map((column)=>metadata.targetName + "." + column.propertyPath)).addSelect(insertionColumns.map((column)=>metadata.targetName + "." + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityIds).setOption("create-pojo") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process
            .getMany();
            entities.forEach((entity, entityIndex)=>{
                this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult[entityIndex]);
                this.queryRunner.manager.merge(metadata.target, entity, returningResult[entityIndex]);
            });
        }
        entities.forEach((entity, entityIndex)=>{
            const entityId = metadata.getEntityIdMap(entity);
            insertResult.identifiers.push(entityId);
            insertResult.generatedMaps.push(generatedMaps[entityIndex]);
        });
    }
    /**
     * Columns we need to be returned from the database when we update entity.
     */ getUpdationReturningColumns() {
        return this.expressionMap.mainAlias.metadata.columns.filter((column)=>{
            return column.asExpression !== undefined || column.isUpdateDate || column.isVersion;
        });
    }
    /**
     * Columns we need to be returned from the database when we soft delete and restore entity.
     */ getSoftDeletionReturningColumns() {
        return this.expressionMap.mainAlias.metadata.columns.filter((column)=>{
            return column.asExpression !== undefined || column.isUpdateDate || column.isVersion || column.isDeleteDate;
        });
    }
}
exports.ReturningResultsEntityUpdator = ReturningResultsEntityUpdator; //# sourceMappingURL=ReturningResultsEntityUpdator.js.map
}),
"[project]/node_modules/typeorm/query-builder/InsertQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InsertQueryBuilder = void 0;
const uuid_1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/cjs/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InsertValuesMissingError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/InsertValuesMissingError.js [app-route] (ecmascript)");
const ReturningStatementNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ReturningStatementNotSupportedError.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const InsertResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/InsertResult.js [app-route] (ecmascript)");
const ReturningResultsEntityUpdator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/ReturningResultsEntityUpdator.js [app-route] (ecmascript)");
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
    constructor(){
        super(...arguments);
        this["@instanceof"] = Symbol.for("InsertQueryBuilder");
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated SQL query without parameters being replaced.
     */ getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createInsertExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
    }
    /**
     * Executes sql generated by query builder and returns raw database results.
     */ async execute() {
        // console.time(".value sets");
        const valueSets = this.getValueSets();
        // console.timeEnd(".value sets");
        // If user passed empty array of entities then we don't need to do
        // anything.
        //
        // Fixes GitHub issues #3111 and #5734. If we were to let this through
        // we would run into problems downstream, like subscribers getting
        // invoked with the empty array where they expect an entity, and SQL
        // queries with an empty VALUES clause.
        if (valueSets.length === 0) return new InsertResult_1.InsertResult();
        // console.time("QueryBuilder.execute");
        // console.time(".database stuff");
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            // console.timeEnd(".database stuff");
            // call before insertion methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                const broadcastResult = new BroadcasterResult_1.BroadcasterResult();
                valueSets.forEach((valueSet)=>{
                    queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);
                });
                await broadcastResult.wait();
            }
            let declareSql = null;
            let selectOutputSql = null;
            // if update entity mode is enabled we may need extra columns for the returning statement
            // console.time(".prepare returning statement");
            const returningResultsEntityUpdator = new ReturningResultsEntityUpdator_1.ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
            const returningColumns = [];
            if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {
                for (const columnPath of this.expressionMap.returning){
                    returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));
                }
            }
            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {
                if (!(valueSets.length > 1 && this.connection.driver.options.type === "oracle")) {
                    this.expressionMap.extraReturningColumns = this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();
                }
                returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c)=>!returningColumns.includes(c)));
            }
            if (returningColumns.length > 0 && this.connection.driver.options.type === "mssql") {
                declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
                selectOutputSql = `SELECT * FROM @OutputTable`;
            }
            // console.timeEnd(".prepare returning statement");
            // execute query
            // console.time(".getting query and parameters");
            const [insertSql, parameters] = this.getQueryAndParameters();
            // console.timeEnd(".getting query and parameters");
            // console.time(".query execution by database");
            const statements = [
                declareSql,
                insertSql,
                selectOutputSql
            ];
            const sql = statements.filter((s)=>s != null).join(";\n\n");
            const queryResult = await queryRunner.query(sql, parameters, true);
            const insertResult = InsertResult_1.InsertResult.from(queryResult);
            // console.timeEnd(".query execution by database");
            // load returning results and set them to the entity if entity updation is enabled
            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {
                // console.time(".updating entity");
                await returningResultsEntityUpdator.insert(insertResult, valueSets);
            // console.timeEnd(".updating entity");
            }
            // call after insertion methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                const broadcastResult = new BroadcasterResult_1.BroadcasterResult();
                valueSets.forEach((valueSet)=>{
                    queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);
                });
                await broadcastResult.wait();
            }
            // close transaction if we started it
            // console.time(".commit");
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            // console.timeEnd(".commit");
            return insertResult;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            // console.time(".releasing connection");
            if (queryRunner !== this.queryRunner) {
                // means we created our own query runner
                await queryRunner.release();
            }
        // console.timeEnd(".releasing connection");
        // console.timeEnd("QueryBuilder.execute");
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Specifies INTO which entity's table insertion will be executed.
     */ into(entityTarget, columns) {
        entityTarget = InstanceChecker_1.InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget);
        this.expressionMap.setMainAlias(mainAlias);
        this.expressionMap.insertColumns = columns || [];
        return this;
    }
    /**
     * Values needs to be inserted into table.
     */ values(values) {
        this.expressionMap.valuesSet = values;
        return this;
    }
    /**
     * Optional returning/output clause.
     */ output(output) {
        return this.returning(output);
    }
    /**
     * Optional returning/output clause.
     */ returning(returning) {
        // not all databases support returning/output cause
        if (!this.connection.driver.isReturningSqlSupported("insert")) {
            throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
    }
    /**
     * Indicates if entity must be updated after insertion operations.
     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
     * Enabled by default.
     */ updateEntity(enabled) {
        this.expressionMap.updateEntity = enabled;
        return this;
    }
    /**
     * Adds additional ON CONFLICT statement supported in postgres and cockroach.
     *
     * @deprecated Use `orIgnore` or `orUpdate`
     */ onConflict(statement) {
        this.expressionMap.onConflict = statement;
        return this;
    }
    /**
     * Adds additional ignore statement supported in databases.
     */ orIgnore(statement = true) {
        this.expressionMap.onIgnore = !!statement;
        return this;
    }
    /**
     * Adds additional update statement supported in databases.
     */ orUpdate(statementOrOverwrite, conflictTarget, orUpdateOptions) {
        const { where, parameters } = orUpdateOptions?.overwriteCondition ?? {};
        let wheres;
        if (where) {
            const condition = this.getWhereCondition(where);
            if (Array.isArray(condition) ? condition.length !== 0 : condition) wheres = [
                {
                    type: "simple",
                    condition: condition
                }
            ];
        }
        if (parameters) this.setParameters(parameters);
        if (!Array.isArray(statementOrOverwrite)) {
            this.expressionMap.onUpdate = {
                conflict: statementOrOverwrite?.conflict_target,
                columns: statementOrOverwrite?.columns,
                overwrite: statementOrOverwrite?.overwrite,
                skipUpdateIfNoValuesChanged: orUpdateOptions?.skipUpdateIfNoValuesChanged,
                upsertType: orUpdateOptions?.upsertType,
                overwriteCondition: wheres
            };
            return this;
        }
        this.expressionMap.onUpdate = {
            overwrite: statementOrOverwrite,
            conflict: conflictTarget,
            skipUpdateIfNoValuesChanged: orUpdateOptions?.skipUpdateIfNoValuesChanged,
            indexPredicate: orUpdateOptions?.indexPredicate,
            upsertType: orUpdateOptions?.upsertType,
            overwriteCondition: wheres
        };
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates INSERT express used to perform insert query.
     */ createInsertExpression() {
        if (this.expressionMap.onUpdate || this.expressionMap.onIgnore) {
            if ((this.expressionMap.onUpdate?.upsertType ?? "merge-into") === "merge-into" && this.connection.driver.supportedUpsertTypes.includes("merge-into")) return this.createMergeExpression();
        }
        const tableName = this.getTableName(this.getMainTableName());
        const tableOrAliasName = this.alias !== this.getMainTableName() ? this.escape(this.alias) : tableName;
        const valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important
        const returningExpression = this.connection.driver.options.type === "oracle" && this.getValueSets().length > 1 ? null : this.createReturningExpression("insert"); // oracle doesnt support returning with multi-row insert
        const columnsExpression = this.createColumnNamesExpression();
        let query = "INSERT ";
        if (this.expressionMap.onUpdate?.upsertType === "primary-key") {
            query = "UPSERT ";
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
            query += `${this.expressionMap.onIgnore ? " IGNORE " : ""}`;
        }
        query += `INTO ${tableName}`;
        if (this.alias !== this.getMainTableName() && DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
            query += ` AS "${this.alias}"`;
        }
        // add columns expression
        if (columnsExpression) {
            query += `(${columnsExpression})`;
        } else {
            if (!valuesExpression && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql")) // special syntax for mysql DEFAULT VALUES insertion
            query += "()";
        }
        // add OUTPUT expression
        if (returningExpression && this.connection.driver.options.type === "mssql") {
            query += ` OUTPUT ${returningExpression}`;
        }
        // add VALUES expression
        if (valuesExpression) {
            if ((this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "sap") && this.getValueSets().length > 1) {
                query += ` ${valuesExpression}`;
            } else {
                query += ` VALUES ${valuesExpression}`;
            }
        } else {
            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
                // special syntax for mysql DEFAULT VALUES insertion
                query += " VALUES ()";
            } else {
                query += ` DEFAULT VALUES`;
            }
        }
        if (this.expressionMap.onUpdate?.upsertType !== "primary-key") {
            if (this.connection.driver.supportedUpsertTypes.includes("on-conflict-do-update")) {
                if (this.expressionMap.onIgnore) {
                    query += " ON CONFLICT DO NOTHING ";
                } else if (this.expressionMap.onConflict) {
                    query += ` ON CONFLICT ${this.expressionMap.onConflict} `;
                } else if (this.expressionMap.onUpdate) {
                    const { overwrite, columns, conflict, skipUpdateIfNoValuesChanged, indexPredicate } = this.expressionMap.onUpdate;
                    let conflictTarget = "ON CONFLICT";
                    if (Array.isArray(conflict)) {
                        conflictTarget += ` ( ${conflict.map((column)=>this.escape(column)).join(", ")} )`;
                        if (indexPredicate && !DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
                            throw new error_1.TypeORMError(`indexPredicate option is not supported by the current database driver`);
                        }
                        if (indexPredicate && DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
                            conflictTarget += ` WHERE ( ${indexPredicate} )`;
                        }
                    } else if (conflict) {
                        conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`;
                    }
                    const updatePart = [];
                    if (Array.isArray(overwrite)) {
                        updatePart.push(...overwrite.map((column)=>`${this.escape(column)} = EXCLUDED.${this.escape(column)}`));
                    } else if (columns) {
                        updatePart.push(...columns.map((column)=>`${this.escape(column)} = :${column}`));
                    }
                    if (updatePart.length > 0) {
                        query += ` ${conflictTarget} DO UPDATE SET `;
                        updatePart.push(...this.expressionMap.mainAlias.metadata.columns.filter((column)=>column.isUpdateDate && !overwrite?.includes(column.databaseName) && !(this.connection.driver.options.type === "oracle" && this.getValueSets().length > 1 || DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner")).map((column)=>`${this.escape(column.databaseName)} = DEFAULT`));
                        query += updatePart.join(", ");
                    }
                    if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged) {
                        this.expressionMap.onUpdate.overwriteCondition ??= [];
                        const wheres = overwrite.map((column)=>({
                                type: "or",
                                condition: `${tableOrAliasName}.${this.escape(column)} IS DISTINCT FROM EXCLUDED.${this.escape(column)}`
                            }));
                        this.expressionMap.onUpdate.overwriteCondition.push({
                            type: "and",
                            condition: wheres
                        });
                    }
                    if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) && this.expressionMap.onUpdate.overwriteCondition && this.expressionMap.onUpdate.overwriteCondition.length > 0) {
                        query += ` WHERE ${this.createUpsertConditionExpression()}`;
                    }
                }
            } else if (this.connection.driver.supportedUpsertTypes.includes("on-duplicate-key-update")) {
                if (this.expressionMap.onUpdate) {
                    const { overwrite, columns } = this.expressionMap.onUpdate;
                    if (Array.isArray(overwrite)) {
                        query += " ON DUPLICATE KEY UPDATE ";
                        query += overwrite.map((column)=>`${this.escape(column)} = VALUES(${this.escape(column)})`).join(", ");
                        query += " ";
                    } else if (Array.isArray(columns)) {
                        query += " ON DUPLICATE KEY UPDATE ";
                        query += columns.map((column)=>`${this.escape(column)} = :${column}`).join(", ");
                        query += " ";
                    }
                }
            } else {
                if (this.expressionMap.onUpdate) {
                    throw new error_1.TypeORMError(`onUpdate is not supported by the current database driver`);
                }
            }
        }
        // add RETURNING expression
        if (returningExpression && (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) || this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "cockroachdb" || DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver))) {
            query += ` RETURNING ${returningExpression}`;
        }
        if (returningExpression && this.connection.driver.options.type === "spanner") {
            query += ` THEN RETURN ${returningExpression}`;
        }
        // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT
        // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)
        if (this.connection.driver.options.type === "mssql" && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.mainAlias.metadata.columns.filter((column)=>this.expressionMap.insertColumns.length > 0 ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert).some((column)=>this.isOverridingAutoIncrementBehavior(column))) {
            query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;
        }
        return query;
    }
    /**
     * Gets list of columns where values must be inserted to.
     */ getInsertedColumns() {
        if (!this.expressionMap.mainAlias.hasMetadata) return [];
        return this.expressionMap.mainAlias.metadata.columns.filter((column)=>{
            // if user specified list of columns he wants to insert to, then we filter only them
            if (this.expressionMap.insertColumns.length) return this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1;
            // skip columns the user doesn't want included by default
            if (!column.isInsert) {
                return false;
            }
            // if user did not specified such list then return all columns except auto-increment one
            // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression
            if (column.isGenerated && column.generationStrategy === "increment" && !(this.connection.driver.options.type === "spanner") && !(this.connection.driver.options.type === "oracle") && !DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) && !DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) && !(this.connection.driver.options.type === "aurora-mysql") && !(this.connection.driver.options.type === "mssql" && this.isOverridingAutoIncrementBehavior(column))) return false;
            return true;
        });
    }
    /**
     * Creates a columns string where values must be inserted to for INSERT INTO expression.
     */ createColumnNamesExpression() {
        const columns = this.getInsertedColumns();
        if (columns.length > 0) return columns.map((column)=>this.escape(column.databaseName)).join(", ");
        // in the case if there are no insert columns specified and table without metadata used
        // we get columns from the inserted value map, in the case if only one inserted map is specified
        if (!this.expressionMap.mainAlias.hasMetadata && !this.expressionMap.insertColumns.length) {
            const valueSets = this.getValueSets();
            if (valueSets.length === 1) return Object.keys(valueSets[0]).map((columnName)=>this.escape(columnName)).join(", ");
        }
        // get a table name and all column database names
        return this.expressionMap.insertColumns.map((columnName)=>this.escape(columnName)).join(", ");
    }
    /**
     * Creates list of values needs to be inserted in the VALUES expression.
     */ createValuesExpression() {
        const valueSets = this.getValueSets();
        const columns = this.getInsertedColumns();
        // if column metadatas are given then apply all necessary operations with values
        if (columns.length > 0) {
            let expression = "";
            valueSets.forEach((valueSet, valueSetIndex)=>{
                columns.forEach((column, columnIndex)=>{
                    if (columnIndex === 0) {
                        if (this.connection.driver.options.type === "oracle" && valueSets.length > 1) {
                            expression += " SELECT ";
                        } else if (this.connection.driver.options.type === "sap" && valueSets.length > 1) {
                            expression += " SELECT ";
                        } else {
                            expression += "(";
                        }
                    }
                    expression += this.createColumnValueExpression(valueSets, valueSetIndex, column);
                    if (columnIndex === columns.length - 1) {
                        if (valueSetIndex === valueSets.length - 1) {
                            if ([
                                "oracle",
                                "sap"
                            ].includes(this.connection.driver.options.type) && valueSets.length > 1) {
                                expression += " FROM " + this.connection.driver.dummyTableName;
                            } else {
                                expression += ")";
                            }
                        } else {
                            if ([
                                "oracle",
                                "sap"
                            ].includes(this.connection.driver.options.type) && valueSets.length > 1) {
                                expression += " FROM " + this.connection.driver.dummyTableName + " UNION ALL ";
                            } else {
                                expression += "), ";
                            }
                        }
                    } else {
                        expression += ", ";
                    }
                });
            });
            if (expression === "()") return "";
            return expression;
        } else {
            // for tables without metadata
            // get values needs to be inserted
            let expression = "";
            valueSets.forEach((valueSet, insertionIndex)=>{
                const columns = Object.keys(valueSet);
                columns.forEach((columnName, columnIndex)=>{
                    if (columnIndex === 0) {
                        expression += "(";
                    }
                    const value = valueSet[columnName];
                    // support for SQL expressions in queries
                    if (typeof value === "function") {
                        expression += value();
                    // if value for this column was not provided then insert default value
                    } else if (value === undefined) {
                        if (this.connection.driver.options.type === "oracle" && valueSets.length > 1 || DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
                            expression += "NULL";
                        } else {
                            expression += "DEFAULT";
                        }
                    } else if (value === null && this.connection.driver.options.type === "spanner") {
                    // just any other regular value
                    } else {
                        expression += this.createParameter(value);
                    }
                    if (columnIndex === Object.keys(valueSet).length - 1) {
                        if (insertionIndex === valueSets.length - 1) {
                            expression += ")";
                        } else {
                            expression += "), ";
                        }
                    } else {
                        expression += ", ";
                    }
                });
            });
            if (expression === "()") return "";
            return expression;
        }
    }
    /**
     * Gets array of values need to be inserted into the target table.
     */ getValueSets() {
        if (Array.isArray(this.expressionMap.valuesSet)) return this.expressionMap.valuesSet;
        if (ObjectUtils_1.ObjectUtils.isObject(this.expressionMap.valuesSet)) return [
            this.expressionMap.valuesSet
        ];
        throw new InsertValuesMissingError_1.InsertValuesMissingError();
    }
    /**
     * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.
     *
     * @param column
     */ isOverridingAutoIncrementBehavior(column) {
        return column.isPrimary && column.isGenerated && column.generationStrategy === "increment" && this.getValueSets().some((valueSet)=>column.getEntityValue(valueSet) !== undefined && column.getEntityValue(valueSet) !== null);
    }
    /**
     * Creates MERGE express used to perform insert query.
     */ createMergeExpression() {
        if (!this.connection.driver.supportedUpsertTypes.includes("merge-into")) throw new error_1.TypeORMError(`Upsert type "merge-into" is not supported by current database driver`);
        if (this.expressionMap.onUpdate?.upsertType && this.expressionMap.onUpdate.upsertType !== "merge-into") {
            throw new error_1.TypeORMError(`Upsert type "${this.expressionMap.onUpdate.upsertType}" is not supported by current database driver`);
        }
        // const mainAlias = this.expressionMap.mainAlias!
        const tableName = this.getTableName(this.getMainTableName());
        const tableAlias = this.escape(this.alias);
        const columns = this.getInsertedColumns();
        const columnsExpression = this.createColumnNamesExpression();
        let query = `MERGE INTO ${tableName} ${this.escape(this.alias)}`;
        const mergeSourceAlias = this.escape("mergeIntoSource");
        const mergeSourceExpression = this.createMergeIntoSourceExpression(mergeSourceAlias);
        query += ` ${mergeSourceExpression}`;
        // build on condition
        if (this.expressionMap.onIgnore) {
            const primaryKey = columns.find((column)=>column.isPrimary);
            if (primaryKey) {
                query += ` ON (${tableAlias}.${this.escape(primaryKey.databaseName)} = ${mergeSourceAlias}.${this.escape(primaryKey.databaseName)})`;
            } else {
                query += `ON (${this.expressionMap.mainAlias.metadata.uniques.map((unique)=>{
                    return `(${unique.columns.map((column)=>{
                        return `${tableAlias}.${this.escape(column.databaseName)} = ${mergeSourceAlias}.${this.escape(column.databaseName)}`;
                    }).join(" AND ")})`;
                }).join(" OR ")})`;
            }
        } else if (this.expressionMap.onUpdate) {
            const { conflict, indexPredicate } = this.expressionMap.onUpdate;
            if (indexPredicate) {
                throw new error_1.TypeORMError(`indexPredicate option is not supported by upsert type "merge-into"`);
            }
            if (Array.isArray(conflict)) {
                query += ` ON (${conflict.map((column)=>`${tableAlias}.${this.escape(column)} = ${mergeSourceAlias}.${this.escape(column)}`).join(" AND ")})`;
            } else if (conflict) {
                query += ` ON (${tableAlias}.${this.escape(conflict)} = ${mergeSourceAlias}.${this.escape(conflict)})`;
            } else {
                query += `ON (${this.expressionMap.mainAlias.metadata.uniques.map((unique)=>{
                    return `(${unique.columns.map((column)=>{
                        return `${tableAlias}.${this.escape(column.databaseName)} = ${mergeSourceAlias}.${this.escape(column.databaseName)}`;
                    }).join(" AND ")})`;
                }).join(" OR ")})`;
            }
        }
        if (this.expressionMap.onUpdate) {
            const { overwrite, columns, conflict, skipUpdateIfNoValuesChanged } = this.expressionMap.onUpdate;
            let updateExpression = "";
            if (Array.isArray(overwrite)) {
                updateExpression += (overwrite || columns)?.filter((column)=>!conflict?.includes(column)).map((column)=>`${tableAlias}.${this.escape(column)} = ${mergeSourceAlias}.${this.escape(column)}`).join(", ");
            }
            if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged) {
                this.expressionMap.onUpdate.overwriteCondition ??= [];
                const wheres = overwrite.map((column)=>({
                        type: "or",
                        condition: {
                            operator: "notEqual",
                            parameters: [
                                `${tableAlias}.${this.escape(column)}`,
                                `${mergeSourceAlias}.${this.escape(column)}`
                            ]
                        }
                    }));
                this.expressionMap.onUpdate.overwriteCondition.push({
                    type: "and",
                    condition: wheres
                });
            }
            const mergeCondition = this.createUpsertConditionExpression();
            if (updateExpression.trim()) {
                if ((this.connection.driver.options.type === "mssql" || this.connection.driver.options.type === "sap") && mergeCondition != "") {
                    query += ` WHEN MATCHED AND ${mergeCondition} THEN UPDATE SET ${updateExpression}`;
                } else {
                    query += ` WHEN MATCHED THEN UPDATE SET ${updateExpression}`;
                    if (mergeCondition != "") {
                        query += ` WHERE ${mergeCondition}`;
                    }
                }
            }
        }
        const valuesExpression = this.createMergeIntoInsertValuesExpression(mergeSourceAlias);
        const returningExpression = this.connection.driver.options.type === "mssql" ? this.createReturningExpression("insert") : null;
        query += " WHEN NOT MATCHED THEN INSERT";
        // add columns expression
        if (columnsExpression) {
            query += `(${columnsExpression})`;
        }
        // add VALUES expression
        if (valuesExpression) {
            query += ` VALUES ${valuesExpression}`;
        }
        // add OUTPUT expression
        if (returningExpression && this.connection.driver.options.type === "mssql") {
            query += ` OUTPUT ${returningExpression}`;
        }
        if (this.connection.driver.options.type === "mssql") {
            query += `;`;
        }
        return query;
    }
    /**
     * Creates list of values needs to be inserted in the VALUES expression.
     */ createMergeIntoSourceExpression(mergeSourceAlias) {
        const valueSets = this.getValueSets();
        const columns = this.getInsertedColumns();
        let expression = "USING (";
        // if column metadatas are given then apply all necessary operations with values
        if (columns.length > 0) {
            if (this.connection.driver.options.type === "mssql") {
                expression += "VALUES ";
            }
            valueSets.forEach((valueSet, valueSetIndex)=>{
                columns.forEach((column, columnIndex)=>{
                    if (columnIndex === 0) {
                        if (this.connection.driver.options.type === "mssql") {
                            expression += "(";
                        } else {
                            expression += "SELECT ";
                        }
                    }
                    const value = column.getEntityValue(valueSet);
                    if (value === undefined && !(column.isGenerated && column.generationStrategy === "uuid" && !this.connection.driver.isUUIDGenerationSupported())) {
                        if (column.default !== undefined && column.default !== null) {
                            // try to use default defined in the column
                            expression += this.connection.driver.normalizeDefault(column);
                        } else {
                            expression += "NULL"; // otherwise simply use NULL and pray if column is nullable
                        }
                    } else if (value === null) {
                        expression += "NULL";
                    } else {
                        expression += this.createColumnValueExpression(valueSets, valueSetIndex, column);
                    }
                    if (this.connection.driver.options.type !== "mssql") expression += ` AS ${this.escape(column.databaseName)}`;
                    if (columnIndex === columns.length - 1) {
                        if (valueSetIndex === valueSets.length - 1) {
                            if ([
                                "oracle",
                                "sap"
                            ].includes(this.connection.driver.options.type)) {
                                expression += " FROM " + this.connection.driver.dummyTableName;
                            } else if (this.connection.driver.options.type === "mssql") {
                                expression += ")";
                            }
                        } else {
                            if ([
                                "oracle",
                                "sap"
                            ].includes(this.connection.driver.options.type) && valueSets.length > 1) {
                                expression += " FROM " + this.connection.driver.dummyTableName + " UNION ALL ";
                            } else if (this.connection.driver.options.type === "mssql") {
                                expression += "), ";
                            } else {
                                expression += " UNION ALL ";
                            }
                        }
                    } else {
                        expression += ", ";
                    }
                });
            });
        } else {
            // for tables without metadata
            throw new error_1.TypeORMError('Upsert type "merge-into" is not supported without metadata tables');
        }
        expression += `) ${mergeSourceAlias}`;
        if (this.connection.driver.options.type === "mssql") expression += ` (${columns.map((column)=>this.escape(column.databaseName)).join(", ")})`;
        return expression;
    }
    /**
     * Creates list of values needs to be inserted in the VALUES expression.
     */ createMergeIntoInsertValuesExpression(mergeSourceAlias) {
        const columns = this.getInsertedColumns();
        let expression = "";
        // if column metadatas are given then apply all necessary operations with values
        if (columns.length > 0) {
            columns.forEach((column, columnIndex)=>{
                if (columnIndex === 0) {
                    expression += "(";
                }
                if (column.isGenerated && column.generationStrategy === "uuid" && this.connection.driver.isUUIDGenerationSupported() || column.isGenerated && column.generationStrategy !== "uuid") {
                    expression += `DEFAULT`;
                } else {
                    expression += `${mergeSourceAlias}.${this.escape(column.databaseName)}`;
                }
                if (columnIndex === columns.length - 1) {
                    expression += ")";
                } else {
                    expression += ", ";
                }
            });
        } else {
            // for tables without metadata
            throw new error_1.TypeORMError('Upsert type "merge-into" is not supported without metadata tables');
        }
        if (expression === "()") return "";
        return expression;
    }
    /**
     * Create upsert search condition expression.
     */ createUpsertConditionExpression() {
        if (!this.expressionMap.onUpdate.overwriteCondition) return "";
        const conditionsArray = [];
        const whereExpression = this.createWhereClausesExpression(this.expressionMap.onUpdate.overwriteCondition);
        if (whereExpression.length > 0 && whereExpression !== "1=1") {
            conditionsArray.push(whereExpression);
        }
        if (this.expressionMap.mainAlias.hasMetadata) {
            const metadata = this.expressionMap.mainAlias.metadata;
            // Adds the global condition of "non-deleted" for the entity with delete date columns in select query.
            if (this.expressionMap.queryType === "select" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {
                const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;
                const condition = `${column} IS NULL`;
                conditionsArray.push(condition);
            }
            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;
                const condition = `${column} IN (:...discriminatorColumnValues)`;
                conditionsArray.push(condition);
            }
        }
        if (this.expressionMap.extraAppendedAndWhereCondition) {
            const condition = this.expressionMap.extraAppendedAndWhereCondition;
            conditionsArray.push(condition);
        }
        let condition = "";
        if (!conditionsArray.length) {
            condition += "";
        } else if (conditionsArray.length === 1) {
            condition += `${conditionsArray[0]}`;
        } else {
            condition += `( ${conditionsArray.join(" ) AND ( ")} )`;
        }
        return condition;
    }
    createColumnValueExpression(valueSets, valueSetIndex, column) {
        const valueSet = valueSets[valueSetIndex];
        let expression = "";
        // extract real value from the entity
        let value = column.getEntityValue(valueSet);
        // if column is relational and value is an object then get real referenced column value from this object
        // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }
        // and we extract "1" from this object
        /*if (column.referencedColumn && value instanceof Object && !(typeof value === "function")) { // todo: check if we still need it since getEntityValue already has similar code
            value = column.referencedColumn.getEntityValue(value);
        }*/ if (!(typeof value === "function")) {
            // make sure our value is normalized by a driver
            value = this.connection.driver.preparePersistentValue(value, column);
        }
        // newly inserted entities always have a version equal to 1 (first version)
        // also, user-specified version must be empty
        if (column.isVersion && value === undefined) {
            expression += "1";
        // } else if (column.isNestedSetLeft) {
        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);
        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);
        //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;
        //     expression += subQuery;
        //
        // } else if (column.isNestedSetRight) {
        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);
        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);
        //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;
        //     expression += subQuery;
        } else if (column.isDiscriminator) {
            expression += this.createParameter(this.expressionMap.mainAlias.metadata.discriminatorValue);
        // return "1";
        // for create and update dates we insert current date
        // no, we don't do it because this constant is already in "default" value of the column
        // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example
        // } else if (column.isCreateDate || column.isUpdateDate) {
        //     return "CURRENT_TIMESTAMP";
        // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion
        } else if (column.isGenerated && column.generationStrategy === "uuid" && !this.connection.driver.isUUIDGenerationSupported() && value === undefined) {
            value = (0, uuid_1.v4)();
            expression += this.createParameter(value);
            if (!(valueSetIndex in this.expressionMap.locallyGenerated)) {
                this.expressionMap.locallyGenerated[valueSetIndex] = {};
            }
            column.setEntityValue(this.expressionMap.locallyGenerated[valueSetIndex], value);
        // if value for this column was not provided then insert default value
        } else if (value === undefined) {
            if (this.connection.driver.options.type === "oracle" && valueSets.length > 1 || DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
                // unfortunately sqlite does not support DEFAULT expression in INSERT queries
                if (column.default !== undefined && column.default !== null) {
                    // try to use default defined in the column
                    expression += this.connection.driver.normalizeDefault(column);
                } else if (this.connection.driver.options.type === "spanner" && column.isGenerated && column.generationStrategy === "uuid") {
                    expression += "GENERATE_UUID()"; // Produces a random universally unique identifier (UUID) as a STRING value.
                } else {
                    expression += "NULL"; // otherwise simply use NULL and pray if column is nullable
                }
            } else {
                expression += "DEFAULT";
            }
        } else if (value === null && (this.connection.driver.options.type === "spanner" || this.connection.driver.options.type === "oracle")) {
            expression += "NULL";
        // support for SQL expressions in queries
        } else if (typeof value === "function") {
            expression += value();
        // just any other regular value
        } else {
            if (this.connection.driver.options.type === "mssql") value = this.connection.driver.parametrizeValue(column, value);
            // we need to store array values in a special class to make sure parameter replacement will work correctly
            // if (value instanceof Array)
            //     value = new ArrayParameter(value);
            const paramName = this.createParameter(value);
            if ((DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && this.connection.driver.spatialTypes.includes(column.type)) {
                const useLegacy = this.connection.driver.options.legacySpatialSupport;
                const geomFromText = useLegacy ? "GeomFromText" : "ST_GeomFromText";
                if (column.srid != null) {
                    expression += `${geomFromText}(${paramName}, ${column.srid})`;
                } else {
                    expression += `${geomFromText}(${paramName})`;
                }
            } else if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.includes(column.type)) {
                if (column.srid != null) {
                    expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;
                } else {
                    expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
                }
            } else if (this.connection.driver.options.type === "mssql" && this.connection.driver.spatialTypes.includes(column.type)) {
                expression += column.type + "::STGeomFromText(" + paramName + ", " + (column.srid || "0") + ")";
            } else {
                expression += paramName;
            }
        }
        return expression;
    }
}
exports.InsertQueryBuilder = InsertQueryBuilder; //# sourceMappingURL=InsertQueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/RelationUpdater.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationUpdater = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Allows to work with entity relations and perform specific operations with those relations.
 *
 * todo: add transactions everywhere
 */ class RelationUpdater {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryBuilder, expressionMap){
        this.queryBuilder = queryBuilder;
        this.expressionMap = expressionMap;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs set or add operation on a relation.
     */ async update(value) {
        const relation = this.expressionMap.relationMetadata;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
            const updateSet = relation.joinColumns.reduce((updateSet, joinColumn)=>{
                const relationValue = ObjectUtils_1.ObjectUtils.isObject(value) ? joinColumn.referencedColumn.getEntityValue(value) : value;
                joinColumn.setEntityValue(updateSet, relationValue);
                return updateSet;
            }, {});
            if (!this.expressionMap.of || Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length) return;
            await this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(this.expressionMap.of).execute();
        } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) {
            // we handle null a bit different way
            const updateSet = {};
            relation.inverseRelation.joinColumns.forEach((column)=>{
                updateSet[column.propertyName] = null;
            });
            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [
                this.expressionMap.of
            ];
            const parameters = {};
            const conditions = [];
            ofs.forEach((of, ofIndex)=>{
                relation.inverseRelation.joinColumns.map((column, columnIndex)=>{
                    const parameterName = "joinColumn_" + ofIndex + "_" + columnIndex;
                    parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;
                    conditions.push(`${column.propertyPath} = :${parameterName}`);
                });
            });
            const condition = conditions.map((str)=>"(" + str + ")").join(" OR ");
            if (!condition) return;
            await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();
        } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {
            if (Array.isArray(this.expressionMap.of)) throw new error_1.TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);
            const of = this.expressionMap.of;
            const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet, joinColumn)=>{
                const relationValue = ObjectUtils_1.ObjectUtils.isObject(of) ? joinColumn.referencedColumn.getEntityValue(of) : of;
                joinColumn.setEntityValue(updateSet, relationValue);
                return updateSet;
            }, {});
            if (!value || Array.isArray(value) && !value.length) return;
            await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute();
        } else {
            // many to many
            const junctionMetadata = relation.junctionEntityMetadata;
            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [
                this.expressionMap.of
            ];
            const values = Array.isArray(value) ? value : [
                value
            ];
            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;
            const secondColumnValues = relation.isManyToManyOwner ? values : ofs;
            const bulkInserted = [];
            firstColumnValues.forEach((firstColumnVal)=>{
                secondColumnValues.forEach((secondColumnVal)=>{
                    const inserted = {};
                    junctionMetadata.ownerColumns.forEach((column)=>{
                        inserted[column.databaseName] = ObjectUtils_1.ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
                    });
                    junctionMetadata.inverseColumns.forEach((column)=>{
                        inserted[column.databaseName] = ObjectUtils_1.ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
                    });
                    bulkInserted.push(inserted);
                });
            });
            if (!bulkInserted.length) return;
            if (this.queryBuilder.connection.driver.options.type === "oracle" || this.queryBuilder.connection.driver.options.type === "sap") {
                await Promise.all(bulkInserted.map((value)=>{
                    return this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(value).execute();
                }));
            } else {
                await this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(bulkInserted).execute();
            }
        }
    }
}
exports.RelationUpdater = RelationUpdater; //# sourceMappingURL=RelationUpdater.js.map
}),
"[project]/node_modules/typeorm/query-builder/RelationRemover.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationRemover = void 0;
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Allows to work with entity relations and perform specific operations with those relations.
 *
 * todo: add transactions everywhere
 */ class RelationRemover {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryBuilder, expressionMap){
        this.queryBuilder = queryBuilder;
        this.expressionMap = expressionMap;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs remove operation on a relation.
     */ async remove(value) {
        const relation = this.expressionMap.relationMetadata;
        if (relation.isOneToMany) {
            // if (this.expressionMap.of instanceof Array)
            //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);
            // DELETE FROM post WHERE post.categoryId = of AND post.id = id
            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [
                this.expressionMap.of
            ];
            const values = Array.isArray(value) ? value : [
                value
            ];
            const updateSet = {};
            relation.inverseRelation.joinColumns.forEach((column)=>{
                updateSet[column.propertyName] = null;
            });
            const parameters = {};
            const conditions = [];
            ofs.forEach((of, ofIndex)=>{
                conditions.push(...values.map((value, valueIndex)=>{
                    return [
                        ...relation.inverseRelation.joinColumns.map((column, columnIndex)=>{
                            const parameterName = "joinColumn_" + ofIndex + "_" + valueIndex + "_" + columnIndex;
                            parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;
                            return `${column.propertyPath} = :${parameterName}`;
                        }),
                        ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex)=>{
                            const parameterName = "primaryColumn_" + valueIndex + "_" + valueIndex + "_" + columnIndex;
                            parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(value) ? column.getEntityValue(value) : value;
                            return `${column.propertyPath} = :${parameterName}`;
                        })
                    ].join(" AND ");
                }));
            });
            const condition = conditions.map((str)=>"(" + str + ")").join(" OR ");
            if (!condition) return;
            await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();
        } else {
            // many to many
            const junctionMetadata = relation.junctionEntityMetadata;
            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [
                this.expressionMap.of
            ];
            const values = Array.isArray(value) ? value : [
                value
            ];
            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;
            const secondColumnValues = relation.isManyToManyOwner ? values : ofs;
            const parameters = {};
            const conditions = [];
            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex)=>{
                conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex)=>{
                    return [
                        ...junctionMetadata.ownerColumns.map((column, columnIndex)=>{
                            const parameterName = "firstValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
                            parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
                            return `${column.databaseName} = :${parameterName}`;
                        }),
                        ...junctionMetadata.inverseColumns.map((column, columnIndex)=>{
                            const parameterName = "secondValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
                            parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
                            return `${column.databaseName} = :${parameterName}`;
                        })
                    ].join(" AND ");
                }));
            });
            const condition = conditions.map((str)=>"(" + str + ")").join(" OR ");
            await this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata.tableName).where(condition).setParameters(parameters).execute();
        }
    }
}
exports.RelationRemover = RelationRemover; //# sourceMappingURL=RelationRemover.js.map
}),
"[project]/node_modules/typeorm/query-builder/RelationQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationQueryBuilder = void 0;
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const RelationUpdater_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationUpdater.js [app-route] (ecmascript)");
const RelationRemover_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationRemover.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Allows to work with entity relations and perform specific operations with those relations.
 *
 * todo: add transactions everywhere
 */ class RelationQueryBuilder extends QueryBuilder_1.QueryBuilder {
    constructor(){
        super(...arguments);
        this["@instanceof"] = Symbol.for("RelationQueryBuilder");
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated SQL query without parameters being replaced.
     */ getQuery() {
        return "";
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Sets entity (target) which relations will be updated.
     */ of(entity) {
        this.expressionMap.of = entity;
        return this;
    }
    /**
     * Sets entity relation's value.
     * Value can be entity, entity id or entity id map (if entity has composite ids).
     * Works only for many-to-one and one-to-one relations.
     * For many-to-many and one-to-many relations use #add and #remove methods instead.
     */ async set(value) {
        const relation = this.expressionMap.relationMetadata;
        if (!this.expressionMap.of) // todo: move this check before relation query builder creation?
        throw new error_1.TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
        if (relation.isManyToMany || relation.isOneToMany) throw new error_1.TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. ` + `However given "${relation.propertyPath}" has ${relation.relationType} relation. ` + `Use .add() method instead.`);
        // if there are multiple join columns then user must send id map as "value" argument. check if he really did it
        if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils_1.ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new error_1.TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: "...", lastName: "..." })`);
        const updater = new RelationUpdater_1.RelationUpdater(this, this.expressionMap);
        return updater.update(value);
    }
    /**
     * Adds (binds) given value to entity relation.
     * Value can be entity, entity id or entity id map (if entity has composite ids).
     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
     * Works only for many-to-many and one-to-many relations.
     * For many-to-one and one-to-one use #set method instead.
     */ async add(value) {
        if (Array.isArray(value) && value.length === 0) return;
        const relation = this.expressionMap.relationMetadata;
        if (!this.expressionMap.of) // todo: move this check before relation query builder creation?
        throw new error_1.TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
        if (relation.isManyToOne || relation.isOneToOne) throw new error_1.TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given "${relation.propertyPath}" has ${relation.relationType} relation. ` + `Use .set() method instead.`);
        // if there are multiple join columns then user must send id map as "value" argument. check if he really did it
        if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils_1.ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new error_1.TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: "...", lastName: "..." })`);
        const updater = new RelationUpdater_1.RelationUpdater(this, this.expressionMap);
        return updater.update(value);
    }
    /**
     * Removes (unbinds) given value from entity relation.
     * Value can be entity, entity id or entity id map (if entity has composite ids).
     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
     * Works only for many-to-many and one-to-many relations.
     * For many-to-one and one-to-one use #set method instead.
     */ async remove(value) {
        if (Array.isArray(value) && value.length === 0) return;
        const relation = this.expressionMap.relationMetadata;
        if (!this.expressionMap.of) // todo: move this check before relation query builder creation?
        throw new error_1.TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
        if (relation.isManyToOne || relation.isOneToOne) throw new error_1.TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given "${relation.propertyPath}" has ${relation.relationType} relation. ` + `Use .set(null) method instead.`);
        const remover = new RelationRemover_1.RelationRemover(this, this.expressionMap);
        return remover.remove(value);
    }
    /**
     * Adds (binds) and removes (unbinds) given values to/from entity relation.
     * Value can be entity, entity id or entity id map (if entity has composite ids).
     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
     * Works only for many-to-many and one-to-many relations.
     * For many-to-one and one-to-one use #set method instead.
     */ async addAndRemove(added, removed) {
        await this.remove(removed);
        await this.add(added);
    }
    /**
     * Gets entity's relation id.
    async getId(): Promise<any> {

    }*/ /**
     * Gets entity's relation ids.
    async getIds(): Promise<any[]> {
        return [];
    }*/ /**
     * Loads a single entity (relational) from the relation.
     * You can also provide id of relational entity to filter by.
     */ async loadOne() {
        return this.loadMany().then((results)=>results[0]);
    }
    /**
     * Loads many entities (relational) from the relation.
     * You can also provide ids of relational entities to filter by.
     */ async loadMany() {
        let of = this.expressionMap.of;
        if (!ObjectUtils_1.ObjectUtils.isObject(of)) {
            const metadata = this.expressionMap.mainAlias.metadata;
            if (metadata.hasMultiplePrimaryKeys) throw new error_1.TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);
            of = metadata.primaryColumns[0].createValueMap(of);
        }
        return this.connection.relationLoader.load(this.expressionMap.relationMetadata, of, this.queryRunner);
    }
}
exports.RelationQueryBuilder = RelationQueryBuilder; //# sourceMappingURL=RelationQueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RawSqlResultsToEntityTransformer = void 0;
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Transforms raw sql results returned from the database into entity object.
 * Entity is constructed based on its entity metadata.
 */ class RawSqlResultsToEntityTransformer {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner){
        this.expressionMap = expressionMap;
        this.driver = driver;
        this.rawRelationIdResults = rawRelationIdResults;
        this.rawRelationCountResults = rawRelationCountResults;
        this.queryRunner = queryRunner;
        this.pojo = this.expressionMap.options.includes("create-pojo");
        this.selections = new Set(this.expressionMap.selects.map((s)=>s.selection));
        this.aliasCache = new Map();
        this.columnsCache = new Map();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
     * we need to group our result and we must have some unique id (primary key in our case)
     */ transform(rawResults, alias) {
        const group = this.group(rawResults, alias);
        const entities = [];
        for (const results of group.values()){
            const entity = this.transformRawResultsGroup(results, alias);
            if (entity !== undefined) entities.push(entity);
        }
        return entities;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Build an alias from a name and column name.
     */ buildAlias(aliasName, columnName) {
        let aliases = this.aliasCache.get(aliasName);
        if (!aliases) {
            aliases = new Map();
            this.aliasCache.set(aliasName, aliases);
        }
        let columnAlias = aliases.get(columnName);
        if (!columnAlias) {
            columnAlias = DriverUtils_1.DriverUtils.buildAlias(this.driver, undefined, aliasName, columnName);
            aliases.set(columnName, columnAlias);
        }
        return columnAlias;
    }
    /**
     * Groups given raw results by ids of given alias.
     */ group(rawResults, alias) {
        const map = new Map();
        const keys = [];
        if (alias.metadata.tableType === "view") {
            keys.push(...alias.metadata.columns.map((column)=>this.buildAlias(alias.name, column.databaseName)));
        } else {
            keys.push(...alias.metadata.primaryColumns.map((column)=>this.buildAlias(alias.name, column.databaseName)));
        }
        for (const rawResult of rawResults){
            const id = keys.map((key)=>{
                const keyValue = rawResult[key];
                if (Buffer.isBuffer(keyValue)) {
                    return keyValue.toString("hex");
                }
                if (ObjectUtils_1.ObjectUtils.isObject(keyValue)) {
                    return JSON.stringify(keyValue);
                }
                return keyValue;
            }).join("_"); // todo: check partial
            const items = map.get(id);
            if (!items) {
                map.set(id, [
                    rawResult
                ]);
            } else {
                items.push(rawResult);
            }
        }
        return map;
    }
    /**
     * Transforms set of data results into single entity.
     */ transformRawResultsGroup(rawResults, alias) {
        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;
        let metadata = alias.metadata;
        if (metadata.discriminatorColumn) {
            const discriminatorValues = rawResults.map((result)=>result[this.buildAlias(alias.name, alias.metadata.discriminatorColumn.databaseName)]);
            const discriminatorMetadata = metadata.childEntityMetadatas.find((childEntityMetadata)=>{
                return typeof discriminatorValues.find((value)=>value === childEntityMetadata.discriminatorValue) !== "undefined";
            });
            if (discriminatorMetadata) metadata = discriminatorMetadata;
        }
        const entity = metadata.create(this.queryRunner, {
            fromDeserializer: true,
            pojo: this.pojo
        });
        // get value from columns selections and put them into newly created entity
        const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);
        const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);
        const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);
        const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);
        // if we have at least one selected column then return this entity
        // since entity must have at least primary columns to be really selected and transformed into entity
        if (hasColumns) return entity;
        // if we don't have any selected column we should not return entity,
        // except for the case when entity only contain a primary column as a relation to another entity
        // in this case its absolutely possible our entity to not have any columns except a single relation
        const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.every((column)=>column.isVirtual === true); // todo: create metadata.hasOnlyVirtualPrimaryColumns
        if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts)) return entity;
        return undefined;
    }
    // get value from columns selections and put them into object
    transformColumns(rawResults, alias, entity, metadata) {
        let hasData = false;
        const result = rawResults[0];
        for (const [key, column] of this.getColumnsToProcess(alias.name, metadata)){
            const value = result[key];
            if (value === undefined) continue;
            else if (value !== null && !column.isVirtualProperty) hasData = true;
            column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));
        }
        return hasData;
    }
    /**
     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity
     */ transformJoins(rawResults, entity, alias, metadata) {
        let hasData = false;
        // let discriminatorValue: string = "";
        // if (metadata.discriminatorColumn)
        //     discriminatorValue = rawResults[0][this.buildAlias(alias.name, alias.metadata.discriminatorColumn!.databaseName)];
        for (const join of this.expressionMap.joinAttributes){
            // todo: we have problem here - when inner joins are used without selects it still create empty array
            // skip joins without metadata
            if (!join.metadata) continue;
            // if simple left or inner join was performed without selection then we don't need to do anything
            if (!join.isSelected) continue;
            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)
            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);
            if (join.relation && !metadata.relations.find((relation)=>relation === join.relation)) continue;
            // some checks to make sure this join is for current alias
            if (join.mapToProperty) {
                if (join.mapToPropertyParentAlias !== alias.name) continue;
            } else {
                if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath) continue;
            }
            // transform joined data into entities
            let result = this.transform(rawResults, join.alias);
            result = !join.isMany ? result[0] : result;
            result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database
            // if nothing was joined then simply continue
            if (result === undefined) continue;
            // if join was mapped to some property then save result to that property
            if (join.mapToPropertyPropertyName) {
                entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds
            } else {
                // otherwise set to relation
                join.relation.setEntityValue(entity, result);
            }
            hasData = true;
        }
        return hasData;
    }
    transformRelationIds(rawSqlResults, alias, entity, metadata) {
        let hasData = false;
        for (const [index, rawRelationIdResult] of this.rawRelationIdResults.entries()){
            if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name) continue;
            const relation = rawRelationIdResult.relationIdAttribute.relation;
            const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);
            if (valueMap === undefined || valueMap === null) {
                continue;
            }
            // prepare common data for this call
            this.prepareDataForTransformRelationIds();
            // Extract idMaps from prepared data by hash
            const hash = this.hashEntityIds(relation, valueMap);
            const idMaps = this.relationIdMaps[index][hash] || [];
            // Map data to properties
            const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(".");
            const mapToProperty = (properties, map, value)=>{
                const property = properties.shift();
                if (property && properties.length === 0) {
                    map[property] = value;
                    return map;
                }
                if (property && properties.length > 0) {
                    mapToProperty(properties, map[property], value);
                } else {
                    return map;
                }
            };
            if (relation.isOneToOne || relation.isManyToOne) {
                if (idMaps[0] !== undefined) {
                    mapToProperty(properties, entity, idMaps[0]);
                    hasData = true;
                }
            } else {
                mapToProperty(properties, entity, idMaps);
                hasData = hasData || idMaps.length > 0;
            }
        }
        return hasData;
    }
    transformRelationCounts(rawSqlResults, alias, entity) {
        let hasData = false;
        for (const rawRelationCountResult of this.rawRelationCountResults){
            if (rawRelationCountResult.relationCountAttribute.parentAlias !== alias.name) continue;
            const relation = rawRelationCountResult.relationCountAttribute.relation;
            let referenceColumnName;
            if (relation.isOneToMany) {
                referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]
            } else {
                referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
            }
            const referenceColumnValue = rawSqlResults[0][this.buildAlias(alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work
            if (referenceColumnValue !== undefined && referenceColumnValue !== null) {
                entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;
                for (const result of rawRelationCountResult.results){
                    if (result["parentId"] !== referenceColumnValue) continue;
                    entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result["cnt"]);
                    hasData = true;
                }
            }
        }
        return hasData;
    }
    getColumnsToProcess(aliasName, metadata) {
        let metadatas = this.columnsCache.get(aliasName);
        if (!metadatas) {
            metadatas = new Map();
            this.columnsCache.set(aliasName, metadatas);
        }
        let columns = metadatas.get(metadata);
        if (!columns) {
            columns = metadata.columns.filter((column)=>!column.isVirtual && // if user does not selected the whole entity or he used partial selection and does not select this particular column
                // then we don't add this column and its value into the entity
                (this.selections.has(aliasName) || this.selections.has(`${aliasName}.${column.propertyPath}`)) && // if table inheritance is used make sure this column is not child's column
                !metadata.childEntityMetadatas.some((childMetadata)=>childMetadata.target === column.target)).map((column)=>[
                    this.buildAlias(aliasName, column.databaseName),
                    column
                ]);
            metadatas.set(metadata, columns);
        }
        return columns;
    }
    createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {
        let columns;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
            columns = relation.entityMetadata.primaryColumns.map((joinColumn)=>joinColumn);
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            columns = relation.inverseRelation.joinColumns.map((joinColumn)=>joinColumn);
        } else {
            if (relation.isOwning) {
                columns = relation.joinColumns.map((joinColumn)=>joinColumn);
            } else {
                columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn)=>joinColumn);
            }
        }
        return columns.reduce((valueMap, column)=>{
            for (const rawSqlResult of rawSqlResults){
                if (relation.isManyToOne || relation.isOneToOneOwner) {
                    valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[this.buildAlias(parentAlias, column.databaseName)], column);
                } else {
                    valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[this.buildAlias(parentAlias, column.referencedColumn.databaseName)], column.referencedColumn);
                }
            }
            return valueMap;
        }, {});
    }
    extractEntityPrimaryIds(relation, relationIdRawResult) {
        let columns;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
            columns = relation.entityMetadata.primaryColumns.map((joinColumn)=>joinColumn);
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            columns = relation.inverseRelation.joinColumns.map((joinColumn)=>joinColumn);
        } else {
            if (relation.isOwning) {
                columns = relation.joinColumns.map((joinColumn)=>joinColumn);
            } else {
                columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn)=>joinColumn);
            }
        }
        return columns.reduce((data, column)=>{
            data[column.databaseName] = relationIdRawResult[column.databaseName];
            return data;
        }, {});
    }
    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {
        const virtualColumns = this.expressionMap.selects
            .filter(select => select.virtual)
            .map(select => select.selection.replace(alias.name + ".", ""));

        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);
    }*/ /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */ prepareDataForTransformRelationIds() {
        // Return early if the relationIdMaps were already calculated
        if (this.relationIdMaps) {
            return;
        }
        // Ensure this prepare function is only called once
        this.relationIdMaps = this.rawRelationIdResults.map((rawRelationIdResult)=>{
            const relation = rawRelationIdResult.relationIdAttribute.relation;
            // Calculate column metadata
            let columns;
            if (relation.isManyToOne || relation.isOneToOneOwner) {
                columns = relation.joinColumns;
            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                columns = relation.inverseEntityMetadata.primaryColumns;
            } else {
                // ManyToMany
                if (relation.isOwning) {
                    columns = relation.inverseJoinColumns;
                } else {
                    columns = relation.inverseRelation.joinColumns;
                }
            }
            // Calculate the idMaps for the rawRelationIdResult
            return rawRelationIdResult.results.reduce((agg, result)=>{
                let idMap = columns.reduce((idMap, column)=>{
                    let value = result[column.databaseName];
                    if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) {
                            // if column is a relation
                            value = column.referencedColumn.createValueMap(value);
                        }
                        return OrmUtils_1.OrmUtils.mergeDeep(idMap, column.createValueMap(value));
                    }
                    if (!column.isPrimary && column.referencedColumn.referencedColumn) {
                        // if column is a relation
                        value = column.referencedColumn.referencedColumn.createValueMap(value);
                    }
                    return OrmUtils_1.OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(value));
                }, {});
                if (columns.length === 1 && !rawRelationIdResult.relationIdAttribute.disableMixedMap) {
                    if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        idMap = columns[0].getEntityValue(idMap);
                    } else {
                        idMap = columns[0].referencedColumn.getEntityValue(idMap);
                    }
                }
                // If an idMap is found, set it in the aggregator under the correct hash
                if (idMap !== undefined) {
                    const hash = this.hashEntityIds(relation, result);
                    if (agg[hash]) {
                        agg[hash].push(idMap);
                    } else {
                        agg[hash] = [
                            idMap
                        ];
                    }
                }
                return agg;
            }, {});
        });
    }
    /**
     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.
     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is
     * given, a simple JSON.stringify should be enough to get a unique hash per entity!
     */ hashEntityIds(relation, data) {
        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);
        return JSON.stringify(entityPrimaryIds);
    }
}
exports.RawSqlResultsToEntityTransformer = RawSqlResultsToEntityTransformer; //# sourceMappingURL=RawSqlResultsToEntityTransformer.js.map
}),
"[project]/node_modules/typeorm/query-builder/relation-id/RelationIdLoader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationIdLoader = void 0;
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
class RelationIdLoader {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner, relationIdAttributes){
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.relationIdAttributes = relationIdAttributes;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    async load(rawEntities) {
        const promises = this.relationIdAttributes.map(async (relationIdAttr)=>{
            if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {
                // example: Post and Tag
                // loadRelationIdAndMap("post.tagId", "post.tag")
                // we expect it to load id of tag
                if (relationIdAttr.queryBuilderFactory) throw new TypeORMError_1.TypeORMError("Additional condition can not be used with ManyToOne or OneToOne owner relations.");
                const duplicates = {};
                const results = rawEntities.map((rawEntity)=>{
                    const result = {};
                    const duplicateParts = [];
                    relationIdAttr.relation.joinColumns.forEach((joinColumn)=>{
                        result[joinColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);
                        const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;
                        if (duplicateParts.indexOf(duplicatePart) === -1) {
                            duplicateParts.push(duplicatePart);
                        }
                    });
                    relationIdAttr.relation.entityMetadata.primaryColumns.forEach((primaryColumn)=>{
                        result[primaryColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);
                        const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;
                        if (duplicateParts.indexOf(duplicatePart) === -1) {
                            duplicateParts.push(duplicatePart);
                        }
                    });
                    duplicateParts.sort();
                    const duplicate = duplicateParts.join("::");
                    if (duplicates[duplicate]) {
                        return null;
                    }
                    duplicates[duplicate] = true;
                    return result;
                }).filter((v)=>v);
                return {
                    relationIdAttribute: relationIdAttr,
                    results: results
                };
            } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {
                // example: Post and Category
                // loadRelationIdAndMap("post.categoryIds", "post.categories")
                // we expect it to load array of category ids
                const relation = relationIdAttr.relation; // "post.categories"
                const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
                const table = relation.inverseEntityMetadata.target; // category
                const tableName = relation.inverseEntityMetadata.tableName; // category
                const tableAlias = relationIdAttr.alias || tableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined
                const duplicates = {};
                const parameters = {};
                const condition = rawEntities.map((rawEntity, index)=>{
                    const duplicateParts = [];
                    const parameterParts = {};
                    const queryPart = joinColumns.map((joinColumn)=>{
                        const parameterName = joinColumn.databaseName + index;
                        const parameterValue = rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];
                        const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;
                        if (duplicateParts.indexOf(duplicatePart) !== -1) {
                            return "";
                        }
                        duplicateParts.push(duplicatePart);
                        parameterParts[parameterName] = parameterValue;
                        return tableAlias + "." + joinColumn.propertyPath + " = :" + parameterName;
                    }).filter((v)=>v).join(" AND ");
                    duplicateParts.sort();
                    const duplicate = duplicateParts.join("::");
                    if (duplicates[duplicate]) {
                        return "";
                    }
                    duplicates[duplicate] = true;
                    Object.assign(parameters, parameterParts);
                    return queryPart;
                }).filter((v)=>v).map((condition)=>"(" + condition + ")").join(" OR ");
                // ensure we won't perform redundant queries for joined data which was not found in selection
                // example: if post.category was not found in db then no need to execute query for category.imageIds
                if (!condition) return {
                    relationIdAttribute: relationIdAttr,
                    results: []
                };
                // generate query:
                // SELECT category.id, category.postId FROM category category ON category.postId = :postId
                const qb = this.connection.createQueryBuilder(this.queryRunner);
                const columns = OrmUtils_1.OrmUtils.uniq([
                    ...joinColumns,
                    ...relation.inverseRelation.entityMetadata.primaryColumns
                ], (column)=>column.propertyPath);
                columns.forEach((joinColumn)=>{
                    qb.addSelect(tableAlias + "." + joinColumn.propertyPath, joinColumn.databaseName);
                });
                qb.from(table, tableAlias).where("(" + condition + ")") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect
                .setParameters(parameters);
                // apply condition (custom query builder factory)
                if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);
                const results = await qb.getRawMany();
                results.forEach((result)=>{
                    joinColumns.forEach((column)=>{
                        result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);
                    });
                    relation.inverseRelation.entityMetadata.primaryColumns.forEach((column)=>{
                        result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column);
                    });
                });
                return {
                    relationIdAttribute: relationIdAttr,
                    results
                };
            } else {
                // many-to-many
                // example: Post and Category
                // owner side: loadRelationIdAndMap("post.categoryIds", "post.categories")
                // inverse side: loadRelationIdAndMap("category.postIds", "category.posts")
                // we expect it to load array of post ids
                const relation = relationIdAttr.relation;
                const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
                const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                const junctionAlias = relationIdAttr.junctionAlias;
                const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;
                const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;
                const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;
                const mappedColumns = rawEntities.map((rawEntity)=>{
                    return joinColumns.reduce((map, joinColumn)=>{
                        map[joinColumn.propertyPath] = rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];
                        return map;
                    }, {});
                });
                // ensure we won't perform redundant queries for joined data which was not found in selection
                // example: if post.category was not found in db then no need to execute query for category.imageIds
                if (mappedColumns.length === 0) return {
                    relationIdAttribute: relationIdAttr,
                    results: []
                };
                const parameters = {};
                const duplicates = {};
                const joinColumnConditions = mappedColumns.map((mappedColumn, index)=>{
                    const duplicateParts = [];
                    const parameterParts = {};
                    const queryPart = Object.keys(mappedColumn).map((key)=>{
                        const parameterName = key + index;
                        const parameterValue = mappedColumn[key];
                        const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;
                        if (duplicateParts.indexOf(duplicatePart) !== -1) {
                            return "";
                        }
                        duplicateParts.push(duplicatePart);
                        parameterParts[parameterName] = parameterValue;
                        return junctionAlias + "." + key + " = :" + parameterName;
                    }).filter((s)=>s).join(" AND ");
                    duplicateParts.sort();
                    const duplicate = duplicateParts.join("::");
                    if (duplicates[duplicate]) {
                        return "";
                    }
                    duplicates[duplicate] = true;
                    Object.assign(parameters, parameterParts);
                    return queryPart;
                }).filter((s)=>s);
                const inverseJoinColumnCondition = inverseJoinColumns.map((joinColumn)=>{
                    return junctionAlias + "." + joinColumn.propertyPath + " = " + inverseSideTableAlias + "." + joinColumn.referencedColumn.propertyPath;
                }).join(" AND ");
                const condition = joinColumnConditions.map((condition)=>{
                    return "(" + condition + " AND " + inverseJoinColumnCondition + ")";
                }).join(" OR ");
                const qb = this.connection.createQueryBuilder(this.queryRunner);
                inverseJoinColumns.forEach((joinColumn)=>{
                    qb.addSelect(junctionAlias + "." + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + "." + joinColumn.propertyPath);
                });
                joinColumns.forEach((joinColumn)=>{
                    qb.addSelect(junctionAlias + "." + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + "." + joinColumn.propertyPath);
                });
                qb.from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).setParameters(parameters);
                // apply condition (custom query builder factory)
                if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);
                const results = await qb.getRawMany();
                results.forEach((result)=>{
                    ;
                    [
                        ...joinColumns,
                        ...inverseJoinColumns
                    ].forEach((column)=>{
                        result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);
                    });
                });
                return {
                    relationIdAttribute: relationIdAttr,
                    results
                };
            }
        });
        return Promise.all(promises);
    }
}
exports.RelationIdLoader = RelationIdLoader; //# sourceMappingURL=RelationIdLoader.js.map
}),
"[project]/node_modules/typeorm/query-builder/RelationIdLoader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationIdLoader = void 0;
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/**
 * Loads relation ids for the given entities.
 */ class RelationIdLoader {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner){
        this.connection = connection;
        this.queryRunner = queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Loads relation ids of the given entity or entities.
     */ load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [
            entityOrEntities
        ];
        const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities) ? relatedEntityOrRelatedEntities : relatedEntityOrRelatedEntities ? [
            relatedEntityOrRelatedEntities
        ] : undefined;
        // load relation ids depend of relation type
        if (relation.isManyToMany) {
            return this.loadForManyToMany(relation, entities, relatedEntities);
        } else if (relation.isManyToOne || relation.isOneToOneOwner) {
            return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);
        } else {
            // if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);
        }
    }
    /**
     * Loads relation ids of the given entities and groups them into the object with parent and children.
     *
     * todo: extract this method?
     */ async loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {
        // console.log("relation:", relation.propertyName);
        // console.log("entitiesOrEntities", entitiesOrEntities);
        const isMany = relation.isManyToMany || relation.isOneToMany;
        const entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [
            entitiesOrEntities
        ];
        if (!relatedEntityOrEntities) {
            relatedEntityOrEntities = await this.connection.relationLoader.load(relation, entitiesOrEntities, this.queryRunner, queryBuilder);
            if (!relatedEntityOrEntities.length) return entities.map((entity)=>({
                    entity: entity,
                    related: isMany ? [] : undefined
                }));
        }
        // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);
        const relationIds = await this.load(relation, entitiesOrEntities, relatedEntityOrEntities);
        // console.log("entities", entities);
        // console.log("relatedEntityOrEntities", relatedEntityOrEntities);
        // console.log("relationIds", relationIds);
        const relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [
            relatedEntityOrEntities
        ];
        let columns = [], inverseColumns = [];
        if (relation.isManyToManyOwner) {
            columns = relation.junctionEntityMetadata.inverseColumns.map((column)=>column.referencedColumn);
            inverseColumns = relation.junctionEntityMetadata.ownerColumns.map((column)=>column.referencedColumn);
        } else if (relation.isManyToManyNotOwner) {
            columns = relation.junctionEntityMetadata.ownerColumns.map((column)=>column.referencedColumn);
            inverseColumns = relation.junctionEntityMetadata.inverseColumns.map((column)=>column.referencedColumn);
        } else if (relation.isManyToOne || relation.isOneToOneOwner) {
            columns = relation.joinColumns.map((column)=>column.referencedColumn);
            inverseColumns = relation.entityMetadata.primaryColumns;
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            columns = relation.inverseRelation.entityMetadata.primaryColumns;
            inverseColumns = relation.inverseRelation.joinColumns.map((column)=>column.referencedColumn);
        } else {}
        return entities.map((entity)=>{
            const group = {
                entity: entity,
                related: isMany ? [] : undefined
            };
            const entityRelationIds = relationIds.filter((relationId)=>{
                return inverseColumns.every((column)=>{
                    return column.compareEntityValue(entity, relationId[column.entityMetadata.name + "_" + column.propertyAliasName]);
                });
            });
            if (!entityRelationIds.length) return group;
            relatedEntities.forEach((relatedEntity)=>{
                entityRelationIds.forEach((relationId)=>{
                    const relatedEntityMatched = columns.every((column)=>{
                        return column.compareEntityValue(relatedEntity, relationId[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, column.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.propertyPath.replace(".", "_"))]);
                    });
                    if (relatedEntityMatched) {
                        if (isMany) {
                            ;
                            group.related.push(relatedEntity);
                        } else {
                            group.related = relatedEntity;
                        }
                    }
                });
            });
            return group;
        });
    }
    /**
     * Loads relation ids of the given entities and maps them into the given entity property.
     async loadManyToManyRelationIdsAndMap(
     relation: RelationMetadata,
     entityOrEntities: ObjectLiteral|ObjectLiteral[],
     mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],
     propertyName: string
     ): Promise<void> {
        const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);
        const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];
        const junctionMetadata = relation.junctionEntityMetadata!;
        const mainAlias = junctionMetadata.name;
        const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;
        const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;
        mapToEntities.forEach(mapToEntity => {
            mapToEntity[propertyName] = [];
            relationIds.forEach(relationId => {
                const match = inverseColumns.every(column => {
                    return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + "_" + column.propertyName];
                });
                if (match) {
                    if (columns.length === 1) {
                        mapToEntity[propertyName].push(relationId[mainAlias + "_" + columns[0].propertyName]);
                    } else {
                        const value = {};
                        columns.forEach(column => {
                            column.referencedColumn!.setEntityValue(value, relationId[mainAlias + "_" + column.propertyName]);
                        });
                        mapToEntity[propertyName].push(value);
                    }
                }
            });
        });
    }*/ // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Loads relation ids for the many-to-many relation.
     */ loadForManyToMany(relation, entities, relatedEntities) {
        const junctionMetadata = relation.junctionEntityMetadata;
        const mainAlias = junctionMetadata.name;
        const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;
        const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;
        const qb = this.connection.createQueryBuilder(this.queryRunner);
        // select all columns from junction table
        columns.forEach((column)=>{
            const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
            qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        inverseColumns.forEach((column)=>{
            const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
            qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        // add conditions for the given entities
        let condition1 = "";
        if (columns.length === 1) {
            const values = entities.map((entity)=>columns[0].referencedColumn.getEntityValue(entity));
            const areAllNumbers = values.every((value)=>typeof value === "number");
            if (areAllNumbers) {
                condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(", ")})`;
            } else {
                qb.setParameter("values1", values);
                condition1 = mainAlias + "." + columns[0].propertyPath + " IN (:...values1)"; // todo: use ANY for postgres
            }
        } else {
            condition1 = "(" + entities.map((entity, entityIndex)=>{
                return columns.map((column)=>{
                    const paramName = "entity1_" + entityIndex + "_" + column.propertyName;
                    qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));
                    return mainAlias + "." + column.propertyPath + " = :" + paramName;
                }).join(" AND ");
            }).map((condition)=>"(" + condition + ")").join(" OR ") + ")";
        }
        // add conditions for the given inverse entities
        let condition2 = "";
        if (relatedEntities) {
            if (inverseColumns.length === 1) {
                const values = relatedEntities.map((entity)=>inverseColumns[0].referencedColumn.getEntityValue(entity));
                const areAllNumbers = values.every((value)=>typeof value === "number");
                if (areAllNumbers) {
                    condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(", ")})`;
                } else {
                    qb.setParameter("values2", values);
                    condition2 = mainAlias + "." + inverseColumns[0].propertyPath + " IN (:...values2)"; // todo: use ANY for postgres
                }
            } else {
                condition2 = "(" + relatedEntities.map((entity, entityIndex)=>{
                    return inverseColumns.map((column)=>{
                        const paramName = "entity2_" + entityIndex + "_" + column.propertyName;
                        qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));
                        return mainAlias + "." + column.propertyPath + " = :" + paramName;
                    }).join(" AND ");
                }).map((condition)=>"(" + condition + ")").join(" OR ") + ")";
            }
        }
        // qb.from(junctionMetadata.target, mainAlias)
        //     .where(condition1 + (condition2 ? " AND " + condition2 : ""));
        //
        // // execute query
        // const { values1, values2 } = qb.getParameters();
        // console.log(`I can do it`, { values1, values2 });
        // if (inverseColumns.length === 1 &&
        //     columns.length === 1 &&
        //     this.connection.driver instanceof SqliteDriver &&
        //     (values1.length + values2.length) > 500 &&
        //     values1.length === values2.length) {
        //     console.log(`I can do it`);
        //     return qb.getRawMany();
        //
        // } else {
        //     return qb.getRawMany();
        // }
        // execute query
        const condition = [
            condition1,
            condition2
        ].filter((v)=>v.length > 0).join(" AND ");
        return qb.from(junctionMetadata.target, mainAlias).where(condition).getRawMany();
    }
    /**
     * Loads relation ids for the many-to-one and one-to-one owner relations.
     */ loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {
        const mainAlias = relation.entityMetadata.targetName;
        // console.log("entitiesx", entities);
        // console.log("relatedEntitiesx", relatedEntities);
        const hasAllJoinColumnsInEntity = relation.joinColumns.every((joinColumn)=>{
            return !!relation.entityMetadata.nonVirtualColumns.find((column)=>column === joinColumn);
        });
        if (relatedEntities && hasAllJoinColumnsInEntity) {
            const relationIdMaps = [];
            entities.forEach((entity)=>{
                const relationIdMap = {};
                relation.entityMetadata.primaryColumns.forEach((primaryColumn)=>{
                    const key = primaryColumn.entityMetadata.name + "_" + primaryColumn.propertyPath.replace(".", "_");
                    relationIdMap[key] = primaryColumn.getEntityValue(entity);
                });
                relatedEntities.forEach((relatedEntity)=>{
                    relation.joinColumns.forEach((joinColumn)=>{
                        const entityColumnValue = joinColumn.getEntityValue(entity);
                        const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);
                        if (entityColumnValue === undefined || relatedEntityColumnValue === undefined) return;
                        if (entityColumnValue === relatedEntityColumnValue) {
                            const key = joinColumn.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + joinColumn.referencedColumn.propertyPath.replace(".", "_");
                            relationIdMap[key] = relatedEntityColumnValue;
                        }
                    });
                });
                if (Object.keys(relationIdMap).length === relation.entityMetadata.primaryColumns.length + relation.joinColumns.length) {
                    relationIdMaps.push(relationIdMap);
                }
            });
            // console.log("relationIdMap", relationIdMaps);
            // console.log("entities.length", entities.length);
            if (relationIdMaps.length === entities.length) return Promise.resolve(relationIdMaps);
        }
        // select all columns we need
        const qb = this.connection.createQueryBuilder(this.queryRunner);
        relation.entityMetadata.primaryColumns.forEach((primaryColumn)=>{
            const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name + "_" + primaryColumn.propertyPath.replace(".", "_"));
            qb.addSelect(mainAlias + "." + primaryColumn.propertyPath, columnName);
        });
        relation.joinColumns.forEach((column)=>{
            const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
            qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        // add condition for entities
        let condition = "";
        if (relation.entityMetadata.primaryColumns.length === 1) {
            const values = entities.map((entity)=>relation.entityMetadata.primaryColumns[0].getEntityValue(entity));
            const areAllNumbers = values.every((value)=>typeof value === "number");
            if (areAllNumbers) {
                condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(", ")})`;
            } else {
                qb.setParameter("values", values);
                condition = mainAlias + "." + relation.entityMetadata.primaryColumns[0].propertyPath + " IN (:...values)"; // todo: use ANY for postgres
            }
        } else {
            condition = entities.map((entity, entityIndex)=>{
                return relation.entityMetadata.primaryColumns.map((column, columnIndex)=>{
                    const paramName = "entity" + entityIndex + "_" + columnIndex;
                    qb.setParameter(paramName, column.getEntityValue(entity));
                    return mainAlias + "." + column.propertyPath + " = :" + paramName;
                }).join(" AND ");
            }).map((condition)=>"(" + condition + ")").join(" OR ");
        }
        // execute query
        return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();
    }
    /**
     * Loads relation ids for the one-to-many and one-to-one not owner relations.
     */ loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {
        const originalRelation = relation;
        relation = relation.inverseRelation;
        if (relation.entityMetadata.primaryColumns.length === relation.joinColumns.length) {
            const sameReferencedColumns = relation.entityMetadata.primaryColumns.every((column)=>{
                return relation.joinColumns.indexOf(column) !== -1;
            });
            if (sameReferencedColumns) {
                return Promise.resolve(entities.map((entity)=>{
                    const result = {};
                    relation.joinColumns.forEach(function(joinColumn) {
                        const value = joinColumn.referencedColumn.getEntityValue(entity);
                        const joinColumnName = joinColumn.referencedColumn.entityMetadata.name + "_" + joinColumn.referencedColumn.propertyPath.replace(".", "_");
                        const primaryColumnName = joinColumn.entityMetadata.name + "_" + originalRelation.propertyPath.replace(".", "_") + "_" + joinColumn.propertyPath.replace(".", "_");
                        result[joinColumnName] = value;
                        result[primaryColumnName] = value;
                    });
                    return result;
                }));
            }
        }
        const mainAlias = relation.entityMetadata.targetName;
        // select all columns we need
        const qb = this.connection.createQueryBuilder(this.queryRunner);
        relation.entityMetadata.primaryColumns.forEach((primaryColumn)=>{
            const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name + "_" + originalRelation.propertyPath.replace(".", "_") + "_" + primaryColumn.propertyPath.replace(".", "_"));
            qb.addSelect(mainAlias + "." + primaryColumn.propertyPath, columnName);
        });
        relation.joinColumns.forEach((column)=>{
            const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
            qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        // add condition for entities
        let condition = "";
        if (relation.joinColumns.length === 1) {
            const values = entities.map((entity)=>relation.joinColumns[0].referencedColumn.getEntityValue(entity));
            const areAllNumbers = values.every((value)=>typeof value === "number");
            if (areAllNumbers) {
                condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(", ")})`;
            } else {
                qb.setParameter("values", values);
                condition = mainAlias + "." + relation.joinColumns[0].propertyPath + " IN (:...values)"; // todo: use ANY for postgres
            }
        } else {
            condition = entities.map((entity, entityIndex)=>{
                return relation.joinColumns.map((joinColumn, joinColumnIndex)=>{
                    const paramName = "entity" + entityIndex + "_" + joinColumnIndex;
                    qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));
                    return mainAlias + "." + joinColumn.propertyPath + " = :" + paramName;
                }).join(" AND ");
            }).map((condition)=>"(" + condition + ")").join(" OR ");
        }
        // execute query
        return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();
    }
}
exports.RelationIdLoader = RelationIdLoader; //# sourceMappingURL=RelationIdLoader.js.map
}),
"[project]/node_modules/typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationIdMetadataToAttributeTransformer = void 0;
const RelationIdAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-id/RelationIdAttribute.js [app-route] (ecmascript)");
class RelationIdMetadataToAttributeTransformer {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(expressionMap){
        this.expressionMap = expressionMap;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    transform() {
        // by example:
        // post has relation id:
        // @RelationId(post => post.categories) categoryIds
        // category has relation id
        // @RelationId(category => category.images) imageIds
        // we load post and join category
        // we expect post.categoryIds and post.category.imageIds to have relation ids
        // first create relation id attributes for all relation id metadatas of the main selected object (post from example)
        if (this.expressionMap.mainAlias) {
            this.expressionMap.mainAlias.metadata.relationIds.forEach((relationId)=>{
                const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationId);
                this.expressionMap.relationIdAttributes.push(attribute);
            });
        }
        // second create relation id attributes for all relation id metadatas of all joined objects (category from example)
        this.expressionMap.joinAttributes.forEach((join)=>{
            // ensure this join has a metadata, because relation id can only work for real orm entities
            if (!join.metadata || join.metadata.isJunction) return;
            join.metadata.relationIds.forEach((relationId)=>{
                const attribute = this.metadataToAttribute(join.alias.name, relationId);
                this.expressionMap.relationIdAttributes.push(attribute);
            });
        });
    }
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    metadataToAttribute(parentAliasName, relationId) {
        return new RelationIdAttribute_1.RelationIdAttribute(this.expressionMap, {
            relationName: parentAliasName + "." + relationId.relation.propertyName,
            mapToProperty: parentAliasName + "." + relationId.propertyName,
            alias: relationId.alias,
            queryBuilderFactory: relationId.queryBuilderFactory
        });
    }
}
exports.RelationIdMetadataToAttributeTransformer = RelationIdMetadataToAttributeTransformer; //# sourceMappingURL=RelationIdMetadataToAttributeTransformer.js.map
}),
"[project]/node_modules/typeorm/query-builder/relation-count/RelationCountLoader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationCountLoader = void 0;
class RelationCountLoader {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner, relationCountAttributes){
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.relationCountAttributes = relationCountAttributes;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    async load(rawEntities) {
        const onlyUnique = (value, index, self)=>{
            return self.indexOf(value) === index;
        };
        const promises = this.relationCountAttributes.map(async (relationCountAttr)=>{
            if (relationCountAttr.relation.isOneToMany) {
                // example: Post and Category
                // loadRelationCountAndMap("post.categoryCount", "post.categories")
                // we expect it to load array of post ids
                // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]
                const relation = relationCountAttr.relation; // "category.posts"
                const inverseRelation = relation.inverseRelation; // "post.category"
                const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn.propertyName; // post id
                const inverseSideTable = relation.inverseEntityMetadata.target; // Post
                const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post
                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined
                const inverseSidePropertyName = inverseRelation.propertyName; // "category" from "post.category"
                let referenceColumnValues = rawEntities.map((rawEntity)=>rawEntity[relationCountAttr.parentAlias + "_" + referenceColumnName]).filter((value)=>!!value);
                referenceColumnValues = referenceColumnValues.filter(onlyUnique);
                // ensure we won't perform redundant queries for joined data which was not found in selection
                // example: if post.category was not found in db then no need to execute query for category.imageIds
                if (referenceColumnValues.length === 0) return {
                    relationCountAttribute: relationCountAttr,
                    results: []
                };
                // generate query:
                // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post
                const qb = this.connection.createQueryBuilder(this.queryRunner);
                qb.select(inverseSideTableAlias + "." + inverseSidePropertyName, "parentId").addSelect("COUNT(*)", "cnt").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + "." + inverseSidePropertyName + " IN (:...ids)").addGroupBy(inverseSideTableAlias + "." + inverseSidePropertyName).setParameter("ids", referenceColumnValues);
                // apply condition (custom query builder factory)
                if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);
                return {
                    relationCountAttribute: relationCountAttr,
                    results: await qb.getRawMany()
                };
            } else {
                // example: Post and Category
                // owner side: loadRelationIdAndMap("post.categoryIds", "post.categories")
                // inverse side: loadRelationIdAndMap("category.postIds", "category.posts")
                // we expect it to load array of post ids
                let joinTableColumnName;
                let inverseJoinColumnName;
                let firstJunctionColumn;
                let secondJunctionColumn;
                if (relationCountAttr.relation.isOwning) {
                    // todo fix joinColumns[0] and inverseJoinColumns[0].
                    joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;
                    inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;
                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
                } else {
                    joinTableColumnName = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;
                    inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
                }
                let referenceColumnValues = rawEntities.map((rawEntity)=>rawEntity[relationCountAttr.parentAlias + "_" + joinTableColumnName]).filter((value)=>!!value);
                referenceColumnValues = referenceColumnValues.filter(onlyUnique);
                // ensure we won't perform redundant queries for joined data which was not found in selection
                // example: if post.category was not found in db then no need to execute query for category.imageIds
                if (referenceColumnValues.length === 0) return {
                    relationCountAttribute: relationCountAttr,
                    results: []
                };
                const junctionAlias = relationCountAttr.junctionAlias;
                const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;
                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
                const junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;
                const condition = junctionAlias + "." + firstJunctionColumn.propertyName + " IN (" + referenceColumnValues.map((vals)=>isNaN(vals) ? "'" + vals + "'" : vals) + ")" + " AND " + junctionAlias + "." + secondJunctionColumn.propertyName + " = " + inverseSideTableAlias + "." + inverseJoinColumnName;
                const qb = this.connection.createQueryBuilder(this.queryRunner);
                qb.select(junctionAlias + "." + firstJunctionColumn.propertyName, "parentId").addSelect("COUNT(" + qb.escape(inverseSideTableAlias) + "." + qb.escape(inverseJoinColumnName) + ")", "cnt").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + "." + firstJunctionColumn.propertyName);
                // apply condition (custom query builder factory)
                if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);
                return {
                    relationCountAttribute: relationCountAttr,
                    results: await qb.getRawMany()
                };
            }
        });
        return Promise.all(promises);
    }
}
exports.RelationCountLoader = RelationCountLoader; //# sourceMappingURL=RelationCountLoader.js.map
}),
"[project]/node_modules/typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationCountMetadataToAttributeTransformer = void 0;
const RelationCountAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-count/RelationCountAttribute.js [app-route] (ecmascript)");
class RelationCountMetadataToAttributeTransformer {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(expressionMap){
        this.expressionMap = expressionMap;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    transform() {
        // by example:
        // post has relation count:
        // @RelationCount(post => post.categories) categoryCount
        // category has relation count
        // @RelationCount(category => category.images) imageCount
        // we load post and join category
        // we expect post.categoryCount and post.category.imageCount to have relation counts
        // first create relation count attributes for all relation count metadatas of the main selected object (post from example)
        if (this.expressionMap.mainAlias) {
            this.expressionMap.mainAlias.metadata.relationCounts.forEach((relationCount)=>{
                const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationCount);
                this.expressionMap.relationCountAttributes.push(attribute);
            });
        }
        // second create relation count attributes for all relation count metadatas of all joined objects (category from example)
        this.expressionMap.joinAttributes.forEach((join)=>{
            // ensure this join has a metadata, because relation count can only work for real orm entities
            if (!join.metadata || join.metadata.isJunction) return;
            join.metadata.relationCounts.forEach((relationCount)=>{
                const attribute = this.metadataToAttribute(join.alias.name, relationCount);
                this.expressionMap.relationCountAttributes.push(attribute);
            });
        });
    }
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    metadataToAttribute(parentAliasName, relationCount) {
        return new RelationCountAttribute_1.RelationCountAttribute(this.expressionMap, {
            relationName: parentAliasName + "." + relationCount.relation.propertyName,
            mapToProperty: parentAliasName + "." + relationCount.propertyName,
            alias: relationCount.alias,
            queryBuilderFactory: relationCount.queryBuilderFactory
        });
    }
}
exports.RelationCountMetadataToAttributeTransformer = RelationCountMetadataToAttributeTransformer; //# sourceMappingURL=RelationCountMetadataToAttributeTransformer.js.map
}),
"[project]/node_modules/typeorm/query-builder/SelectQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SelectQueryBuilder = void 0;
const RawSqlResultsToEntityTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer.js [app-route] (ecmascript)");
const PessimisticLockTransactionRequiredError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/PessimisticLockTransactionRequiredError.js [app-route] (ecmascript)");
const NoVersionOrUpdateDateColumnError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/NoVersionOrUpdateDateColumnError.js [app-route] (ecmascript)");
const OptimisticLockVersionMismatchError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/OptimisticLockVersionMismatchError.js [app-route] (ecmascript)");
const OptimisticLockCanNotBeUsedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/OptimisticLockCanNotBeUsedError.js [app-route] (ecmascript)");
const JoinAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/JoinAttribute.js [app-route] (ecmascript)");
const RelationIdAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-id/RelationIdAttribute.js [app-route] (ecmascript)");
const RelationCountAttribute_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-count/RelationCountAttribute.js [app-route] (ecmascript)");
const RelationIdLoader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-id/RelationIdLoader.js [app-route] (ecmascript)");
const RelationIdLoader_2 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationIdLoader.js [app-route] (ecmascript)");
const RelationIdMetadataToAttributeTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.js [app-route] (ecmascript)");
const RelationCountLoader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-count/RelationCountLoader.js [app-route] (ecmascript)");
const RelationCountMetadataToAttributeTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer.js [app-route] (ecmascript)");
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const LockNotSupportedOnGivenDriverError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/LockNotSupportedOnGivenDriverError.js [app-route] (ecmascript)");
const OffsetWithoutLimitNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/OffsetWithoutLimitNotSupportedError.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const EntityNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/EntityNotFoundError.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const FindOptionsUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const EntityPropertyNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/EntityPropertyNotFoundError.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
    constructor(){
        super(...arguments);
        this["@instanceof"] = Symbol.for("SelectQueryBuilder");
        this.findOptions = {};
        this.selects = [];
        this.joins = [];
        this.conditions = "";
        this.orderBys = [];
        this.relationMetadatas = [];
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated SQL query without parameters being replaced.
     */ getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createSelectExpression();
        sql += this.createJoinExpression();
        sql += this.createWhereExpression();
        sql += this.createGroupByExpression();
        sql += this.createHavingExpression();
        sql += this.createOrderByExpression();
        sql += this.createLimitOffsetExpression();
        sql += this.createLockExpression();
        sql = sql.trim();
        if (this.expressionMap.subQuery) sql = "(" + sql + ")";
        return this.replacePropertyNamesForTheWholeQuery(sql);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    setFindOptions(findOptions) {
        this.findOptions = findOptions;
        this.applyFindOptions();
        return this;
    }
    /**
     * Creates a subquery - query that can be used inside other queries.
     */ subQuery() {
        const qb = this.createQueryBuilder();
        qb.expressionMap.subQuery = true;
        qb.parentQueryBuilder = this;
        return qb;
    }
    /**
     * Creates SELECT query and selects given data.
     * Replaces all previous selections if they exist.
     */ select(selection, selectionAliasName) {
        this.expressionMap.queryType = "select";
        if (Array.isArray(selection)) {
            this.expressionMap.selects = selection.map((selection)=>({
                    selection: selection
                }));
        } else if (typeof selection === "function") {
            const subQueryBuilder = selection(this.subQuery());
            this.setParameters(subQueryBuilder.getParameters());
            this.expressionMap.selects.push({
                selection: subQueryBuilder.getQuery(),
                aliasName: selectionAliasName
            });
        } else if (selection) {
            this.expressionMap.selects = [
                {
                    selection: selection,
                    aliasName: selectionAliasName
                }
            ];
        }
        return this;
    }
    /**
     * Adds new selection to the SELECT query.
     */ addSelect(selection, selectionAliasName) {
        if (!selection) return this;
        if (Array.isArray(selection)) {
            this.expressionMap.selects = this.expressionMap.selects.concat(selection.map((selection)=>({
                    selection: selection
                })));
        } else if (typeof selection === "function") {
            const subQueryBuilder = selection(this.subQuery());
            this.setParameters(subQueryBuilder.getParameters());
            this.expressionMap.selects.push({
                selection: subQueryBuilder.getQuery(),
                aliasName: selectionAliasName
            });
        } else if (selection) {
            this.expressionMap.selects.push({
                selection: selection,
                aliasName: selectionAliasName
            });
        }
        return this;
    }
    /**
     * Set max execution time.
     * @param milliseconds
     */ maxExecutionTime(milliseconds) {
        this.expressionMap.maxExecutionTime = milliseconds;
        return this;
    }
    /**
     * Sets whether the selection is DISTINCT.
     */ distinct(distinct = true) {
        this.expressionMap.selectDistinct = distinct;
        return this;
    }
    /**
     * Sets the distinct on clause for Postgres.
     */ distinctOn(distinctOn) {
        this.expressionMap.selectDistinctOn = distinctOn;
        return this;
    }
    fromDummy() {
        return this.from(this.connection.driver.dummyTableName ?? "(SELECT 1 AS dummy_column)", "dummy_table");
    }
    /**
     * Specifies FROM which entity's table select/update/delete will be executed.
     * Also sets a main string alias of the selection data.
     * Removes all previously set from-s.
     */ from(entityTarget, aliasName) {
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
    }
    /**
     * Specifies FROM which entity's table select/update/delete will be executed.
     * Also sets a main string alias of the selection data.
     */ addFrom(entityTarget, aliasName) {
        const alias = this.createFromAlias(entityTarget, aliasName);
        if (!this.expressionMap.mainAlias) this.expressionMap.setMainAlias(alias);
        return this;
    }
    /**
     * INNER JOINs (without selection).
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ innerJoin(entityOrProperty, alias, condition, parameters) {
        this.join("INNER", entityOrProperty, alias, condition, parameters);
        return this;
    }
    /**
     * LEFT JOINs (without selection).
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ leftJoin(entityOrProperty, alias, condition, parameters) {
        this.join("LEFT", entityOrProperty, alias, condition, parameters);
        return this;
    }
    /**
     * INNER JOINs and adds all selection properties to SELECT.
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.innerJoin(entityOrProperty, alias, condition, parameters);
        return this;
    }
    /**
     * LEFT JOINs and adds all selection properties to SELECT.
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.leftJoin(entityOrProperty, alias, condition, parameters);
        return this;
    }
    /**
     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
     * This is extremely useful when you want to select some data and map it to some virtual property.
     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.join("INNER", entityOrProperty, alias, condition, parameters, mapToProperty, true);
        return this;
    }
    /**
     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
     * This is extremely useful when you want to select some data and map it to some virtual property.
     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {
        this.addSelect(alias);
        this.join("INNER", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);
        return this;
    }
    /**
     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
     * This is extremely useful when you want to select some data and map it to some virtual property.
     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.join("LEFT", entityOrProperty, alias, condition, parameters, mapToProperty, true);
        return this;
    }
    /**
     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
     * This is extremely useful when you want to select some data and map it to some virtual property.
     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
     * You also need to specify an alias of the joined data.
     * Optionally, you can add condition and parameters used in condition.
     */ leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {
        this.addSelect(alias);
        this.join("LEFT", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);
        return this;
    }
    /**
     * LEFT JOINs relation id and maps it into some entity's property.
     * Optionally, you can add condition and parameters used in condition.
     */ loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {
        const relationIdAttribute = new RelationIdAttribute_1.RelationIdAttribute(this.expressionMap);
        relationIdAttribute.mapToProperty = mapToProperty;
        relationIdAttribute.relationName = relationName;
        if (typeof aliasNameOrOptions === "string") relationIdAttribute.alias = aliasNameOrOptions;
        if (typeof aliasNameOrOptions === "object" && aliasNameOrOptions.disableMixedMap) relationIdAttribute.disableMixedMap = true;
        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;
        this.expressionMap.relationIdAttributes.push(relationIdAttribute);
        if (relationIdAttribute.relation.junctionEntityMetadata) {
            this.expressionMap.createAlias({
                type: "other",
                name: relationIdAttribute.junctionAlias,
                metadata: relationIdAttribute.relation.junctionEntityMetadata
            });
        }
        return this;
    }
    /**
     * Counts number of entities of entity's relation and maps the value into some entity's property.
     * Optionally, you can add condition and parameters used in condition.
     */ loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {
        const relationCountAttribute = new RelationCountAttribute_1.RelationCountAttribute(this.expressionMap);
        relationCountAttribute.mapToProperty = mapToProperty;
        relationCountAttribute.relationName = relationName;
        relationCountAttribute.alias = aliasName;
        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;
        this.expressionMap.relationCountAttributes.push(relationCountAttribute);
        this.expressionMap.createAlias({
            type: "other",
            name: relationCountAttribute.junctionAlias
        });
        if (relationCountAttribute.relation.junctionEntityMetadata) {
            this.expressionMap.createAlias({
                type: "other",
                name: relationCountAttribute.junctionAlias,
                metadata: relationCountAttribute.relation.junctionEntityMetadata
            });
        }
        return this;
    }
    /**
     * Loads all relation ids for all relations of the selected entity.
     * All relation ids will be mapped to relation property themself.
     * If array of strings is given then loads only relation ids of the given properties.
     */ loadAllRelationIds(options) {
        // todo: add skip relations
        this.expressionMap.mainAlias.metadata.relations.forEach((relation)=>{
            if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1) return;
            this.loadRelationIdAndMap(this.expressionMap.mainAlias.name + "." + relation.propertyPath, this.expressionMap.mainAlias.name + "." + relation.propertyPath, options);
        });
        return this;
    }
    /**
     * Sets WHERE condition in the query builder.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     * Additionally you can add parameters used in where expression.
     */ where(where, parameters) {
        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
        const condition = this.getWhereCondition(where);
        if (condition) {
            this.expressionMap.wheres = [
                {
                    type: "simple",
                    condition: condition
                }
            ];
        }
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ andWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "and",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new OR WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ orWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "or",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Sets a new where EXISTS clause
     */ whereExists(subQuery) {
        return this.where(...this.getExistsCondition(subQuery));
    }
    /**
     * Adds a new AND where EXISTS clause
     */ andWhereExists(subQuery) {
        return this.andWhere(...this.getExistsCondition(subQuery));
    }
    /**
     * Adds a new OR where EXISTS clause
     */ orWhereExists(subQuery) {
        return this.orWhere(...this.getExistsCondition(subQuery));
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     *
     * Ids are mixed.
     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
     * If you have multiple primary keys you need to pass object with property names and values specified,
     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
     */ whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     *
     * Ids are mixed.
     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
     * If you have multiple primary keys you need to pass object with property names and values specified,
     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
     */ andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new OR WHERE with conditions for the given ids.
     *
     * Ids are mixed.
     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
     * If you have multiple primary keys you need to pass object with property names and values specified,
     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
     */ orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Sets HAVING condition in the query builder.
     * If you had previously HAVING expression defined,
     * calling this function will override previously set HAVING conditions.
     * Additionally you can add parameters used in where expression.
     */ having(having, parameters) {
        this.expressionMap.havings.push({
            type: "simple",
            condition: having
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND HAVING condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ andHaving(having, parameters) {
        this.expressionMap.havings.push({
            type: "and",
            condition: having
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new OR HAVING condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ orHaving(having, parameters) {
        this.expressionMap.havings.push({
            type: "or",
            condition: having
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Sets GROUP BY condition in the query builder.
     * If you had previously GROUP BY expression defined,
     * calling this function will override previously set GROUP BY conditions.
     */ groupBy(groupBy) {
        if (groupBy) {
            this.expressionMap.groupBys = [
                groupBy
            ];
        } else {
            this.expressionMap.groupBys = [];
        }
        return this;
    }
    /**
     * Adds GROUP BY condition in the query builder.
     */ addGroupBy(groupBy) {
        this.expressionMap.groupBys.push(groupBy);
        return this;
    }
    /**
     * Enables time travelling for the current query (only supported by cockroach currently)
     */ timeTravelQuery(timeTravelFn) {
        if (this.connection.driver.options.type === "cockroachdb") {
            if (timeTravelFn === undefined) {
                this.expressionMap.timeTravel = "follower_read_timestamp()";
            } else {
                this.expressionMap.timeTravel = timeTravelFn;
            }
        }
        return this;
    }
    /**
     * Sets ORDER BY condition in the query builder.
     * If you had previously ORDER BY expression defined,
     * calling this function will override previously set ORDER BY conditions.
     */ orderBy(sort, order = "ASC", nulls) {
        if (order !== undefined && order !== "ASC" && order !== "DESC") throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "order" can accept only "ASC" and "DESC" values.`);
        if (nulls !== undefined && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST") throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "nulls" can accept only "NULLS FIRST" and "NULLS LAST" values.`);
        if (sort) {
            if (typeof sort === "object") {
                this.expressionMap.orderBys = sort;
            } else {
                if (nulls) {
                    this.expressionMap.orderBys = {
                        [sort]: {
                            order,
                            nulls
                        }
                    };
                } else {
                    this.expressionMap.orderBys = {
                        [sort]: order
                    };
                }
            }
        } else {
            this.expressionMap.orderBys = {};
        }
        return this;
    }
    /**
     * Adds ORDER BY condition in the query builder.
     */ addOrderBy(sort, order = "ASC", nulls) {
        if (order !== undefined && order !== "ASC" && order !== "DESC") throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "order" can accept only "ASC" and "DESC" values.`);
        if (nulls !== undefined && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST") throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "nulls" can accept only "NULLS FIRST" and "NULLS LAST" values.`);
        if (nulls) {
            this.expressionMap.orderBys[sort] = {
                order,
                nulls
            };
        } else {
            this.expressionMap.orderBys[sort] = order;
        }
        return this;
    }
    /**
     * Sets LIMIT - maximum number of rows to be selected.
     * NOTE that it may not work as you expect if you are using joins.
     * If you want to implement pagination, and you are having join in your query,
     * then use the take method instead.
     */ limit(limit) {
        this.expressionMap.limit = this.normalizeNumber(limit);
        if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit)) throw new error_1.TypeORMError(`Provided "limit" value is not a number. Please provide a numeric value.`);
        return this;
    }
    /**
     * Sets OFFSET - selection offset.
     * NOTE that it may not work as you expect if you are using joins.
     * If you want to implement pagination, and you are having join in your query,
     * then use the skip method instead.
     */ offset(offset) {
        this.expressionMap.offset = this.normalizeNumber(offset);
        if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset)) throw new error_1.TypeORMError(`Provided "offset" value is not a number. Please provide a numeric value.`);
        return this;
    }
    /**
     * Sets maximal number of entities to take.
     */ take(take) {
        this.expressionMap.take = this.normalizeNumber(take);
        if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take)) throw new error_1.TypeORMError(`Provided "take" value is not a number. Please provide a numeric value.`);
        return this;
    }
    /**
     * Sets number of entities to skip.
     */ skip(skip) {
        this.expressionMap.skip = this.normalizeNumber(skip);
        if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip)) throw new error_1.TypeORMError(`Provided "skip" value is not a number. Please provide a numeric value.`);
        return this;
    }
    /**
     * Set certain index to be used by the query.
     *
     * @param index Name of index to be used.
     */ useIndex(index) {
        this.expressionMap.useIndex = index;
        return this;
    }
    /**
     * Sets locking mode.
     */ setLock(lockMode, lockVersion, lockTables) {
        this.expressionMap.lockMode = lockMode;
        this.expressionMap.lockVersion = lockVersion;
        this.expressionMap.lockTables = lockTables;
        return this;
    }
    /**
     * Sets lock handling by adding NO WAIT or SKIP LOCKED.
     */ setOnLocked(onLocked) {
        this.expressionMap.onLocked = onLocked;
        return this;
    }
    /**
     * Disables the global condition of "non-deleted" for the entity with delete date columns.
     */ withDeleted() {
        this.expressionMap.withDeleted = true;
        return this;
    }
    /**
     * Gets first raw result returned by execution of generated query builder sql.
     */ async getRawOne() {
        return (await this.getRawMany())[0];
    }
    /**
     * Gets all raw results returned by execution of generated query builder sql.
     */ async getRawMany() {
        if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        this.expressionMap.queryEntity = false;
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            const results = await this.loadRawResults(queryRunner);
            // close transaction if we started it
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            return results;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) {
                // means we created our own query runner
                await queryRunner.release();
            }
        }
    }
    /**
     * Executes sql generated by query builder and returns object with raw results and entities created from them.
     */ async getRawAndEntities() {
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            this.expressionMap.queryEntity = true;
            const results = await this.executeEntitiesAndRawResults(queryRunner);
            // close transaction if we started it
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            return results;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) // means we created our own query runner
            await queryRunner.release();
        }
    }
    /**
     * Gets single entity returned by execution of generated query builder sql.
     */ async getOne() {
        const results = await this.getRawAndEntities();
        const result = results.entities[0];
        if (result && this.expressionMap.lockMode === "optimistic" && this.expressionMap.lockVersion) {
            const metadata = this.expressionMap.mainAlias.metadata;
            if (this.expressionMap.lockVersion instanceof Date) {
                const actualVersion = metadata.updateDateColumn.getEntityValue(result); // what if columns arent set?
                if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime()) throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
            } else {
                const actualVersion = metadata.versionColumn.getEntityValue(result); // what if columns arent set?
                if (actualVersion !== this.expressionMap.lockVersion) throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
            }
        }
        if (result === undefined) {
            return null;
        }
        return result;
    }
    /**
     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.
     */ async getOneOrFail() {
        const entity = await this.getOne();
        if (!entity) {
            throw new EntityNotFoundError_1.EntityNotFoundError(this.expressionMap.mainAlias.target, this.expressionMap.parameters);
        }
        return entity;
    }
    /**
     * Gets entities returned by execution of generated query builder sql.
     */ async getMany() {
        if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const results = await this.getRawAndEntities();
        return results.entities;
    }
    /**
     * Gets count - number of entities selected by sql generated by this query builder.
     * Count excludes all limitations set by offset, limit, skip, and take.
     */ async getCount() {
        if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            this.expressionMap.queryEntity = false;
            const results = await this.executeCountQuery(queryRunner);
            // close transaction if we started it
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            return results;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) // means we created our own query runner
            await queryRunner.release();
        }
    }
    /**
     * Gets exists
     * Returns whether any rows exists matching current query.
     */ async getExists() {
        if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            this.expressionMap.queryEntity = false;
            const results = await this.executeExistsQuery(queryRunner);
            // close transaction if we started it
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            return results;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) // means we created our own query runner
            await queryRunner.release();
        }
    }
    /**
     * Executes built SQL query and returns entities and overall entities count (without limitation).
     * This method is useful to build pagination.
     */ async getManyAndCount() {
        if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            this.expressionMap.queryEntity = true;
            const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);
            this.expressionMap.queryEntity = false;
            let count = this.lazyCount(entitiesAndRaw);
            if (count === undefined) {
                const cacheId = this.expressionMap.cacheId;
                // Creates a new cacheId for the count query, or it will retrieve the above query results
                // and count will return 0.
                if (cacheId) {
                    this.expressionMap.cacheId = `${cacheId}-count`;
                }
                count = await this.executeCountQuery(queryRunner);
            }
            const results = [
                entitiesAndRaw.entities,
                count
            ];
            // close transaction if we started it
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            return results;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) // means we created our own query runner
            await queryRunner.release();
        }
    }
    lazyCount(entitiesAndRaw) {
        const hasLimit = this.expressionMap.limit !== undefined && this.expressionMap.limit !== null;
        if (this.expressionMap.joinAttributes.length > 0 && hasLimit) {
            return undefined;
        }
        const hasTake = this.expressionMap.take !== undefined && this.expressionMap.take !== null;
        // limit overrides take when no join is defined
        const maxResults = hasLimit ? this.expressionMap.limit : hasTake ? this.expressionMap.take : undefined;
        if (maxResults !== undefined && entitiesAndRaw.entities.length === maxResults) {
            // stop here when the result set contains the max number of rows; we need to execute a full count
            return undefined;
        }
        const hasSkip = this.expressionMap.skip !== undefined && this.expressionMap.skip !== null && this.expressionMap.skip > 0;
        const hasOffset = this.expressionMap.offset !== undefined && this.expressionMap.offset !== null && this.expressionMap.offset > 0;
        if (entitiesAndRaw.entities.length === 0 && (hasSkip || hasOffset)) {
            // when skip or offset were used and no results found, we need to execute a full count
            // (the given offset may have exceeded the actual number of rows)
            return undefined;
        }
        // offset overrides skip when no join is defined
        const previousResults = hasOffset ? this.expressionMap.offset : hasSkip ? this.expressionMap.skip : 0;
        return entitiesAndRaw.entities.length + previousResults;
    }
    /**
     * Executes built SQL query and returns raw data stream.
     */ async stream() {
        this.expressionMap.queryEntity = false;
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            const releaseFn = ()=>{
                if (queryRunner !== this.queryRunner) // means we created our own query runner
                return queryRunner.release();
                return;
            };
            const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);
            // close transaction if we started it
            if (transactionStartedByUs) {
                await queryRunner.commitTransaction();
            }
            return results;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        }
    }
    /**
     * Enables or disables query result caching.
     */ cache(enabledOrMillisecondsOrId, maybeMilliseconds) {
        if (typeof enabledOrMillisecondsOrId === "boolean") {
            this.expressionMap.cache = enabledOrMillisecondsOrId;
        } else if (typeof enabledOrMillisecondsOrId === "number") {
            this.expressionMap.cache = true;
            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;
        } else if (typeof enabledOrMillisecondsOrId === "string" || typeof enabledOrMillisecondsOrId === "number") {
            this.expressionMap.cache = true;
            this.expressionMap.cacheId = enabledOrMillisecondsOrId;
        }
        if (maybeMilliseconds) {
            this.expressionMap.cacheDuration = maybeMilliseconds;
        }
        return this;
    }
    /**
     * Sets extra options that can be used to configure how query builder works.
     */ setOption(option) {
        this.expressionMap.options.push(option);
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany, mapAsEntity) {
        if (parameters) {
            this.setParameters(parameters);
        }
        const joinAttribute = new JoinAttribute_1.JoinAttribute(this.connection, this.expressionMap);
        joinAttribute.direction = direction;
        joinAttribute.mapAsEntity = mapAsEntity;
        joinAttribute.mapToProperty = mapToProperty;
        joinAttribute.isMappingMany = isMappingMany;
        joinAttribute.entityOrProperty = entityOrProperty; // relationName
        joinAttribute.condition = condition; // joinInverseSideCondition
        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + "_" + destinationTableAlias : destinationTableAlias + "_" + parentAlias;
        this.expressionMap.joinAttributes.push(joinAttribute);
        const joinAttributeMetadata = joinAttribute.metadata;
        if (joinAttributeMetadata) {
            if (joinAttributeMetadata.deleteDateColumn && !this.expressionMap.withDeleted) {
                const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`;
                joinAttribute.condition = joinAttribute.condition ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}` : `${conditionDeleteColumn}`;
            }
            // todo: find and set metadata right there?
            joinAttribute.alias = this.expressionMap.createAlias({
                type: "join",
                name: aliasName,
                metadata: joinAttributeMetadata
            });
            if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {
                this.expressionMap.createAlias({
                    type: "join",
                    name: joinAttribute.junctionAlias,
                    metadata: joinAttribute.relation.junctionEntityMetadata
                });
            }
        } else {
            let subQuery = "";
            if (typeof entityOrProperty === "function") {
                const subQueryBuilder = entityOrProperty(this.subQuery());
                this.setParameters(subQueryBuilder.getParameters());
                subQuery = subQueryBuilder.getQuery();
            } else {
                subQuery = entityOrProperty;
            }
            const isSubQuery = typeof entityOrProperty === "function" || entityOrProperty.substr(0, 1) === "(" && entityOrProperty.substr(-1) === ")";
            joinAttribute.alias = this.expressionMap.createAlias({
                type: "join",
                name: aliasName,
                tablePath: isSubQuery === false ? entityOrProperty : undefined,
                subQuery: isSubQuery === true ? subQuery : undefined
            });
        }
    }
    /**
     * Creates "SELECT FROM" part of SQL query.
     */ createSelectExpression() {
        if (!this.expressionMap.mainAlias) throw new error_1.TypeORMError("Cannot build query because main alias is not set (call qb#from method)");
        // todo throw exception if selects or from is missing
        const allSelects = [];
        const excludedSelects = [];
        if (this.expressionMap.mainAlias.hasMetadata) {
            const metadata = this.expressionMap.mainAlias.metadata;
            allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
            excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
        }
        // add selects from joins
        this.expressionMap.joinAttributes.forEach((join)=>{
            if (join.metadata) {
                allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));
                excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));
            } else {
                const hasMainAlias = this.expressionMap.selects.some((select)=>select.selection === join.alias.name);
                if (hasMainAlias) {
                    allSelects.push({
                        selection: this.escape(join.alias.name) + ".*"
                    });
                    const excludedSelect = this.expressionMap.selects.find((select)=>select.selection === join.alias.name);
                    excludedSelects.push(excludedSelect);
                }
            }
        });
        // add all other selects
        this.expressionMap.selects.filter((select)=>excludedSelects.indexOf(select) === -1).forEach((select)=>allSelects.push({
                selection: this.replacePropertyNames(select.selection),
                aliasName: select.aliasName
            }));
        // if still selection is empty, then simply set it to all (*)
        if (allSelects.length === 0) allSelects.push({
            selection: "*"
        });
        // Use certain index
        let useIndex = "";
        if (this.expressionMap.useIndex) {
            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
                useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;
            }
        }
        // create a selection query
        const froms = this.expressionMap.aliases.filter((alias)=>alias.type === "from" && (alias.tablePath || alias.subQuery)).map((alias)=>{
            if (alias.subQuery) return alias.subQuery + " " + this.escape(alias.name);
            return this.getTableName(alias.tablePath) + " " + this.escape(alias.name);
        });
        const select = this.createSelectDistinctExpression();
        const selection = allSelects.map((select)=>select.selection + (select.aliasName ? " AS " + this.escape(select.aliasName) : "")).join(", ");
        return select + selection + " FROM " + froms.join(", ") + this.createTableLockExpression() + useIndex;
    }
    /**
     * Creates select | select distinct part of SQL query.
     */ createSelectDistinctExpression() {
        const { selectDistinct, selectDistinctOn, maxExecutionTime } = this.expressionMap;
        const { driver } = this.connection;
        let select = "SELECT ";
        if (maxExecutionTime > 0) {
            if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
                select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;
            }
        }
        if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) && selectDistinctOn.length > 0) {
            const selectDistinctOnMap = selectDistinctOn.map((on)=>this.replacePropertyNames(on)).join(", ");
            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;
        } else if (selectDistinct) {
            select = "SELECT DISTINCT ";
        }
        return select;
    }
    /**
     * Creates "JOIN" part of SQL query.
     */ createJoinExpression() {
        // examples:
        // select from owning side
        // qb.select("post")
        //     .leftJoinAndSelect("post.category", "category");
        // select from non-owning side
        // qb.select("category")
        //     .leftJoinAndSelect("category.post", "post");
        const joins = this.expressionMap.joinAttributes.map((joinAttr)=>{
            const relation = joinAttr.relation;
            const destinationTableName = joinAttr.tablePath;
            const destinationTableAlias = joinAttr.alias.name;
            let appendedCondition = joinAttr.condition ? " AND (" + joinAttr.condition + ")" : "";
            const parentAlias = joinAttr.parentAlias;
            // if join was build without relation (e.g. without "post.category") then it means that we have direct
            // table to join, without junction table involved. This means we simply join direct table.
            if (!parentAlias || !relation) {
                const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);
                return " " + joinAttr.direction + " JOIN " + destinationJoin + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + (joinAttr.condition ? " ON " + this.replacePropertyNames(joinAttr.condition) : "");
            }
            // if real entity relation is involved
            if (relation.isManyToOne || relation.isOneToOneOwner) {
                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`
                const condition = relation.joinColumns.map((joinColumn)=>{
                    return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + parentAlias + "." + relation.propertyPath + "." + joinColumn.referencedColumn.propertyPath;
                }).join(" AND ");
                return " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(condition + appendedCondition);
            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`
                const condition = relation.inverseRelation.joinColumns.map((joinColumn)=>{
                    if (relation.inverseEntityMetadata.tableType === "entity-child" && relation.inverseEntityMetadata.discriminatorColumn) {
                        appendedCondition += " AND " + destinationTableAlias + "." + relation.inverseEntityMetadata.discriminatorColumn.databaseName + "='" + relation.inverseEntityMetadata.discriminatorValue + "'";
                    }
                    return destinationTableAlias + "." + relation.inverseRelation.propertyPath + "." + joinColumn.referencedColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                }).join(" AND ");
                if (!condition) throw new error_1.TypeORMError(`Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`);
                return " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(condition + appendedCondition);
            } else {
                // means many-to-many
                const junctionTableName = relation.junctionEntityMetadata.tablePath;
                const junctionAlias = joinAttr.junctionAlias;
                let junctionCondition = "", destinationCondition = "";
                if (relation.isOwning) {
                    junctionCondition = relation.joinColumns.map((joinColumn)=>{
                        // `post_category`.`postId` = `post`.`id`
                        return junctionAlias + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                    }).join(" AND ");
                    destinationCondition = relation.inverseJoinColumns.map((joinColumn)=>{
                        // `category`.`id` = `post_category`.`categoryId`
                        return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias + "." + joinColumn.propertyPath;
                    }).join(" AND ");
                } else {
                    junctionCondition = relation.inverseRelation.inverseJoinColumns.map((joinColumn)=>{
                        // `post_category`.`categoryId` = `category`.`id`
                        return junctionAlias + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                    }).join(" AND ");
                    destinationCondition = relation.inverseRelation.joinColumns.map((joinColumn)=>{
                        // `post`.`id` = `post_category`.`postId`
                        return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias + "." + joinColumn.propertyPath;
                    }).join(" AND ");
                }
                return " " + joinAttr.direction + " JOIN " + this.getTableName(junctionTableName) + " " + this.escape(junctionAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(junctionCondition) + " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(destinationCondition + appendedCondition);
            }
        });
        return joins.join(" ");
    }
    /**
     * Creates "GROUP BY" part of SQL query.
     */ createGroupByExpression() {
        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return "";
        return " GROUP BY " + this.replacePropertyNames(this.expressionMap.groupBys.join(", "));
    }
    /**
     * Creates "ORDER BY" part of SQL query.
     */ createOrderByExpression() {
        const orderBys = this.expressionMap.allOrderBys;
        if (Object.keys(orderBys).length === 0) return "";
        return " ORDER BY " + Object.keys(orderBys).map((columnName)=>{
            const orderValue = typeof orderBys[columnName] === "string" ? orderBys[columnName] : orderBys[columnName].order + " " + orderBys[columnName].nulls;
            const selection = this.expressionMap.selects.find((s)=>s.selection === columnName);
            if (selection && !selection.aliasName && columnName.indexOf(".") !== -1) {
                const criteriaParts = columnName.split(".");
                const aliasName = criteriaParts[0];
                const propertyPath = criteriaParts.slice(1).join(".");
                const alias = this.expressionMap.aliases.find((alias)=>alias.name === aliasName);
                if (alias) {
                    const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
                    if (column) {
                        const orderAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName);
                        return this.escape(orderAlias) + " " + orderValue;
                    }
                }
            }
            return this.replacePropertyNames(columnName) + " " + orderValue;
        }).join(", ");
    }
    /**
     * Creates "LIMIT" and "OFFSET" parts of SQL query.
     */ createLimitOffsetExpression() {
        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results
        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values
        let offset = this.expressionMap.offset, limit = this.expressionMap.limit;
        if (offset === undefined && limit === undefined && this.expressionMap.joinAttributes.length === 0) {
            offset = this.expressionMap.skip;
            limit = this.expressionMap.take;
        }
        // Helper functions to check if values are set (including 0)
        const hasLimit = limit !== undefined && limit !== null;
        const hasOffset = offset !== undefined && offset !== null;
        if (this.connection.driver.options.type === "mssql") {
            // Due to a limitation in SQL Server's parser implementation it does not support using
            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the
            // user does not request one we insert a dummy ORDER BY that does nothing and should
            // have no effect on the query planner or on the order of the results returned.
            // https://dba.stackexchange.com/a/193799
            let prefix = "";
            if ((hasLimit || hasOffset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {
                prefix = " ORDER BY (SELECT NULL)";
            }
            if (hasLimit && hasOffset) return prefix + " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
            if (hasLimit) return prefix + " OFFSET 0 ROWS FETCH NEXT " + limit + " ROWS ONLY";
            if (hasOffset) return prefix + " OFFSET " + offset + " ROWS";
        } else if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
            if (hasLimit && hasOffset) return " LIMIT " + limit + " OFFSET " + offset;
            if (hasLimit) return " LIMIT " + limit;
            if (hasOffset) throw new OffsetWithoutLimitNotSupportedError_1.OffsetWithoutLimitNotSupportedError();
        } else if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver)) {
            if (hasLimit && hasOffset) return " LIMIT " + limit + " OFFSET " + offset;
            if (hasLimit) return " LIMIT " + limit;
            if (hasOffset) return " LIMIT -1 OFFSET " + offset;
        } else if (this.connection.driver.options.type === "oracle") {
            if (hasLimit && hasOffset) return " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
            if (hasLimit) return " FETCH NEXT " + limit + " ROWS ONLY";
            if (hasOffset) return " OFFSET " + offset + " ROWS";
        } else {
            if (hasLimit && hasOffset) return " LIMIT " + limit + " OFFSET " + offset;
            if (hasLimit) return " LIMIT " + limit;
            if (hasOffset) return " OFFSET " + offset;
        }
        return "";
    }
    /**
     * Creates "LOCK" part of SELECT Query after table Clause
     * ex.
     *  SELECT 1
     *  FROM USER U WITH (NOLOCK)
     *  JOIN ORDER O WITH (NOLOCK)
     *      ON U.ID=O.OrderID
     */ createTableLockExpression() {
        if (this.connection.driver.options.type === "mssql") {
            switch(this.expressionMap.lockMode){
                case "pessimistic_read":
                    return " WITH (HOLDLOCK, ROWLOCK)";
                case "pessimistic_write":
                    return " WITH (UPDLOCK, ROWLOCK)";
                case "dirty_read":
                    return " WITH (NOLOCK)";
            }
        }
        return "";
    }
    /**
     * Creates "LOCK" part of SQL query.
     */ createLockExpression() {
        const driver = this.connection.driver;
        let lockTablesClause = "";
        if (this.expressionMap.lockTables) {
            if (!(DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb")) {
                throw new error_1.TypeORMError("Lock tables not supported in selected driver");
            }
            if (this.expressionMap.lockTables.length < 1) {
                throw new error_1.TypeORMError("lockTables cannot be an empty array");
            }
            lockTablesClause = " OF " + this.expressionMap.lockTables.join(", ");
        }
        let onLockExpression = "";
        if (this.expressionMap.onLocked === "nowait") {
            onLockExpression = " NOWAIT";
        } else if (this.expressionMap.onLocked === "skip_locked") {
            onLockExpression = " SKIP LOCKED";
        }
        switch(this.expressionMap.lockMode){
            case "pessimistic_read":
                if (driver.options.type === "mysql" || driver.options.type === "aurora-mysql") {
                    if (DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(driver, "8.0.0")) {
                        return " FOR SHARE" + lockTablesClause + onLockExpression;
                    } else {
                        return " LOCK IN SHARE MODE";
                    }
                } else if (driver.options.type === "mariadb") {
                    return " LOCK IN SHARE MODE";
                } else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
                    return " FOR SHARE" + lockTablesClause + onLockExpression;
                } else if (driver.options.type === "oracle") {
                    return " FOR UPDATE";
                } else if (driver.options.type === "mssql") {
                    return "";
                } else {
                    throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                }
            case "pessimistic_write":
                if (DriverUtils_1.DriverUtils.isMySQLFamily(driver) || driver.options.type === "aurora-mysql" || driver.options.type === "oracle") {
                    return " FOR UPDATE" + onLockExpression;
                } else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
                    return " FOR UPDATE" + lockTablesClause + onLockExpression;
                } else if (driver.options.type === "mssql") {
                    return "";
                } else {
                    throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                }
            case "pessimistic_partial_write":
                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
                    return " FOR UPDATE" + lockTablesClause + " SKIP LOCKED";
                } else if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
                    return " FOR UPDATE SKIP LOCKED";
                } else {
                    throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                }
            case "pessimistic_write_or_fail":
                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
                    return " FOR UPDATE" + lockTablesClause + " NOWAIT";
                } else if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
                    return " FOR UPDATE NOWAIT";
                } else {
                    throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                }
            case "for_no_key_update":
                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
                    return " FOR NO KEY UPDATE" + lockTablesClause + onLockExpression;
                } else {
                    throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                }
            case "for_key_share":
                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
                    return " FOR KEY SHARE" + lockTablesClause + onLockExpression;
                } else {
                    throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                }
            default:
                return "";
        }
    }
    /**
     * Creates "HAVING" part of SQL query.
     */ createHavingExpression() {
        if (!this.expressionMap.havings || !this.expressionMap.havings.length) return "";
        const conditions = this.expressionMap.havings.map((having, index)=>{
            switch(having.type){
                case "and":
                    return (index > 0 ? "AND " : "") + this.replacePropertyNames(having.condition);
                case "or":
                    return (index > 0 ? "OR " : "") + this.replacePropertyNames(having.condition);
                default:
                    return this.replacePropertyNames(having.condition);
            }
        }).join(" ");
        if (!conditions.length) return "";
        return " HAVING " + conditions;
    }
    buildEscapedEntityColumnSelects(aliasName, metadata) {
        const hasMainAlias = this.expressionMap.selects.some((select)=>select.selection === aliasName);
        const columns = [];
        if (hasMainAlias) {
            columns.push(...metadata.columns.filter((column)=>column.isSelect === true));
        }
        columns.push(...metadata.columns.filter((column)=>{
            return this.expressionMap.selects.some((select)=>select.selection === aliasName + "." + column.propertyPath);
        }));
        // if user used partial selection and did not select some primary columns which are required to be selected
        // we select those primary columns and mark them as "virtual". Later virtual column values will be removed from final entity
        // to make entity contain exactly what user selected
        if (columns.length === 0) // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)
        return [];
        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter((primaryColumn)=>columns.indexOf(primaryColumn) === -1) : [];
        const allColumns = [
            ...columns,
            ...nonSelectedPrimaryColumns
        ];
        const finalSelects = [];
        const escapedAliasName = this.escape(aliasName);
        allColumns.forEach((column)=>{
            let selectionPath = escapedAliasName + "." + this.escape(column.databaseName);
            if (column.isVirtualProperty && column.query) {
                selectionPath = `(${column.query(escapedAliasName)})`;
            }
            if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
                    const useLegacy = this.connection.driver.options.legacySpatialSupport;
                    const asText = useLegacy ? "AsText" : "ST_AsText";
                    selectionPath = `${asText}(${selectionPath})`;
                }
                if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) if (column.precision) {
                    // cast to JSON to trigger parsing in the driver
                    selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;
                } else {
                    selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;
                }
                if (this.connection.driver.options.type === "mssql") selectionPath = `${selectionPath}.ToString()`;
            }
            const selections = this.expressionMap.selects.filter((select)=>select.selection === aliasName + "." + column.propertyPath);
            if (selections.length) {
                selections.forEach((selection)=>{
                    finalSelects.push({
                        selection: selectionPath,
                        aliasName: selection.aliasName ? selection.aliasName : DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),
                        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
                        virtual: selection.virtual
                    });
                });
            } else {
                finalSelects.push({
                    selection: selectionPath,
                    aliasName: DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),
                    // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
                    virtual: hasMainAlias
                });
            }
        });
        return finalSelects;
    }
    findEntityColumnSelects(aliasName, metadata) {
        return this.expressionMap.selects.filter((select)=>select.selection === aliasName || metadata.columns.some((column)=>select.selection === aliasName + "." + column.propertyPath));
    }
    computeCountExpression() {
        const mainAlias = this.expressionMap.mainAlias.name; // todo: will this work with "fromTableName"?
        const metadata = this.expressionMap.mainAlias.metadata;
        const primaryColumns = metadata.primaryColumns;
        const distinctAlias = this.escape(mainAlias);
        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead
        // so we prevent poor query patterns in the most likely cases
        if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {
            return "COUNT(1)";
        }
        // For everything else, we'll need to do some hackery to get the correct count values.
        if (this.connection.driver.options.type === "cockroachdb" || DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function
            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT
            return "COUNT(DISTINCT(" + primaryColumns.map((c)=>`${distinctAlias}.${this.escape(c.databaseName)}`).join(", ") + "))";
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct
            // https://mariadb.com/kb/en/count-distinct/
            return "COUNT(DISTINCT " + primaryColumns.map((c)=>`${distinctAlias}.${this.escape(c.databaseName)}`).join(", ") + ")";
        }
        if (this.connection.driver.options.type === "mssql") {
            // SQL Server has gotta be different from everyone else.  They don't support
            // distinct counting multiple columns & they don't have the same operator
            // characteristic for concatenating, so we gotta use the `CONCAT` function.
            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.
            const columnsExpression = primaryColumns.map((primaryColumn)=>`${distinctAlias}.${this.escape(primaryColumn.databaseName)}`).join(", '|;|', ");
            if (primaryColumns.length === 1) {
                return `COUNT(DISTINCT(${columnsExpression}))`;
            }
            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
        }
        if (this.connection.driver.options.type === "spanner") {
            // spanner also has gotta be different from everyone else.
            // they do not support concatenation of different column types without casting them to string
            if (primaryColumns.length === 1) {
                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;
            }
            const columnsExpression = primaryColumns.map((primaryColumn)=>`CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`).join(", '|;|', ");
            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
        }
        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.
        // Per the SQL spec, this is the canonical string concatenation mechanism which is most
        // likely to work across servers implementing the SQL standard.
        // Please note, if there is only one primary column that the concatenation does not occur in this
        // query and the query is a standard `COUNT DISTINCT` in that case.
        return `COUNT(DISTINCT(` + primaryColumns.map((c)=>`${distinctAlias}.${this.escape(c.databaseName)}`).join(" || '|;|' || ") + "))";
    }
    async executeCountQuery(queryRunner) {
        const countSql = this.computeCountExpression();
        const results = await this.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(countSql, "cnt").setOption("disable-global-order").loadRawResults(queryRunner);
        if (!results || !results[0] || !results[0]["cnt"]) return 0;
        return parseInt(results[0]["cnt"]);
    }
    async executeExistsQuery(queryRunner) {
        const results = await this.connection.createQueryBuilder().fromDummy().select("1", "row_exists").whereExists(this).limit(1).loadRawResults(queryRunner);
        return results.length > 0;
    }
    applyFindOptions() {
        // todo: convert relations: string[] to object map to simplify code
        // todo: same with selects
        if (this.expressionMap.mainAlias.metadata) {
            if (this.findOptions.relationLoadStrategy) {
                this.expressionMap.relationLoadStrategy = this.findOptions.relationLoadStrategy;
            }
            if (this.findOptions.comment) {
                this.comment(this.findOptions.comment);
            }
            if (this.findOptions.withDeleted) {
                this.withDeleted();
            }
            if (this.findOptions.select) {
                const select = Array.isArray(this.findOptions.select) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;
                this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
            }
            if (this.selects.length) {
                this.select(this.selects);
            }
            this.selects = [];
            if (this.findOptions.relations) {
                const relations = Array.isArray(this.findOptions.relations) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;
                this.buildRelations(relations, typeof this.findOptions.select === "object" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
                if (this.findOptions.loadEagerRelations !== false && this.expressionMap.relationLoadStrategy === "join") {
                    this.buildEagerRelations(relations, typeof this.findOptions.select === "object" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
                }
            }
            if (this.selects.length) {
                this.addSelect(this.selects);
            }
            if (this.findOptions.where) {
                this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
                if (this.conditions.length) this.andWhere(this.conditions.substr(0, 1) !== "(" ? "(" + this.conditions + ")" : this.conditions); // temporary and where and braces
            }
            if (this.findOptions.order) {
                this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
            }
            // apply joins
            if (this.joins.length) {
                this.joins.forEach((join)=>{
                    if (join.select && !join.selection) {
                        // if (join.selection) {
                        //
                        // } else {
                        if (join.type === "inner") {
                            this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                        } else {
                            this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                        }
                    // }
                    } else {
                        if (join.type === "inner") {
                            this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                        } else {
                            this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                        }
                    }
                // if (join.select) {
                //     if (this.findOptions.loadEagerRelations !== false) {
                //         FindOptionsUtils.joinEagerRelations(
                //             this,
                //             join.alias,
                //             join.relationMetadata.inverseEntityMetadata
                //         );
                //     }
                // }
                });
            }
            // if (this.conditions.length) {
            //     this.where(this.conditions.join(" AND "));
            // }
            // apply offset
            if (this.findOptions.skip !== undefined) {
                // if (this.findOptions.options && this.findOptions.options.pagination === false) {
                //     this.offset(this.findOptions.skip);
                // } else {
                this.skip(this.findOptions.skip);
            // }
            }
            // apply limit
            if (this.findOptions.take !== undefined) {
                // if (this.findOptions.options && this.findOptions.options.pagination === false) {
                //     this.limit(this.findOptions.take);
                // } else {
                this.take(this.findOptions.take);
            // }
            }
            // apply caching options
            if (typeof this.findOptions.cache === "number") {
                this.cache(this.findOptions.cache);
            } else if (typeof this.findOptions.cache === "boolean") {
                this.cache(this.findOptions.cache);
            } else if (typeof this.findOptions.cache === "object") {
                this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);
            }
            if (this.findOptions.join) {
                if (this.findOptions.join.leftJoin) Object.keys(this.findOptions.join.leftJoin).forEach((key)=>{
                    this.leftJoin(this.findOptions.join.leftJoin[key], key);
                });
                if (this.findOptions.join.innerJoin) Object.keys(this.findOptions.join.innerJoin).forEach((key)=>{
                    this.innerJoin(this.findOptions.join.innerJoin[key], key);
                });
                if (this.findOptions.join.leftJoinAndSelect) Object.keys(this.findOptions.join.leftJoinAndSelect).forEach((key)=>{
                    this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);
                });
                if (this.findOptions.join.innerJoinAndSelect) Object.keys(this.findOptions.join.innerJoinAndSelect).forEach((key)=>{
                    this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);
                });
            }
            if (this.findOptions.lock) {
                if (this.findOptions.lock.mode === "optimistic") {
                    this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);
                } else if (this.findOptions.lock.mode === "pessimistic_read" || this.findOptions.lock.mode === "pessimistic_write" || this.findOptions.lock.mode === "dirty_read" || this.findOptions.lock.mode === "pessimistic_partial_write" || this.findOptions.lock.mode === "pessimistic_write_or_fail" || this.findOptions.lock.mode === "for_no_key_update" || this.findOptions.lock.mode === "for_key_share") {
                    const tableNames = this.findOptions.lock.tables ? this.findOptions.lock.tables.map((table)=>{
                        const tableAlias = this.expressionMap.aliases.find((alias)=>{
                            return alias.metadata.tableNameWithoutPrefix === table;
                        });
                        if (!tableAlias) {
                            throw new error_1.TypeORMError(`"${table}" is not part of this query`);
                        }
                        return this.escape(tableAlias.name);
                    }) : undefined;
                    this.setLock(this.findOptions.lock.mode, undefined, tableNames);
                    if (this.findOptions.lock.onLocked) {
                        this.setOnLocked(this.findOptions.lock.onLocked);
                    }
                }
            }
            if (this.findOptions.loadRelationIds === true) {
                this.loadAllRelationIds();
            } else if (typeof this.findOptions.loadRelationIds === "object") {
                this.loadAllRelationIds(this.findOptions.loadRelationIds);
            }
            if (this.findOptions.loadEagerRelations !== false) {
                FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);
            }
            if (this.findOptions.transaction === true) {
                this.expressionMap.useTransaction = true;
            }
        // if (this.orderBys.length) {
        //     this.orderBys.forEach(orderBy => {
        //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);
        //     });
        // }
        // todo
        // if (this.options.options && this.options.options.eagerRelations) {
        //     this.queryBuilder
        // }
        // todo
        // if (this.findOptions.options && this.findOptions.listeners === false) {
        //     this.callListeners(false);
        // }
        }
    }
    concatRelationMetadata(relationMetadata) {
        this.relationMetadatas.push(relationMetadata);
    }
    /**
     * Executes sql generated by query builder and returns object with raw results and entities created from them.
     */ async executeEntitiesAndRawResults(queryRunner) {
        if (!this.expressionMap.mainAlias) throw new error_1.TypeORMError(`Alias is not set. Use "from" method to set an alias.`);
        if ((this.expressionMap.lockMode === "pessimistic_read" || this.expressionMap.lockMode === "pessimistic_write" || this.expressionMap.lockMode === "pessimistic_partial_write" || this.expressionMap.lockMode === "pessimistic_write_or_fail" || this.expressionMap.lockMode === "for_no_key_update" || this.expressionMap.lockMode === "for_key_share") && !queryRunner.isTransactionActive) throw new PessimisticLockTransactionRequiredError_1.PessimisticLockTransactionRequiredError();
        if (this.expressionMap.lockMode === "optimistic") {
            const metadata = this.expressionMap.mainAlias.metadata;
            if (!metadata.versionColumn && !metadata.updateDateColumn) throw new NoVersionOrUpdateDateColumnError_1.NoVersionOrUpdateDateColumnError(metadata.name);
        }
        const relationIdLoader = new RelationIdLoader_1.RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);
        const relationCountLoader = new RelationCountLoader_1.RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);
        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer_1.RelationIdMetadataToAttributeTransformer(this.expressionMap);
        relationIdMetadataTransformer.transform();
        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer_1.RelationCountMetadataToAttributeTransformer(this.expressionMap);
        relationCountMetadataTransformer.transform();
        let rawResults = [], entities = [];
        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process
        // where we make two queries to find the data we need
        // first query find ids in skip and take range
        // and second query loads the actual data in given ids range
        if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {
            // we are skipping order by here because its not working in subqueries anyway
            // to make order by working we need to apply it on a distinct query
            const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression("distinctAlias");
            const metadata = this.expressionMap.mainAlias.metadata;
            const mainAliasName = this.expressionMap.mainAlias.name;
            const querySelects = metadata.primaryColumns.map((primaryColumn)=>{
                const distinctAlias = this.escape("distinctAlias");
                const columnAlias = this.escape(DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, mainAliasName, primaryColumn.databaseName));
                if (!orderBys[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction
                orderBys[columnAlias] = "ASC";
                const alias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, "ids_" + mainAliasName, primaryColumn.databaseName);
                return `${distinctAlias}.${columnAlias} AS ${this.escape(alias)}`;
            });
            const originalQuery = this.clone();
            // preserve original timeTravel value since we set it to "false" in subquery
            const originalQueryTimeTravel = originalQuery.expressionMap.timeTravel;
            rawResults = await new SelectQueryBuilder(this.connection, queryRunner).select(`DISTINCT ${querySelects.join(", ")}`).addSelect(selects).from(`(${originalQuery.orderBy().timeTravelQuery(false) // set it to "false" since time travel clause must appear at the very end and applies to the entire SELECT clause.
            .getQuery()})`, "distinctAlias").timeTravelQuery(originalQueryTimeTravel).offset(this.expressionMap.skip).limit(this.expressionMap.take).orderBy(orderBys).cache(this.expressionMap.cache && this.expressionMap.cacheId ? `${this.expressionMap.cacheId}-pagination` : this.expressionMap.cache, this.expressionMap.cacheDuration).setParameters(this.getParameters()).setNativeParameters(this.expressionMap.nativeParameters).getRawMany();
            if (rawResults.length > 0) {
                let condition = "";
                const parameters = {};
                if (metadata.hasMultiplePrimaryKeys) {
                    condition = rawResults.map((result, index)=>{
                        return metadata.primaryColumns.map((primaryColumn)=>{
                            const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;
                            const paramKeyResult = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, "ids_" + mainAliasName, primaryColumn.databaseName);
                            parameters[paramKey] = result[paramKeyResult];
                            return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;
                        }).join(" AND ");
                    }).join(" OR ");
                } else {
                    const alias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, "ids_" + mainAliasName, metadata.primaryColumns[0].databaseName);
                    const ids = rawResults.map((result)=>result[alias]);
                    const areAllNumbers = ids.every((id)=>typeof id === "number");
                    if (areAllNumbers) {
                        // fixes #190. if all numbers then its safe to perform query without parameter
                        condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(", ")})`;
                    } else {
                        parameters["orm_distinct_ids"] = ids;
                        condition = mainAliasName + "." + metadata.primaryColumns[0].propertyPath + " IN (:...orm_distinct_ids)";
                    }
                }
                rawResults = await this.clone().mergeExpressionMap({
                    extraAppendedAndWhereCondition: condition
                }).setParameters(parameters).loadRawResults(queryRunner);
            }
        } else {
            rawResults = await this.loadRawResults(queryRunner);
        }
        if (rawResults.length > 0) {
            // transform raw results into entities
            const rawRelationIdResults = await relationIdLoader.load(rawResults);
            const rawRelationCountResults = await relationCountLoader.load(rawResults);
            const transformer = new RawSqlResultsToEntityTransformer_1.RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);
            entities = transformer.transform(rawResults, this.expressionMap.mainAlias);
            // broadcast all "after load" events
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                await queryRunner.broadcaster.broadcast("Load", this.expressionMap.mainAlias.metadata, entities);
            }
        }
        if (this.expressionMap.relationLoadStrategy === "query") {
            const queryStrategyRelationIdLoader = new RelationIdLoader_2.RelationIdLoader(this.connection, queryRunner);
            await Promise.all(this.relationMetadatas.map(async (relation)=>{
                const relationTarget = relation.inverseEntityMetadata.target;
                const relationAlias = relation.inverseEntityMetadata.targetName;
                const select = Array.isArray(this.findOptions.select) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;
                const relations = Array.isArray(this.findOptions.relations) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;
                const queryBuilder = this.createQueryBuilder(queryRunner).select(relationAlias).from(relationTarget, relationAlias).setFindOptions({
                    select: select ? OrmUtils_1.OrmUtils.deepValue(select, relation.propertyPath) : undefined,
                    order: this.findOptions.order ? OrmUtils_1.OrmUtils.deepValue(this.findOptions.order, relation.propertyPath) : undefined,
                    relations: relations ? OrmUtils_1.OrmUtils.deepValue(relations, relation.propertyPath) : undefined,
                    withDeleted: this.findOptions.withDeleted,
                    relationLoadStrategy: this.findOptions.relationLoadStrategy
                });
                if (entities.length > 0) {
                    const relatedEntityGroups = await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, undefined, queryBuilder);
                    entities.forEach((entity)=>{
                        const relatedEntityGroup = relatedEntityGroups.find((group)=>group.entity === entity);
                        if (relatedEntityGroup) {
                            const value = relatedEntityGroup.related === undefined ? null : relatedEntityGroup.related;
                            relation.setEntityValue(entity, value);
                        }
                    });
                }
            }));
        }
        return {
            raw: rawResults,
            entities: entities
        };
    }
    createOrderByCombinedWithSelectExpression(parentAlias) {
        // if table has a default order then apply it
        const orderBys = this.expressionMap.allOrderBys;
        const selectString = Object.keys(orderBys).map((orderCriteria)=>{
            if (orderCriteria.indexOf(".") !== -1) {
                const criteriaParts = orderCriteria.split(".");
                const aliasName = criteriaParts[0];
                const propertyPath = criteriaParts.slice(1).join(".");
                const alias = this.expressionMap.findAliasByName(aliasName);
                const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
                return this.escape(parentAlias) + "." + this.escape(DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName));
            } else {
                if (this.expressionMap.selects.find((select)=>select.selection === orderCriteria || select.aliasName === orderCriteria)) return this.escape(parentAlias) + "." + this.escape(orderCriteria);
                return "";
            }
        }).join(", ");
        const orderByObject = {};
        Object.keys(orderBys).forEach((orderCriteria)=>{
            if (orderCriteria.indexOf(".") !== -1) {
                const criteriaParts = orderCriteria.split(".");
                const aliasName = criteriaParts[0];
                const propertyPath = criteriaParts.slice(1).join(".");
                const alias = this.expressionMap.findAliasByName(aliasName);
                const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
                orderByObject[this.escape(parentAlias) + "." + this.escape(DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName))] = orderBys[orderCriteria];
            } else {
                if (this.expressionMap.selects.find((select)=>select.selection === orderCriteria || select.aliasName === orderCriteria)) {
                    orderByObject[this.escape(parentAlias) + "." + this.escape(orderCriteria)] = orderBys[orderCriteria];
                } else {
                    orderByObject[orderCriteria] = orderBys[orderCriteria];
                }
            }
        });
        return [
            selectString,
            orderByObject
        ];
    }
    /**
     * Loads raw results from the database.
     */ async loadRawResults(queryRunner) {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryId = sql + " -- PARAMETERS: " + JSON.stringify(parameters, (_, value)=>typeof value === "bigint" ? value.toString() : value);
        const cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
        let savedQueryResultCacheOptions = undefined;
        const isCachingEnabled = // Caching is enabled globally and isn't disabled locally.
        cacheOptions.alwaysEnabled && this.expressionMap.cache !== false || // ...or it's enabled locally explicitly.
        this.expressionMap.cache === true;
        let cacheError = false;
        if (this.connection.queryResultCache && isCachingEnabled) {
            try {
                savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({
                    identifier: this.expressionMap.cacheId,
                    query: queryId,
                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000
                }, queryRunner);
                if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {
                    return JSON.parse(savedQueryResultCacheOptions.result);
                }
            } catch (error) {
                if (!cacheOptions.ignoreErrors) {
                    throw error;
                }
                cacheError = true;
            }
        }
        const results = await queryRunner.query(sql, parameters, true);
        if (!cacheError && this.connection.queryResultCache && isCachingEnabled) {
            try {
                await this.connection.queryResultCache.storeInCache({
                    identifier: this.expressionMap.cacheId,
                    query: queryId,
                    time: Date.now(),
                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,
                    result: JSON.stringify(results.records)
                }, savedQueryResultCacheOptions, queryRunner);
            } catch (error) {
                if (!cacheOptions.ignoreErrors) {
                    throw error;
                }
            }
        }
        return results.records;
    }
    /**
     * Merges into expression map given expression map properties.
     */ mergeExpressionMap(expressionMap) {
        ObjectUtils_1.ObjectUtils.assign(this.expressionMap, expressionMap);
        return this;
    }
    /**
     * Normalizes a give number - converts to int if possible.
     */ normalizeNumber(num) {
        if (typeof num === "number" || num === undefined || num === null) return num;
        return Number(num);
    }
    /**
     * Creates a query builder used to execute sql queries inside this query builder.
     */ obtainQueryRunner() {
        return this.queryRunner || this.connection.createQueryRunner(this.connection.defaultReplicationModeForReads());
    }
    buildSelect(select, metadata, alias, embedPrefix) {
        for(const key in select){
            if (select[key] === undefined || select[key] === false) continue;
            const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
            const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
            const relation = metadata.findRelationWithPropertyPath(propertyPath);
            if (!embed && !column && !relation) throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
            if (column) {
                this.selects.push(alias + "." + propertyPath);
            // this.addSelect(alias + "." + propertyPath);
            } else if (embed) {
                this.buildSelect(select[key], metadata, alias, propertyPath);
            // } else if (relation) {
            //     const joinAlias = alias + "_" + relation.propertyName;
            //     const existJoin = this.joins.find(join => join.alias === joinAlias);
            //     if (!existJoin) {
            //         this.joins.push({
            //             type: "left",
            //             select: false,
            //             alias: joinAlias,
            //             parentAlias: alias,
            //             relationMetadata: relation
            //         });
            //     }
            //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);
            }
        }
    }
    buildRelations(relations, selection, metadata, alias, embedPrefix) {
        if (!relations) return;
        Object.keys(relations).forEach((relationName)=>{
            const relationValue = relations[relationName];
            const propertyPath = embedPrefix ? embedPrefix + "." + relationName : relationName;
            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
            const relation = metadata.findRelationWithPropertyPath(propertyPath);
            if (!embed && !relation) throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
            if (embed) {
                this.buildRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);
            } else if (relation) {
                let joinAlias = alias + "_" + propertyPath.replace(".", "_");
                joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, {
                    joiner: "__"
                }, alias, joinAlias);
                if (relationValue === true || typeof relationValue === "object") {
                    if (this.expressionMap.relationLoadStrategy === "query") {
                        this.concatRelationMetadata(relation);
                    } else {
                        // join
                        this.joins.push({
                            type: "left",
                            select: true,
                            selection: selection && typeof selection[relationName] === "object" ? selection[relationName] : undefined,
                            alias: joinAlias,
                            parentAlias: alias,
                            relationMetadata: relation
                        });
                        if (selection && typeof selection[relationName] === "object") {
                            this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);
                        }
                    }
                }
                if (typeof relationValue === "object" && this.expressionMap.relationLoadStrategy === "join") {
                    this.buildRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);
                }
            }
        });
    }
    buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {
        if (!relations) return;
        Object.keys(relations).forEach((relationName)=>{
            const relationValue = relations[relationName];
            const propertyPath = embedPrefix ? embedPrefix + "." + relationName : relationName;
            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
            const relation = metadata.findRelationWithPropertyPath(propertyPath);
            if (!embed && !relation) throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
            if (embed) {
                this.buildEagerRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);
            } else if (relation) {
                let joinAlias = alias + "_" + propertyPath.replace(".", "_");
                joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, {
                    joiner: "__"
                }, alias, joinAlias);
                if (relationValue === true || typeof relationValue === "object") {
                    relation.inverseEntityMetadata.eagerRelations.forEach((eagerRelation)=>{
                        let eagerRelationJoinAlias = joinAlias + "_" + eagerRelation.propertyPath.replace(".", "_");
                        eagerRelationJoinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, {
                            joiner: "__"
                        }, joinAlias, eagerRelationJoinAlias);
                        const existJoin = this.joins.find((join)=>join.alias === eagerRelationJoinAlias);
                        if (!existJoin) {
                            this.joins.push({
                                type: "left",
                                select: true,
                                alias: eagerRelationJoinAlias,
                                parentAlias: joinAlias,
                                selection: undefined,
                                relationMetadata: eagerRelation
                            });
                        }
                        if (selection && typeof selection[relationName] === "object") {
                            this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);
                        }
                    });
                }
                if (typeof relationValue === "object") {
                    this.buildEagerRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);
                }
            }
        });
    }
    buildOrder(order, metadata, alias, embedPrefix) {
        for(const key in order){
            if (order[key] === undefined) continue;
            const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
            const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
            const relation = metadata.findRelationWithPropertyPath(propertyPath);
            if (!embed && !column && !relation) throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
            if (column) {
                let direction = typeof order[key] === "object" ? order[key].direction : order[key];
                direction = direction === "DESC" || direction === "desc" || direction === -1 ? "DESC" : "ASC";
                let nulls = typeof order[key] === "object" ? order[key].nulls : undefined;
                nulls = nulls?.toLowerCase() === "first" ? "NULLS FIRST" : nulls?.toLowerCase() === "last" ? "NULLS LAST" : undefined;
                const aliasPath = `${alias}.${propertyPath}`;
                // const selection = this.expressionMap.selects.find(
                //     (s) => s.selection === aliasPath,
                // )
                // if (selection) {
                //     // this is not building correctly now???
                //     aliasPath = this.escape(
                //         DriverUtils.buildAlias(
                //             this.connection.driver,
                //             undefined,
                //             alias,
                //             column.databaseName,
                //         ),
                //     )
                //     // selection.aliasName = aliasPath
                // } else {
                //     if (column.isVirtualProperty && column.query) {
                //         aliasPath = `(${column.query(alias)})`
                //     }
                // }
                // console.log("add sort", selection, aliasPath, direction, nulls)
                this.addOrderBy(aliasPath, direction, nulls);
            // this.orderBys.push({ alias: alias + "." + propertyPath, direction, nulls });
            } else if (embed) {
                this.buildOrder(order[key], metadata, alias, propertyPath);
            } else if (relation) {
                let joinAlias = alias + "_" + propertyPath.replace(".", "_");
                joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, {
                    joiner: "__"
                }, alias, joinAlias);
                // console.log("joinAlias", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)
                // todo: use expressionMap.joinAttributes, and create a new one using
                //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);
                const existJoin = this.joins.find((join)=>join.alias === joinAlias);
                if (!existJoin) {
                    this.joins.push({
                        type: "left",
                        select: false,
                        alias: joinAlias,
                        parentAlias: alias,
                        selection: undefined,
                        relationMetadata: relation
                    });
                }
                this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);
            }
        }
    }
    buildWhere(where, metadata, alias, embedPrefix) {
        let condition = "";
        // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;
        if (Array.isArray(where)) {
            if (where.length) {
                condition = where.map((whereItem)=>{
                    return this.buildWhere(whereItem, metadata, alias, embedPrefix);
                }).filter((condition)=>!!condition).map((condition)=>"(" + condition + ")").join(" OR ");
            }
        } else {
            const andConditions = [];
            for(const key in where){
                let parameterValue = where[key];
                const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
                const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
                const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
                const relation = metadata.findRelationWithPropertyPath(propertyPath);
                if (!embed && !column && !relation) {
                    throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
                }
                if (parameterValue === undefined) {
                    const undefinedBehavior = this.connection.options.invalidWhereValuesBehavior?.undefined || "ignore";
                    if (undefinedBehavior === "throw") {
                        throw new error_1.TypeORMError(`Undefined value encountered in property '${alias}.${key}' of a where condition. ` + `Set 'invalidWhereValuesBehavior.undefined' to 'ignore' in connection options to skip properties with undefined values.`);
                    }
                    continue;
                }
                if (parameterValue === null) {
                    const nullBehavior = this.connection.options.invalidWhereValuesBehavior?.null || "ignore";
                    if (nullBehavior === "ignore") {
                        continue;
                    } else if (nullBehavior === "throw") {
                        throw new error_1.TypeORMError(`Null value encountered in property '${alias}.${key}' of a where condition. ` + `To match with SQL NULL, the IsNull() operator must be used. ` + `Set 'invalidWhereValuesBehavior.null' to 'ignore' or 'sql-null' in connection options to skip or handle null values.`);
                    }
                // 'sql-null' behavior continues to the next logic
                }
                if (column) {
                    let aliasPath = `${alias}.${propertyPath}`;
                    if (column.isVirtualProperty && column.query) {
                        aliasPath = `(${column.query(this.escape(alias))})`;
                    }
                    if (parameterValue === null) {
                        andConditions.push(`${aliasPath} IS NULL`);
                        continue;
                    }
                    // const parameterName = alias + "_" + propertyPath.split(".").join("_") + "_" + parameterIndex;
                    // todo: we need to handle other operators as well?
                    if (InstanceChecker_1.InstanceChecker.isEqualOperator(where[key])) {
                        parameterValue = where[key].value;
                    }
                    if (column.transformer) {
                        if (parameterValue instanceof FindOperator_1.FindOperator) {
                            parameterValue.transformValue(column.transformer);
                        } else {
                            parameterValue = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(column.transformer, parameterValue);
                        }
                    }
                    // MSSQL requires parameters to carry extra type information
                    if (this.connection.driver.options.type === "mssql") {
                        parameterValue = this.connection.driver.parametrizeValues(column, parameterValue);
                    }
                    andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue)));
                // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);
                // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases
                } else if (embed) {
                    const condition = this.buildWhere(where[key], metadata, alias, propertyPath);
                    if (condition) andConditions.push(condition);
                } else if (relation) {
                    if (where[key] === null) {
                        const nullBehavior = this.connection.options.invalidWhereValuesBehavior?.null || "ignore";
                        if (nullBehavior === "sql-null") {
                            andConditions.push(`${alias}.${propertyPath} IS NULL`);
                        } else if (nullBehavior === "throw") {
                            throw new error_1.TypeORMError(`Null value encountered in property '${alias}.${key}' of a where condition. ` + `Set 'invalidWhereValuesBehavior.null' to 'ignore' or 'sql-null' in connection options to skip or handle null values.`);
                        }
                        continue;
                    }
                    // if all properties of where are undefined we don't need to join anything
                    // this can happen when user defines map with conditional queries inside
                    if (typeof where[key] === "object") {
                        const allAllUndefined = Object.keys(where[key]).every((k)=>where[key][k] === undefined);
                        if (allAllUndefined) {
                            continue;
                        }
                    }
                    if (InstanceChecker_1.InstanceChecker.isFindOperator(where[key])) {
                        if (where[key].type === "moreThan" || where[key].type === "lessThan" || where[key].type === "moreThanOrEqual" || where[key].type === "lessThanOrEqual") {
                            let sqlOperator = "";
                            if (where[key].type === "moreThan") {
                                sqlOperator = ">";
                            } else if (where[key].type === "lessThan") {
                                sqlOperator = "<";
                            } else if (where[key].type === "moreThanOrEqual") {
                                sqlOperator = ">=";
                            } else if (where[key].type === "lessThanOrEqual") {
                                sqlOperator = "<=";
                            }
                            // basically relation count functionality
                            const qb = this.subQuery();
                            if (relation.isManyToManyOwner) {
                                qb.select("COUNT(*)").from(relation.joinTableName, relation.joinTableName).where(relation.joinColumns.map((column)=>{
                                    return `${relation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;
                                }).join(" AND "));
                            } else if (relation.isManyToManyNotOwner) {
                                qb.select("COUNT(*)").from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName).where(relation.inverseRelation.inverseJoinColumns.map((column)=>{
                                    return `${relation.inverseRelation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;
                                }).join(" AND "));
                            } else if (relation.isOneToMany) {
                                qb.select("COUNT(*)").from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata.tableName).where(relation.inverseRelation.joinColumns.map((column)=>{
                                    return `${relation.inverseEntityMetadata.tableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;
                                }).join(" AND "));
                            } else {
                                throw new Error(`This relation isn't supported by given find operator`);
                            }
                            // this
                            //     .addSelect(qb.getSql(), relation.propertyAliasName + "_cnt")
                            //     .andWhere(this.escape(relation.propertyAliasName + "_cnt") + " " + sqlOperator + " " + parseInt(where[key].value));
                            this.andWhere(qb.getSql() + " " + sqlOperator + " " + parseInt(where[key].value));
                        } else {
                            if (relation.isManyToOne || relation.isOneToOne && relation.isOneToOneOwner) {
                                const aliasPath = `${alias}.${propertyPath}`;
                                andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));
                            } else {
                                throw new Error(`This relation isn't supported by given find operator`);
                            }
                        }
                    } else {
                        // const joinAlias = alias + "_" + relation.propertyName;
                        let joinAlias = alias + "_" + relation.propertyPath.replace(".", "_");
                        joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, {
                            joiner: "__"
                        }, alias, joinAlias);
                        const existJoin = this.joins.find((join)=>join.alias === joinAlias);
                        if (!existJoin) {
                            this.joins.push({
                                type: "left",
                                select: false,
                                selection: undefined,
                                alias: joinAlias,
                                parentAlias: alias,
                                relationMetadata: relation
                            });
                        }
                        const condition = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);
                        if (condition) {
                            andConditions.push(condition);
                        // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;
                        }
                    }
                }
            }
            condition = andConditions.length ? "(" + andConditions.join(") AND (") + ")" : andConditions.join(" AND ");
        }
        return condition.length ? "(" + condition + ")" : condition;
    }
}
exports.SelectQueryBuilder = SelectQueryBuilder; //# sourceMappingURL=SelectQueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/result/UpdateResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateResult = void 0;
/**
 * Result object returned by UpdateQueryBuilder execution.
 */ class UpdateResult {
    constructor(){
        /**
         * Contains inserted entity id.
         * Has entity-like structure (not just column database name and values).
         */ // identifier: ObjectLiteral[] = [];
        /**
         * Generated values returned by a database.
         * Has entity-like structure (not just column database name and values).
         */ this.generatedMaps = [];
    }
    static from(queryResult) {
        const result = new this();
        result.raw = queryResult.records;
        result.affected = queryResult.affected;
        return result;
    }
}
exports.UpdateResult = UpdateResult; //# sourceMappingURL=UpdateResult.js.map
}),
"[project]/node_modules/typeorm/query-builder/SoftDeleteQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SoftDeleteQueryBuilder = void 0;
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const UpdateResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/UpdateResult.js [app-route] (ecmascript)");
const ReturningStatementNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ReturningStatementNotSupportedError.js [app-route] (ecmascript)");
const ReturningResultsEntityUpdator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/ReturningResultsEntityUpdator.js [app-route] (ecmascript)");
const LimitOnUpdateNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/LimitOnUpdateNotSupportedError.js [app-route] (ecmascript)");
const MissingDeleteDateColumnError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/MissingDeleteDateColumnError.js [app-route] (ecmascript)");
const UpdateValuesMissingError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/UpdateValuesMissingError.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */ class SoftDeleteQueryBuilder extends QueryBuilder_1.QueryBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connectionOrQueryBuilder, queryRunner){
        super(connectionOrQueryBuilder, queryRunner);
        this["@instanceof"] = Symbol.for("SoftDeleteQueryBuilder");
        this.expressionMap.aliasNamePrefixingEnabled = false;
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated SQL query without parameters being replaced.
     */ getQuery() {
        let sql = this.createUpdateExpression();
        sql += this.createCteExpression();
        sql += this.createOrderByExpression();
        sql += this.createLimitExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
    }
    /**
     * Executes sql generated by query builder and returns raw database results.
     */ async execute() {
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            // call before soft remove and recover methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                if (this.expressionMap.queryType === "soft-delete") await queryRunner.broadcaster.broadcast("BeforeSoftRemove", this.expressionMap.mainAlias.metadata);
                else if (this.expressionMap.queryType === "restore") await queryRunner.broadcaster.broadcast("BeforeRecover", this.expressionMap.mainAlias.metadata);
            }
            // if update entity mode is enabled we may need extra columns for the returning statement
            const returningResultsEntityUpdator = new ReturningResultsEntityUpdator_1.ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
                this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getSoftDeletionReturningColumns();
            }
            // execute update query
            const [sql, parameters] = this.getQueryAndParameters();
            const queryResult = await queryRunner.query(sql, parameters, true);
            const updateResult = UpdateResult_1.UpdateResult.from(queryResult);
            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)
            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
                await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);
            }
            // call after soft remove and recover methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                if (this.expressionMap.queryType === "soft-delete") await queryRunner.broadcaster.broadcast("AfterSoftRemove", this.expressionMap.mainAlias.metadata);
                else if (this.expressionMap.queryType === "restore") await queryRunner.broadcaster.broadcast("AfterRecover", this.expressionMap.mainAlias.metadata);
            }
            // close transaction if we started it
            if (transactionStartedByUs) await queryRunner.commitTransaction();
            return updateResult;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) {
                // means we created our own query runner
                await queryRunner.release();
            }
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.
     * Also sets a main string alias of the selection data.
     */ from(entityTarget, aliasName) {
        entityTarget = InstanceChecker_1.InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
    }
    /**
     * Sets WHERE condition in the query builder.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     * Additionally you can add parameters used in where expression.
     */ where(where, parameters) {
        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
        const condition = this.getWhereCondition(where);
        if (condition) this.expressionMap.wheres = [
            {
                type: "simple",
                condition: condition
            }
        ];
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ andWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "and",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new OR WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ orWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "or",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     */ whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     */ andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new OR WHERE with conditions for the given ids.
     */ orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Optional returning/output clause.
     */ output(output) {
        return this.returning(output);
    }
    /**
     * Optional returning/output clause.
     */ returning(returning) {
        // not all databases support returning/output cause
        if (!this.connection.driver.isReturningSqlSupported("update")) {
            throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
    }
    /**
     * Sets ORDER BY condition in the query builder.
     * If you had previously ORDER BY expression defined,
     * calling this function will override previously set ORDER BY conditions.
     */ orderBy(sort, order = "ASC", nulls) {
        if (sort) {
            if (typeof sort === "object") {
                this.expressionMap.orderBys = sort;
            } else {
                if (nulls) {
                    this.expressionMap.orderBys = {
                        [sort]: {
                            order,
                            nulls
                        }
                    };
                } else {
                    this.expressionMap.orderBys = {
                        [sort]: order
                    };
                }
            }
        } else {
            this.expressionMap.orderBys = {};
        }
        return this;
    }
    /**
     * Adds ORDER BY condition in the query builder.
     */ addOrderBy(sort, order = "ASC", nulls) {
        if (nulls) {
            this.expressionMap.orderBys[sort] = {
                order,
                nulls
            };
        } else {
            this.expressionMap.orderBys[sort] = order;
        }
        return this;
    }
    /**
     * Sets LIMIT - maximum number of rows to be selected.
     */ limit(limit) {
        this.expressionMap.limit = limit;
        return this;
    }
    /**
     * Indicates if entity must be updated after update operation.
     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
     * Enabled by default.
     */ whereEntity(entity) {
        if (!this.expressionMap.mainAlias.hasMetadata) throw new error_1.TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);
        this.expressionMap.wheres = [];
        const entities = Array.isArray(entity) ? entity : [
            entity
        ];
        entities.forEach((entity)=>{
            const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);
            if (!entityIdMap) throw new error_1.TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);
            this.orWhereInIds(entityIdMap);
        });
        this.expressionMap.whereEntities = entities;
        return this;
    }
    /**
     * Indicates if entity must be updated after update operation.
     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
     * Enabled by default.
     */ updateEntity(enabled) {
        this.expressionMap.updateEntity = enabled;
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates UPDATE express used to perform insert query.
     */ createUpdateExpression() {
        const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;
        if (!metadata) throw new error_1.TypeORMError(`Cannot get entity metadata for the given alias "${this.expressionMap.mainAlias}"`);
        if (!metadata.deleteDateColumn) {
            throw new MissingDeleteDateColumnError_1.MissingDeleteDateColumnError(metadata);
        }
        // prepare columns and values to be updated
        const updateColumnAndValues = [];
        switch(this.expressionMap.queryType){
            case "soft-delete":
                updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
                break;
            case "restore":
                updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + " = NULL");
                break;
            default:
                throw new error_1.TypeORMError(`The queryType must be "soft-delete" or "restore"`);
        }
        if (metadata.versionColumn) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + " = " + this.escape(metadata.versionColumn.databaseName) + " + 1");
        if (metadata.updateDateColumn) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + " = CURRENT_TIMESTAMP"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can "DEFAULT" be used?!
        if (updateColumnAndValues.length <= 0) {
            throw new UpdateValuesMissingError_1.UpdateValuesMissingError();
        }
        // get a table name and all column database names
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression("update");
        if (returningExpression === "") {
            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?
        }
        if (this.connection.driver.options.type === "mssql") {
            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
        }
        return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
    }
    /**
     * Creates "ORDER BY" part of SQL query.
     */ createOrderByExpression() {
        const orderBys = this.expressionMap.orderBys;
        if (Object.keys(orderBys).length > 0) return " ORDER BY " + Object.keys(orderBys).map((columnName)=>{
            if (typeof orderBys[columnName] === "string") {
                return this.replacePropertyNames(columnName) + " " + orderBys[columnName];
            } else {
                return this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
            }
        }).join(", ");
        return "";
    }
    /**
     * Creates "LIMIT" parts of SQL query.
     */ createLimitExpression() {
        const limit = this.expressionMap.limit;
        if (limit) {
            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
                return " LIMIT " + limit;
            } else {
                throw new LimitOnUpdateNotSupportedError_1.LimitOnUpdateNotSupportedError();
            }
        }
        return "";
    }
}
exports.SoftDeleteQueryBuilder = SoftDeleteQueryBuilder; //# sourceMappingURL=SoftDeleteQueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/UpdateQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateQueryBuilder = void 0;
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const UpdateResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/UpdateResult.js [app-route] (ecmascript)");
const ReturningStatementNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ReturningStatementNotSupportedError.js [app-route] (ecmascript)");
const ReturningResultsEntityUpdator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/ReturningResultsEntityUpdator.js [app-route] (ecmascript)");
const LimitOnUpdateNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/LimitOnUpdateNotSupportedError.js [app-route] (ecmascript)");
const UpdateValuesMissingError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/UpdateValuesMissingError.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const EntityPropertyNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/EntityPropertyNotFoundError.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connectionOrQueryBuilder, queryRunner){
        super(connectionOrQueryBuilder, queryRunner);
        this["@instanceof"] = Symbol.for("UpdateQueryBuilder");
        this.expressionMap.aliasNamePrefixingEnabled = false;
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated SQL query without parameters being replaced.
     */ getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createUpdateExpression();
        sql += this.createOrderByExpression();
        sql += this.createLimitExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
    }
    /**
     * Executes sql generated by query builder and returns raw database results.
     */ async execute() {
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
            // start transaction if it was enabled
            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                await queryRunner.startTransaction();
                transactionStartedByUs = true;
            }
            // call before updation methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                await queryRunner.broadcaster.broadcast("BeforeUpdate", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);
            }
            let declareSql = null;
            let selectOutputSql = null;
            // if update entity mode is enabled we may need extra columns for the returning statement
            const returningResultsEntityUpdator = new ReturningResultsEntityUpdator_1.ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
            const returningColumns = [];
            if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {
                for (const columnPath of this.expressionMap.returning){
                    returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));
                }
            }
            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
                this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getUpdationReturningColumns();
                returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c)=>!returningColumns.includes(c)));
            }
            if (returningColumns.length > 0 && this.connection.driver.options.type === "mssql") {
                declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
                selectOutputSql = `SELECT * FROM @OutputTable`;
            }
            // execute update query
            const [updateSql, parameters] = this.getQueryAndParameters();
            const statements = [
                declareSql,
                updateSql,
                selectOutputSql
            ];
            const queryResult = await queryRunner.query(statements.filter((sql)=>sql != null).join(";\n\n"), parameters, true);
            const updateResult = UpdateResult_1.UpdateResult.from(queryResult);
            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)
            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
                await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);
            }
            // call after updation methods in listeners and subscribers
            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                await queryRunner.broadcaster.broadcast("AfterUpdate", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);
            }
            // close transaction if we started it
            if (transactionStartedByUs) await queryRunner.commitTransaction();
            return updateResult;
        } catch (error) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw error;
        } finally{
            if (queryRunner !== this.queryRunner) {
                // means we created our own query runner
                await queryRunner.release();
            }
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Values needs to be updated.
     */ set(values) {
        this.expressionMap.valuesSet = values;
        return this;
    }
    /**
     * Sets WHERE condition in the query builder.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     * Additionally you can add parameters used in where expression.
     */ where(where, parameters) {
        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
        const condition = this.getWhereCondition(where);
        if (condition) this.expressionMap.wheres = [
            {
                type: "simple",
                condition: condition
            }
        ];
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ andWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "and",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new OR WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */ orWhere(where, parameters) {
        this.expressionMap.wheres.push({
            type: "or",
            condition: this.getWhereCondition(where)
        });
        if (parameters) this.setParameters(parameters);
        return this;
    }
    /**
     * Sets WHERE condition in the query builder with a condition for the given ids.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     */ whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     */ andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Adds new OR WHERE with conditions for the given ids.
     */ orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
    }
    /**
     * Optional returning/output clause.
     */ output(output) {
        return this.returning(output);
    }
    /**
     * Optional returning/output clause.
     */ returning(returning) {
        // not all databases support returning/output cause
        if (!this.connection.driver.isReturningSqlSupported("update")) {
            throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
    }
    /**
     * Sets ORDER BY condition in the query builder.
     * If you had previously ORDER BY expression defined,
     * calling this function will override previously set ORDER BY conditions.
     */ orderBy(sort, order = "ASC", nulls) {
        if (sort) {
            if (typeof sort === "object") {
                this.expressionMap.orderBys = sort;
            } else {
                if (nulls) {
                    this.expressionMap.orderBys = {
                        [sort]: {
                            order,
                            nulls
                        }
                    };
                } else {
                    this.expressionMap.orderBys = {
                        [sort]: order
                    };
                }
            }
        } else {
            this.expressionMap.orderBys = {};
        }
        return this;
    }
    /**
     * Adds ORDER BY condition in the query builder.
     */ addOrderBy(sort, order = "ASC", nulls) {
        if (nulls) {
            this.expressionMap.orderBys[sort] = {
                order,
                nulls
            };
        } else {
            this.expressionMap.orderBys[sort] = order;
        }
        return this;
    }
    /**
     * Sets LIMIT - maximum number of rows to be selected.
     */ limit(limit) {
        this.expressionMap.limit = limit;
        return this;
    }
    /**
     * Indicates if entity must be updated after update operation.
     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
     * Enabled by default.
     */ whereEntity(entity) {
        if (!this.expressionMap.mainAlias.hasMetadata) throw new error_1.TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);
        this.expressionMap.wheres = [];
        const entities = Array.isArray(entity) ? entity : [
            entity
        ];
        entities.forEach((entity)=>{
            const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);
            if (!entityIdMap) throw new error_1.TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);
            this.orWhereInIds(entityIdMap);
        });
        this.expressionMap.whereEntities = entities;
        return this;
    }
    /**
     * Indicates if entity must be updated after update operation.
     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
     * Enabled by default.
     */ updateEntity(enabled) {
        this.expressionMap.updateEntity = enabled;
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates UPDATE express used to perform insert query.
     */ createUpdateExpression() {
        const valuesSet = this.getValueSet();
        const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;
        // it doesn't make sense to update undefined properties, so just skip them
        const valuesSetNormalized = {};
        for(const key in valuesSet){
            if (valuesSet[key] !== undefined) {
                valuesSetNormalized[key] = valuesSet[key];
            }
        }
        // prepare columns and values to be updated
        const updateColumnAndValues = [];
        const updatedColumns = [];
        if (metadata) {
            this.createPropertyPath(metadata, valuesSetNormalized).forEach((propertyPath)=>{
                // todo: make this and other query builder to work with properly with tables without metadata
                const columns = metadata.findColumnsWithPropertyPath(propertyPath);
                if (columns.length <= 0) {
                    throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
                }
                columns.forEach((column)=>{
                    if (!column.isUpdate || updatedColumns.includes(column)) {
                        return;
                    }
                    updatedColumns.push(column);
                    //
                    let value = column.getEntityValue(valuesSetNormalized);
                    if (column.referencedColumn && typeof value === "object" && !(value instanceof Date) && value !== null && !Buffer.isBuffer(value)) {
                        value = column.referencedColumn.getEntityValue(value);
                    } else if (!(typeof value === "function")) {
                        value = this.connection.driver.preparePersistentValue(value, column);
                    }
                    // todo: duplication zone
                    if (typeof value === "function") {
                        // support for SQL expressions in update query
                        updateColumnAndValues.push(this.escape(column.databaseName) + " = " + value());
                    } else if ((this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") && value === null) {
                        updateColumnAndValues.push(this.escape(column.databaseName) + " = NULL");
                    } else {
                        if (this.connection.driver.options.type === "mssql") {
                            value = this.connection.driver.parametrizeValue(column, value);
                        }
                        const paramName = this.createParameter(value);
                        let expression = null;
                        if ((DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                            const useLegacy = this.connection.driver.options.legacySpatialSupport;
                            const geomFromText = useLegacy ? "GeomFromText" : "ST_GeomFromText";
                            if (column.srid != null) {
                                expression = `${geomFromText}(${paramName}, ${column.srid})`;
                            } else {
                                expression = `${geomFromText}(${paramName})`;
                            }
                        } else if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                            if (column.srid != null) {
                                expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;
                            } else {
                                expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
                            }
                        } else if (this.connection.driver.options.type === "mssql" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                            expression = column.type + "::STGeomFromText(" + paramName + ", " + (column.srid || "0") + ")";
                        } else {
                            expression = paramName;
                        }
                        updateColumnAndValues.push(this.escape(column.databaseName) + " = " + expression);
                    }
                });
            });
            // Don't allow calling update only with columns that are `update: false`
            if (updateColumnAndValues.length > 0 || Object.keys(valuesSetNormalized).length === 0) {
                if (metadata.versionColumn && updatedColumns.indexOf(metadata.versionColumn) === -1) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + " = " + this.escape(metadata.versionColumn.databaseName) + " + 1");
                if (metadata.updateDateColumn && updatedColumns.indexOf(metadata.updateDateColumn) === -1) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + " = CURRENT_TIMESTAMP"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can "DEFAULT" be used?!
            }
        } else {
            Object.keys(valuesSetNormalized).map((key)=>{
                const value = valuesSetNormalized[key];
                // todo: duplication zone
                if (typeof value === "function") {
                    // support for SQL expressions in update query
                    updateColumnAndValues.push(this.escape(key) + " = " + value());
                } else if ((this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") && value === null) {
                    updateColumnAndValues.push(this.escape(key) + " = NULL");
                } else {
                    // we need to store array values in a special class to make sure parameter replacement will work correctly
                    // if (value instanceof Array)
                    //     value = new ArrayParameter(value);
                    const paramName = this.createParameter(value);
                    updateColumnAndValues.push(this.escape(key) + " = " + paramName);
                }
            });
        }
        if (updateColumnAndValues.length <= 0) {
            throw new UpdateValuesMissingError_1.UpdateValuesMissingError();
        }
        // get a table name and all column database names
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression("update");
        if (returningExpression === "") {
            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?
        }
        if (this.connection.driver.options.type === "mssql") {
            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "spanner") {
            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} THEN RETURN ${returningExpression}`;
        }
        return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
    }
    /**
     * Creates "ORDER BY" part of SQL query.
     */ createOrderByExpression() {
        const orderBys = this.expressionMap.orderBys;
        if (Object.keys(orderBys).length > 0) return " ORDER BY " + Object.keys(orderBys).map((columnName)=>{
            if (typeof orderBys[columnName] === "string") {
                return this.replacePropertyNames(columnName) + " " + orderBys[columnName];
            } else {
                return this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
            }
        }).join(", ");
        return "";
    }
    /**
     * Creates "LIMIT" parts of SQL query.
     */ createLimitExpression() {
        const limit = this.expressionMap.limit;
        if (limit) {
            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
                return " LIMIT " + limit;
            } else {
                throw new LimitOnUpdateNotSupportedError_1.LimitOnUpdateNotSupportedError();
            }
        }
        return "";
    }
    /**
     * Gets array of values need to be inserted into the target table.
     */ getValueSet() {
        if (typeof this.expressionMap.valuesSet === "object") return this.expressionMap.valuesSet;
        throw new UpdateValuesMissingError_1.UpdateValuesMissingError();
    }
}
exports.UpdateQueryBuilder = UpdateQueryBuilder; //# sourceMappingURL=UpdateQueryBuilder.js.map
}),
"[project]/node_modules/typeorm/query-builder/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerQueryBuilders = registerQueryBuilders;
const DeleteQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/DeleteQueryBuilder.js [app-route] (ecmascript)");
const InsertQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/InsertQueryBuilder.js [app-route] (ecmascript)");
const QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
const RelationQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationQueryBuilder.js [app-route] (ecmascript)");
const SelectQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/SelectQueryBuilder.js [app-route] (ecmascript)");
const SoftDeleteQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/SoftDeleteQueryBuilder.js [app-route] (ecmascript)");
const UpdateQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/UpdateQueryBuilder.js [app-route] (ecmascript)");
function registerQueryBuilders() {
    QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("DeleteQueryBuilder", (qb)=>new DeleteQueryBuilder_1.DeleteQueryBuilder(qb));
    QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("InsertQueryBuilder", (qb)=>new InsertQueryBuilder_1.InsertQueryBuilder(qb));
    QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("RelationQueryBuilder", (qb)=>new RelationQueryBuilder_1.RelationQueryBuilder(qb));
    QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("SelectQueryBuilder", (qb)=>new SelectQueryBuilder_1.SelectQueryBuilder(qb));
    QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("SoftDeleteQueryBuilder", (qb)=>new SoftDeleteQueryBuilder_1.SoftDeleteQueryBuilder(qb));
    QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("UpdateQueryBuilder", (qb)=>new UpdateQueryBuilder_1.UpdateQueryBuilder(qb));
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PlainObjectToNewEntityTransformer = void 0;
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Transforms plain old javascript object
 * Entity is constructed based on its entity metadata.
 */ class PlainObjectToNewEntityTransformer {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    transform(newEntity, object, metadata, getLazyRelationsPromiseValue = false) {
        // console.log("groupAndTransform entity:", newEntity);
        // console.log("groupAndTransform object:", object);
        this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);
        // console.log("result:", newEntity);
        return newEntity;
    }
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    /**
     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
     * we need to group our result and we must have some unique id (primary key in our case)
     */ groupAndTransform(entity, object, metadata, getLazyRelationsPromiseValue = false) {
        // console.log("groupAndTransform entity:", entity);
        // console.log("groupAndTransform object:", object);
        // copy regular column properties from the given object
        metadata.nonVirtualColumns.forEach((column)=>{
            const objectColumnValue = column.getEntityValue(object);
            if (objectColumnValue !== undefined) column.setEntityValue(entity, objectColumnValue);
        });
        // // copy relation properties from the given object
        if (metadata.relations.length) {
            metadata.relations.forEach((relation)=>{
                let entityRelatedValue = relation.getEntityValue(entity);
                const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);
                if (objectRelatedValue === undefined) return;
                if (relation.isOneToMany || relation.isManyToMany) {
                    if (!Array.isArray(objectRelatedValue)) return;
                    if (!entityRelatedValue) {
                        entityRelatedValue = [];
                        relation.setEntityValue(entity, entityRelatedValue);
                    }
                    objectRelatedValue.forEach((objectRelatedValueItem)=>{
                        // check if we have this item from the merging object in the original entity we merge into
                        let objectRelatedValueEntity = entityRelatedValue.find((entityRelatedValueItem)=>{
                            return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);
                        });
                        const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValueItem);
                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array
                        if (!objectRelatedValueEntity) {
                            objectRelatedValueEntity = inverseEntityMetadata.create(undefined, {
                                fromDeserializer: true
                            });
                            entityRelatedValue.push(objectRelatedValueEntity);
                        }
                        this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, inverseEntityMetadata, getLazyRelationsPromiseValue);
                    });
                } else {
                    // if related object isn't an object (direct relation id for example)
                    // we just set it to the entity relation, we don't need anything more from it
                    // however we do it only if original entity does not have this relation set to object
                    // to prevent full overriding of objects
                    if (!ObjectUtils_1.ObjectUtils.isObject(objectRelatedValue)) {
                        if (!ObjectUtils_1.ObjectUtils.isObject(entityRelatedValue)) relation.setEntityValue(entity, objectRelatedValue);
                        return;
                    }
                    const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValue);
                    if (!entityRelatedValue) {
                        entityRelatedValue = inverseEntityMetadata.create(undefined, {
                            fromDeserializer: true
                        });
                        relation.setEntityValue(entity, entityRelatedValue);
                    }
                    this.groupAndTransform(entityRelatedValue, objectRelatedValue, inverseEntityMetadata, getLazyRelationsPromiseValue);
                }
            });
        }
    }
}
exports.PlainObjectToNewEntityTransformer = PlainObjectToNewEntityTransformer; //# sourceMappingURL=PlainObjectToNewEntityTransformer.js.map
}),
"[project]/node_modules/typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PlainObjectToDatabaseEntityTransformer = void 0;
/**
 */ class LoadMapItem {
    constructor(plainEntity, metadata, parentLoadMapItem, relation){
        this.plainEntity = plainEntity;
        this.metadata = metadata;
        this.parentLoadMapItem = parentLoadMapItem;
        this.relation = relation;
    }
    get target() {
        return this.metadata.target;
    }
    get id() {
        return this.metadata.getEntityIdMixedMap(this.plainEntity);
    }
}
class LoadMap {
    constructor(){
        this.loadMapItems = [];
    }
    get mainLoadMapItem() {
        return this.loadMapItems.find((item)=>!item.relation && !item.parentLoadMapItem);
    }
    addLoadMap(newLoadMap) {
        const item = this.loadMapItems.find((item)=>item.target === newLoadMap.target && item.id === newLoadMap.id);
        if (!item) this.loadMapItems.push(newLoadMap);
    }
    fillEntities(target, entities) {
        entities.forEach((entity)=>{
            const item = this.loadMapItems.find((loadMapItem)=>{
                return loadMapItem.target === target && loadMapItem.metadata.compareEntities(entity, loadMapItem.plainEntity);
            });
            if (item) item.entity = entity;
        });
    }
    groupByTargetIds() {
        const groups = [];
        this.loadMapItems.forEach((loadMapItem)=>{
            let group = groups.find((group)=>group.target === loadMapItem.target);
            if (!group) {
                group = {
                    target: loadMapItem.target,
                    ids: []
                };
                groups.push(group);
            }
            group.ids.push(loadMapItem.id);
        });
        return groups;
    }
}
/**
 * Transforms plain old javascript object
 * Entity is constructed based on its entity metadata.
 */ class PlainObjectToDatabaseEntityTransformer {
    constructor(manager){
        this.manager = manager;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    async transform(plainObject, metadata) {
        // if plain object does not have id then nothing to load really
        if (!metadata.hasAllPrimaryKeys(plainObject)) return Promise.reject("Given object does not have a primary column, cannot transform it to database entity.");
        // create a special load map that will hold all metadata that will be used to operate with entities easily
        const loadMap = new LoadMap();
        const fillLoadMap = (entity, entityMetadata, parentLoadMapItem, relation)=>{
            const item = new LoadMapItem(entity, entityMetadata, parentLoadMapItem, relation);
            loadMap.addLoadMap(item);
            entityMetadata.extractRelationValuesFromEntity(entity, metadata.relations).filter((value)=>value !== null && value !== undefined).forEach(([relation, value, inverseEntityMetadata])=>fillLoadMap(value, inverseEntityMetadata, item, relation));
        };
        fillLoadMap(plainObject, metadata);
        // load all entities and store them in the load map
        await Promise.all(loadMap.groupByTargetIds().map((targetWithIds)=>{
            // todo: fix type hinting
            return this.manager.findByIds(targetWithIds.target, targetWithIds.ids).then((entities)=>loadMap.fillEntities(targetWithIds.target, entities));
        }));
        // go through each item in the load map and set their entity relationship using metadata stored in load map
        loadMap.loadMapItems.forEach((loadMapItem)=>{
            if (!loadMapItem.relation || !loadMapItem.entity || !loadMapItem.parentLoadMapItem || !loadMapItem.parentLoadMapItem.entity) return;
            if (loadMapItem.relation.isManyToMany || loadMapItem.relation.isOneToMany) {
                if (!loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName]) loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = [];
                loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName].push(loadMapItem.entity);
            } else {
                loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = loadMapItem.entity;
            }
        });
        return loadMap.mainLoadMapItem ? loadMap.mainLoadMapItem.entity : undefined;
    }
}
exports.PlainObjectToDatabaseEntityTransformer = PlainObjectToDatabaseEntityTransformer; //# sourceMappingURL=PlainObjectToDatabaseEntityTransformer.js.map
}),
"[project]/node_modules/typeorm/query-builder/transformer/DocumentToEntityTransformer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DocumentToEntityTransformer = void 0;
/**
 * Transforms raw document into entity object.
 * Entity is constructed based on its entity metadata.
 */ class DocumentToEntityTransformer {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(// private selectionMap: AliasMap,
    // private joinMappings: JoinMapping[],
    // private relationCountMetas: RelationCountAttribute[],
    enableRelationIdValues = false){
        this.enableRelationIdValues = enableRelationIdValues;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    transformAll(documents, metadata) {
        return documents.map((document)=>this.transform(document, metadata));
    }
    transform(document, metadata) {
        const entity = metadata.create(undefined, {
            fromDeserializer: true
        });
        let hasData = false;
        // handle _id property the special way
        if (metadata.objectIdColumn) {
            // todo: we can't use driver in this class
            // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?
            // entity[metadata.ObjectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.ObjectIdColumn.name"], metadata.ObjectIdColumn);
            const { databaseNameWithoutPrefixes, propertyName } = metadata.objectIdColumn;
            const documentIdWithoutPrefixes = document[databaseNameWithoutPrefixes];
            const documentIdWithPropertyName = document[propertyName];
            if (documentIdWithoutPrefixes) {
                entity[propertyName] = documentIdWithoutPrefixes;
                hasData = true;
            } else if (documentIdWithPropertyName) {
                entity[propertyName] = documentIdWithPropertyName;
                hasData = true;
            }
        }
        // add special columns that contains relation ids
        if (this.enableRelationIdValues) {
            metadata.columns.filter((column)=>!!column.relationMetadata).forEach((column)=>{
                const valueInObject = document[column.databaseNameWithoutPrefixes];
                if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {
                    // todo: we can't use driver in this class
                    // const value = this.driver.prepareHydratedValue(valueInObject, column);
                    entity[column.propertyName] = valueInObject;
                    hasData = true;
                }
            });
        }
        /*this.joinMappings
            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)
            .map(joinMapping => {
                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);
                const isResultArray = joinMapping.isMany;
                const result = !isResultArray ? relatedEntities[0] : relatedEntities;

                if (result && (!isResultArray || result.length > 0)) {
                    entity[joinMapping.propertyName] = result;
                    hasData = true;
                }
            });*/ // get value from columns selections and put them into object
        metadata.ownColumns.forEach((column)=>{
            const valueInObject = document[column.databaseNameWithoutPrefixes];
            if (valueInObject !== undefined && column.propertyName && !column.isVirtual) {
                // const value = this.driver.prepareHydratedValue(valueInObject, column);
                entity[column.propertyName] = valueInObject;
                hasData = true;
            }
        });
        const addEmbeddedValuesRecursively = (entity, document, embeddeds)=>{
            embeddeds.forEach((embedded)=>{
                if (!document[embedded.prefix]) return;
                if (embedded.isArray) {
                    entity[embedded.propertyName] = document[embedded.prefix].map((subValue, index)=>{
                        const newItem = embedded.create({
                            fromDeserializer: true
                        });
                        embedded.columns.forEach((column)=>{
                            newItem[column.propertyName] = subValue[column.databaseNameWithoutPrefixes];
                        });
                        addEmbeddedValuesRecursively(newItem, document[embedded.prefix][index], embedded.embeddeds);
                        return newItem;
                    });
                } else {
                    if (embedded.embeddeds.length && !entity[embedded.propertyName]) entity[embedded.propertyName] = embedded.create({
                        fromDeserializer: true
                    });
                    embedded.columns.forEach((column)=>{
                        const value = document[embedded.prefix][column.databaseNameWithoutPrefixes];
                        if (value === undefined) return;
                        if (!entity[embedded.propertyName]) entity[embedded.propertyName] = embedded.create({
                            fromDeserializer: true
                        });
                        entity[embedded.propertyName][column.propertyName] = value;
                    });
                    addEmbeddedValuesRecursively(entity[embedded.propertyName], document[embedded.prefix], embedded.embeddeds);
                }
            });
        };
        addEmbeddedValuesRecursively(entity, document, metadata.embeddeds);
        // if relation is loaded then go into it recursively and transform its values too
        /*metadata.relations.forEach(relation => {
            const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);
            if (relationAlias) {
                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === "join" && joinMapping.alias === relationAlias);
                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);
                const isResultArray = relation.isManyToMany || relation.isOneToMany;
                const result = !isResultArray ? relatedEntities[0] : relatedEntities;

                if (result) {
                    let propertyName = relation.propertyName;
                    if (joinMapping) {
                        propertyName = joinMapping.propertyName;
                    }

                    if (relation.isLazy) {
                        entity["__" + propertyName + "__"] = result;
                    } else {
                        entity[propertyName] = result;
                    }

                    if (!isResultArray || result.length > 0)
                        hasData = true;
                }
            }

            // if relation has id field then relation id/ids to that field.
            if (relation.isManyToMany) {
                if (relationAlias) {
                    const ids: any[] = [];
                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === "relationId" && joinMapping.alias === relationAlias);

                    if (relation.idField || joinMapping) {
                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;
                        const junctionMetadata = relation.junctionEntityMetadata;
                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;

                        rawSqlResults.forEach(results => {
                            if (relationAlias) {
                                const resultsKey = relationAlias.name + "_" + columnName;
                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);
                                if (value !== undefined && value !== null)
                                    ids.push(value);
                            }
                        });

                        if (ids && ids.length)
                            entity[propertyName] = ids;
                    }
                }
            } else if (relation.idField) {
                const relationName = relation.name;
                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + "_" + relationName], relation.referencedColumn);
            }

            // if relation counter
            this.relationCountMetas.forEach(joinMeta => {
                if (joinMeta.alias === relationAlias) {
                    // console.log("relation count was found for relation: ", relation);
                    // joinMeta.entity = entity;
                    joinMeta.entities.push({ entity: entity, metadata: metadata });
                    // console.log(joinMeta);
                    // console.log("---------------------");
                }
            });
        });*/ return hasData ? entity : null;
    }
}
exports.DocumentToEntityTransformer = DocumentToEntityTransformer; //# sourceMappingURL=DocumentToEntityTransformer.js.map
}),
"[project]/node_modules/typeorm/query-builder/RelationLoader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationLoader = void 0;
const FindOptionsUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)");
/**
 * Wraps entities and creates getters/setters for their relations
 * to be able to lazily load relations when accessing these relations.
 */ class RelationLoader {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Loads relation data for the given entity and its relation.
     */ load(relation, entityOrEntities, queryRunner, queryBuilder) {
        // todo: check all places where it uses non array
        if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed
        if (relation.isManyToOne || relation.isOneToOneOwner) {
            return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        } else if (relation.isManyToManyOwner) {
            return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        } else {
            // many-to-many non owner
            return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        }
    }
    /**
     * Loads data for many-to-one and one-to-one owner relations.
     *
     * (ow) post.category<=>category.post
     * loaded: category from post
     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category
     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1
     */ loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [
            entityOrEntities
        ];
        const joinAliasName = relation.entityMetadata.name;
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName) // category
        .from(relation.type, relation.propertyName);
        const mainAlias = qb.expressionMap.mainAlias.name;
        const columns = relation.entityMetadata.primaryColumns;
        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
        const conditions = joinColumns.map((joinColumn)=>{
            return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;
        }).join(" AND ");
        qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);
        if (columns.length === 1) {
            qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + "_" + columns[0].propertyName})`);
            qb.setParameter(joinAliasName + "_" + columns[0].propertyName, entities.map((entity)=>columns[0].getEntityValue(entity, true)));
        } else {
            const condition = entities.map((entity, entityIndex)=>{
                return columns.map((column, columnIndex)=>{
                    const paramName = joinAliasName + "_entity_" + entityIndex + "_" + columnIndex;
                    qb.setParameter(paramName, column.getEntityValue(entity, true));
                    return joinAliasName + "." + column.propertyPath + " = :" + paramName;
                }).join(" AND ");
            }).map((condition)=>"(" + condition + ")").join(" OR ");
            qb.where(condition);
        }
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
    // return qb.getOne(); todo: fix all usages
    }
    /**
     * Loads data for one-to-many and one-to-one not owner relations.
     *
     * SELECT post
     * FROM post post
     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]
     */ loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [
            entityOrEntities
        ];
        const columns = relation.inverseRelation.joinColumns;
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.inverseRelation.entityMetadata.target, relation.propertyName);
        const aliasName = qb.expressionMap.mainAlias.name;
        if (columns.length === 1) {
            qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + "_" + columns[0].propertyName})`);
            qb.setParameter(aliasName + "_" + columns[0].propertyName, entities.map((entity)=>columns[0].referencedColumn.getEntityValue(entity, true)));
        } else {
            const condition = entities.map((entity, entityIndex)=>{
                return columns.map((column, columnIndex)=>{
                    const paramName = aliasName + "_entity_" + entityIndex + "_" + columnIndex;
                    qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));
                    return aliasName + "." + column.propertyPath + " = :" + paramName;
                }).join(" AND ");
            }).map((condition)=>"(" + condition + ")").join(" OR ");
            qb.where(condition);
        }
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
    // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages
    }
    /**
     * Loads data for many-to-many owner relations.
     *
     * SELECT category
     * FROM category category
     * INNER JOIN post_categories post_categories
     * ON post_categories.postId = :postId
     * AND post_categories.categoryId = category.id
     */ loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [
            entityOrEntities
        ];
        const parameters = relation.joinColumns.reduce((parameters, joinColumn)=>{
            parameters[joinColumn.propertyName] = entities.map((entity)=>joinColumn.referencedColumn.getEntityValue(entity, true));
            return parameters;
        }, {});
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
        const mainAlias = qb.expressionMap.mainAlias.name;
        const joinAlias = relation.junctionEntityMetadata.tableName;
        const joinColumnConditions = relation.joinColumns.map((joinColumn)=>{
            return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;
        });
        const inverseJoinColumnConditions = relation.inverseJoinColumns.map((inverseJoinColumn)=>{
            return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;
        });
        qb.innerJoin(joinAlias, joinAlias, [
            ...joinColumnConditions,
            ...inverseJoinColumnConditions
        ].join(" AND ")).setParameters(parameters);
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
    }
    /**
     * Loads data for many-to-many not owner relations.
     *
     * SELECT post
     * FROM post post
     * INNER JOIN post_categories post_categories
     * ON post_categories.postId = post.id
     * AND post_categories.categoryId = post_categories.categoryId
     */ loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [
            entityOrEntities
        ];
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
        const mainAlias = qb.expressionMap.mainAlias.name;
        const joinAlias = relation.junctionEntityMetadata.tableName;
        const joinColumnConditions = relation.inverseRelation.joinColumns.map((joinColumn)=>{
            return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;
        });
        const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map((inverseJoinColumn)=>{
            return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;
        });
        const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters, joinColumn)=>{
            parameters[joinColumn.propertyName] = entities.map((entity)=>joinColumn.referencedColumn.getEntityValue(entity, true));
            return parameters;
        }, {});
        qb.innerJoin(joinAlias, joinAlias, [
            ...joinColumnConditions,
            ...inverseJoinColumnConditions
        ].join(" AND ")).setParameters(parameters);
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
    }
    /**
     * Wraps given entity and creates getters/setters for its given relation
     * to be able to lazily load data when accessing this relation.
     */ enableLazyLoad(relation, entity, queryRunner) {
        const relationLoader = this;
        const dataIndex = "__" + relation.propertyName + "__"; // in what property of the entity loaded data will be stored
        const promiseIndex = "__promise_" + relation.propertyName + "__"; // in what property of the entity loading promise will be stored
        const resolveIndex = "__has_" + relation.propertyName + "__"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty
        const setData = (entity, value)=>{
            entity[dataIndex] = value;
            entity[resolveIndex] = true;
            delete entity[promiseIndex];
            return value;
        };
        const setPromise = (entity, value)=>{
            delete entity[resolveIndex];
            delete entity[dataIndex];
            entity[promiseIndex] = value;
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            value.then(// ensure different value is not assigned yet
            (result)=>entity[promiseIndex] === value ? setData(entity, result) : result);
            return value;
        };
        Object.defineProperty(entity, relation.propertyName, {
            get: function() {
                if (this[resolveIndex] === true || this[dataIndex] !== undefined) // if related data already was loaded then simply return it
                return Promise.resolve(this[dataIndex]);
                if (this[promiseIndex]) // if related data is loading then return a promise relationLoader loads it
                return this[promiseIndex];
                // nothing is loaded yet, load relation data and save it in the model once they are loaded
                const loader = relationLoader.load(relation, this, queryRunner).then((result)=>relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result);
                return setPromise(this, loader);
            },
            set: function(value) {
                if (value instanceof Promise) {
                    // if set data is a promise then wait for its resolve and save in the object
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    setPromise(this, value);
                } else {
                    // if its direct data set (non promise, probably not safe-typed)
                    setData(this, value);
                }
            },
            configurable: true,
            enumerable: false
        });
    }
}
exports.RelationLoader = RelationLoader; //# sourceMappingURL=RelationLoader.js.map
}),
"[project]/node_modules/typeorm/query-builder/NotBrackets.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NotBrackets = void 0;
const Brackets_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/Brackets.js [app-route] (ecmascript)");
/**
 * Syntax sugar.
 * Allows to use negate brackets in WHERE expressions for better syntax.
 */ class NotBrackets extends Brackets_1.Brackets {
    constructor(){
        super(...arguments);
        this["@instanceof"] = Symbol.for("NotBrackets");
    }
}
exports.NotBrackets = NotBrackets; //# sourceMappingURL=NotBrackets.js.map
}),
];

//# sourceMappingURL=node_modules_typeorm_query-builder_a8f248ed._.js.map