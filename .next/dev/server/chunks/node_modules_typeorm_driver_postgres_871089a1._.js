module.exports = [
"[project]/node_modules/typeorm/driver/postgres/PostgresQueryRunner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PostgresQueryRunner = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const BaseQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/BaseQueryRunner.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const TableCheck_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)");
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const TableExclusion_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableExclusion.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const Query_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)");
const MetadataTableType_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/types/MetadataTableType.js [app-route] (ecmascript)");
/**
 * Runs queries on a single postgres database connection.
 */ class PostgresQueryRunner extends BaseQueryRunner_1.BaseQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver, mode){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.mode = mode;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */ connect() {
        if (this.databaseConnection) return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise) return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
            this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release])=>{
                this.driver.connectedQueryRunners.push(this);
                this.databaseConnection = connection;
                const onErrorCallback = (err)=>this.releasePostgresConnection(err);
                this.releaseCallback = (err)=>{
                    this.databaseConnection.removeListener("error", onErrorCallback);
                    release(err);
                };
                this.databaseConnection.on("error", onErrorCallback);
                return this.databaseConnection;
            });
        } else {
            // master
            this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release])=>{
                this.driver.connectedQueryRunners.push(this);
                this.databaseConnection = connection;
                const onErrorCallback = (err)=>this.releasePostgresConnection(err);
                this.releaseCallback = (err)=>{
                    this.databaseConnection.removeListener("error", onErrorCallback);
                    release(err);
                };
                this.databaseConnection.on("error", onErrorCallback);
                return this.databaseConnection;
            });
        }
        return this.databaseConnectionPromise;
    }
    /**
     * Release a connection back to the pool, optionally specifying an Error to release with.
     * Per pg-pool documentation this will prevent the pool from re-using the broken connection.
     */ async releasePostgresConnection(err) {
        if (this.isReleased) {
            return;
        }
        this.isReleased = true;
        if (this.releaseCallback) {
            this.releaseCallback(err);
            this.releaseCallback = undefined;
        }
        const index = this.driver.connectedQueryRunners.indexOf(this);
        if (index !== -1) {
            this.driver.connectedQueryRunners.splice(index, 1);
        }
    }
    /**
     * Releases used database connection.
     * You cannot use query runner methods once its released.
     */ release() {
        return this.releasePostgresConnection();
    }
    /**
     * Starts transaction.
     */ async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        if (this.transactionDepth === 0) {
            await this.query("START TRANSACTION");
            if (isolationLevel) {
                await this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
            }
        } else {
            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
            await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.query("COMMIT");
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.query("ROLLBACK");
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        try {
            const queryStartTime = Date.now();
            const raw = await databaseConnection.query(query, parameters);
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            const result = new QueryResult_1.QueryResult();
            if (raw) {
                if (raw.hasOwnProperty("rows")) {
                    result.records = raw.rows;
                }
                if (raw.hasOwnProperty("rowCount")) {
                    result.affected = raw.rowCount;
                }
                switch(raw.command){
                    case "DELETE":
                    case "UPDATE":
                        // for UPDATE and DELETE query additionally return number of affected rows
                        result.raw = [
                            raw.rows,
                            raw.rowCount
                        ];
                        break;
                    default:
                        result.raw = raw.rows;
                }
                if (!useStructuredResult) {
                    return result.raw;
                }
            }
            return result;
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally{
            await broadcasterResult.wait();
        }
    }
    /**
     * Returns raw data stream.
     */ async stream(query, parameters, onEnd, onError) {
        const QueryStream = this.driver.loadStreamDependency();
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        const stream = databaseConnection.query(new QueryStream(query, parameters));
        if (onEnd) stream.on("end", onEnd);
        if (onError) stream.on("error", onError);
        return stream;
    }
    /**
     * Returns all available database names including system databases.
     */ async getDatabases() {
        return Promise.resolve([]);
    }
    /**
     * Returns all available schema names including system schemas.
     * If database parameter specified, returns schemas of that database.
     */ async getSchemas(database) {
        return Promise.resolve([]);
    }
    /**
     * Checks if database with the given name exist.
     */ async hasDatabase(database) {
        const result = await this.query(`SELECT * FROM pg_database WHERE datname='${database}';`);
        return result.length ? true : false;
    }
    /**
     * Loads currently using database
     */ async getCurrentDatabase() {
        const query = await this.query(`SELECT * FROM current_database()`);
        return query[0]["current_database"];
    }
    /**
     * Checks if schema with the given name exist.
     */ async hasSchema(schema) {
        const result = await this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
        return result.length ? true : false;
    }
    /**
     * Loads currently using database schema
     */ async getCurrentSchema() {
        const query = await this.query(`SELECT * FROM current_schema()`);
        return query[0]["current_schema"];
    }
    /**
     * Checks if table with the given name exist in the database.
     */ async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
            parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "information_schema"."tables" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Checks if column with the given name exist in the given table.
     */ async hasColumn(tableOrName, columnName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
            parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "information_schema"."columns" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}' AND "column_name" = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Creates a new database.
     * Note: Postgres does not support database creation inside a transaction block.
     */ async createDatabase(database, ifNotExist) {
        if (ifNotExist) {
            const databaseAlreadyExists = await this.hasDatabase(database);
            if (databaseAlreadyExists) return Promise.resolve();
        }
        const up = `CREATE DATABASE "${database}"`;
        const down = `DROP DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Drops database.
     * Note: Postgres does not support database dropping inside a transaction block.
     */ async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS "${database}"` : `DROP DATABASE "${database}"`;
        const down = `CREATE DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Creates a new table schema.
     */ async createSchema(schemaPath, ifNotExist) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS "${schema}"` : `CREATE SCHEMA "${schema}"`;
        const down = `DROP SCHEMA "${schema}" CASCADE`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Drops table schema.
     */ async dropSchema(schemaPath, ifExist, isCascade) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        const up = ifExist ? `DROP SCHEMA IF EXISTS "${schema}" ${isCascade ? "CASCADE" : ""}` : `DROP SCHEMA "${schema}" ${isCascade ? "CASCADE" : ""}`;
        const down = `CREATE SCHEMA "${schema}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Creates a new table.
     */ async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
            const isTableExist = await this.hasTable(table);
            if (isTableExist) return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        // if table have column with ENUM type, we must create this type in postgres.
        const enumColumns = table.columns.filter((column)=>column.type === "enum" || column.type === "simple-enum");
        const createdEnumTypes = [];
        for (const column of enumColumns){
            // TODO: Should also check if values of existing type matches expected ones
            const hasEnum = await this.hasEnumType(table, column);
            const enumName = this.buildEnumName(table, column);
            // if enum with the same "enumName" is defined more then once, me must prevent double creation
            if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {
                createdEnumTypes.push(enumName);
                upQueries.push(this.createEnumTypeSql(table, column, enumName));
                downQueries.push(this.dropEnumTypeSql(table, column, enumName));
            }
        }
        // if table have column with generated type, we must add the expression to the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType === "STORED" && column.asExpression);
        for (const column of generatedColumns){
            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
            const tableName = tableNameWithSchema[1];
            const schema = tableNameWithSchema[0];
            const insertQuery = this.insertTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        // if createForeignKeys is true, we must drop created foreign keys in down query.
        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
        if (createForeignKeys) table.foreignKeys.forEach((foreignKey)=>downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
            table.indices.forEach((index)=>{
                // new index may be passed without name. In this case we generate index name manually.
                if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
                upQueries.push(this.createIndexSql(table, index));
                downQueries.push(this.dropIndexSql(table, index));
            });
        }
        if (table.comment) {
            upQueries.push(new Query_1.Query("COMMENT ON TABLE " + this.escapePath(table) + " IS '" + table.comment + "'"));
            downQueries.push(new Query_1.Query("COMMENT ON TABLE " + this.escapePath(table) + " IS NULL"));
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the table.
     */ async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need
        // to perform drop queries for foreign keys and indices.
        if (ifExist) {
            const isTableExist = await this.hasTable(target);
            if (!isTableExist) return Promise.resolve();
        }
        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
            table.indices.forEach((index)=>{
                upQueries.push(this.dropIndexSql(table, index));
                downQueries.push(this.createIndexSql(table, index));
            });
        }
        if (dropForeignKeys) table.foreignKeys.forEach((foreignKey)=>upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        // if table had columns with generated type, we must remove the expression from the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
            const tableName = tableNameWithSchema[1];
            const schema = tableNameWithSchema[0];
            const deleteQuery = this.deleteTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Creates a new view.
     */ async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata) upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata) downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the view.
     */ async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Renames the given table.
     */ async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { schema: schemaName, tableName: oldTableName } = this.driver.parseTableName(oldTable);
        newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO "${newTableName}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO "${oldTableName}"`));
        // rename column primary key constraint if it has default constraint name
        if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
            const columnNames = newTable.primaryColumns.map((column)=>column.name);
            const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
            const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
        }
        // rename sequences
        newTable.columns.map((col)=>{
            if (col.isGenerated && col.generationStrategy === "increment") {
                const sequencePath = this.buildSequencePath(oldTable, col.name);
                const sequenceName = this.buildSequenceName(oldTable, col.name);
                const newSequencePath = this.buildSequencePath(newTable, col.name);
                const newSequenceName = this.buildSequenceName(newTable, col.name);
                const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO "${newSequenceName}"`;
                const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO "${sequenceName}"`;
                upQueries.push(new Query_1.Query(up));
                downQueries.push(new Query_1.Query(down));
            }
        });
        // rename unique constraints
        newTable.uniques.forEach((unique)=>{
            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
            // Skip renaming if Unique has user defined constraint name
            if (unique.name !== oldUniqueName) return;
            // build new constraint name
            const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
            // build queries
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
            // replace constraint name
            unique.name = newUniqueName;
        });
        // rename index constraints
        newTable.indices.forEach((index)=>{
            const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
            // Skip renaming if Index has user defined constraint name
            if (index.name !== oldIndexName) return;
            // build new constraint name
            const { schema } = this.driver.parseTableName(newTable);
            const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
            // build queries
            const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
            const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
            upQueries.push(new Query_1.Query(up));
            downQueries.push(new Query_1.Query(down));
            // replace constraint name
            index.name = newIndexName;
        });
        // rename foreign key constraints
        newTable.foreignKeys.forEach((foreignKey)=>{
            const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            // Skip renaming if foreign key has user defined constraint name
            if (foreignKey.name !== oldForeignKeyName) return;
            // build new constraint name
            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            // build queries
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
            // replace constraint name
            foreignKey.name = newForeignKeyName;
        });
        // rename ENUM types
        const enumColumns = newTable.columns.filter((column)=>column.type === "enum" || column.type === "simple-enum");
        for (const column of enumColumns){
            // skip renaming for user-defined enum name
            if (column.enumName) continue;
            const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);
            upQueries.push(new Query_1.Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(newTable, column, false)}`));
            downQueries.push(new Query_1.Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO "${oldEnumType.name}"`));
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Creates a new column from the column in the table.
     */ async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.type === "enum" || column.type === "simple-enum") {
            const hasEnum = await this.hasEnumType(table, column);
            if (!hasEnum) {
                upQueries.push(this.createEnumTypeSql(table, column));
                downQueries.push(this.dropEnumTypeSql(table, column));
            }
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        // create or update primary key constraint
        if (column.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            // if table already have primary key, me must drop it and recreate again
            if (primaryColumns.length > 0) {
                const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            primaryColumns.push(column);
            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
            const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        // create column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            upQueries.push(this.createIndexSql(table, columnIndex));
            downQueries.push(this.dropIndexSql(table, columnIndex));
        }
        // create unique constraint
        if (column.isUnique) {
            const uniqueConstraint = new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ]
            });
            clonedTable.uniques.push(uniqueConstraint);
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
        }
        if (column.generatedType === "STORED" && column.asExpression) {
            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
            const tableName = tableNameWithSchema[1];
            const schema = tableNameWithSchema[0];
            const insertQuery = this.insertTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        // create column's comment
        if (column.comment) {
            upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
            downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Creates a new columns from the column in the table.
     */ async addColumns(tableOrName, columns) {
        for (const column of columns){
            await this.addColumn(tableOrName, column);
        }
    }
    /**
     * Renames column in the given table.
     */ async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c)=>c.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
            newColumn = newTableColumnOrName;
        } else {
            newColumn = oldColumn.clone();
            newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
    }
    /**
     * Changes a column in the table.
     */ async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        let defaultValueChanged = false;
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column)=>column.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || !oldColumn.generatedType && newColumn.generatedType === "STORED" || oldColumn.asExpression !== newColumn.asExpression && newColumn.generatedType === "STORED") {
            // To avoid data conversion, we just recreate column
            await this.dropColumn(table, oldColumn);
            await this.addColumn(table, newColumn);
            // update cloned table
            clonedTable = table.clone();
        } else {
            if (oldColumn.name !== newColumn.name) {
                // rename column
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "${newColumn.name}"`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${newColumn.name}" TO "${oldColumn.name}"`));
                // rename ENUM type
                if (oldColumn.type === "enum" || oldColumn.type === "simple-enum") {
                    const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);
                    upQueries.push(new Query_1.Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));
                    downQueries.push(new Query_1.Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO "${oldEnumType.name}"`));
                }
                // rename column primary key constraint
                if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
                    const primaryColumns = clonedTable.primaryColumns;
                    // build old primary constraint name
                    const columnNames = primaryColumns.map((column)=>column.name);
                    const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
                    // replace old column name with new column name
                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
                    columnNames.push(newColumn.name);
                    // build new primary constraint name
                    const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
                }
                // rename column sequence
                if (oldColumn.isGenerated === true && newColumn.generationStrategy === "increment") {
                    const sequencePath = this.buildSequencePath(table, oldColumn.name);
                    const sequenceName = this.buildSequenceName(table, oldColumn.name);
                    const newSequencePath = this.buildSequencePath(table, newColumn.name);
                    const newSequenceName = this.buildSequenceName(table, newColumn.name);
                    const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO "${newSequenceName}"`;
                    const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO "${sequenceName}"`;
                    upQueries.push(new Query_1.Query(up));
                    downQueries.push(new Query_1.Query(down));
                }
                // rename unique constraints
                clonedTable.findColumnUniques(oldColumn).forEach((unique)=>{
                    const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
                    // Skip renaming if Unique has user defined constraint name
                    if (unique.name !== oldUniqueName) return;
                    // build new constraint name
                    unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
                    unique.columnNames.push(newColumn.name);
                    const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
                    // build queries
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
                    // replace constraint name
                    unique.name = newUniqueName;
                });
                // rename index constraints
                clonedTable.findColumnIndices(oldColumn).forEach((index)=>{
                    const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
                    // Skip renaming if Index has user defined constraint name
                    if (index.name !== oldIndexName) return;
                    // build new constraint name
                    index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
                    index.columnNames.push(newColumn.name);
                    const { schema } = this.driver.parseTableName(table);
                    const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
                    // build queries
                    const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
                    const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
                    upQueries.push(new Query_1.Query(up));
                    downQueries.push(new Query_1.Query(down));
                    // replace constraint name
                    index.name = newIndexName;
                });
                // rename foreign key constraints
                clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey)=>{
                    const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
                    // Skip renaming if foreign key has user defined constraint name
                    if (foreignKey.name !== foreignKeyName) return;
                    // build new constraint name
                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
                    foreignKey.columnNames.push(newColumn.name);
                    const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
                    // build queries
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
                    // replace constraint name
                    foreignKey.name = newForeignKeyName;
                });
                // rename old column in the Table object
                const oldTableColumn = clonedTable.columns.find((column)=>column.name === oldColumn.name);
                clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
                oldColumn.name = newColumn.name;
            }
            if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
            }
            if ((newColumn.type === "enum" || newColumn.type === "simple-enum") && (oldColumn.type === "enum" || oldColumn.type === "simple-enum") && (!OrmUtils_1.OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {
                const arraySuffix = newColumn.isArray ? "[]" : "";
                // "public"."new_enum"
                const newEnumName = this.buildEnumName(table, newColumn);
                // "public"."old_enum"
                const oldEnumName = this.buildEnumName(table, oldColumn);
                // "old_enum"
                const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false);
                //"public"."old_enum_old"
                const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true);
                //"old_enum_old"
                const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true);
                // rename old ENUM
                upQueries.push(new Query_1.Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));
                downQueries.push(new Query_1.Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));
                // create new ENUM
                upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));
                downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName));
                // if column have default value, we must drop it to avoid issues with type casting
                if (oldColumn.default !== null && oldColumn.default !== undefined) {
                    // mark default as changed to prevent double update
                    defaultValueChanged = true;
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${oldColumn.default}`));
                }
                // build column types
                const upType = `${newEnumName}${arraySuffix} USING "${newColumn.name}"::"text"::${newEnumName}${arraySuffix}`;
                const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING "${newColumn.name}"::"text"::${oldEnumNameWithSchema_old}${arraySuffix}`;
                // update column to use new type
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${upType}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${downType}`));
                // restore column default or create new one
                if (newColumn.default !== null && newColumn.default !== undefined) {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                }
                // remove old ENUM
                upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
                downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
            }
            if (oldColumn.isNullable !== newColumn.isNullable) {
                if (newColumn.isNullable) {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
                } else {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
                }
            }
            if (oldColumn.comment !== newColumn.comment) {
                upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${oldColumn.name}" IS ${this.escapeComment(newColumn.comment)}`));
                downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${newColumn.name}" IS ${this.escapeComment(oldColumn.comment)}`));
            }
            if (newColumn.isPrimary !== oldColumn.isPrimary) {
                const primaryColumns = clonedTable.primaryColumns;
                // if primary column state changed, we must always drop existed constraint.
                if (primaryColumns.length > 0) {
                    const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                    const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                }
                if (newColumn.isPrimary === true) {
                    primaryColumns.push(newColumn);
                    // update column in table
                    const column = clonedTable.columns.find((column)=>column.name === newColumn.name);
                    column.isPrimary = true;
                    const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                    const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                } else {
                    const primaryColumn = primaryColumns.find((c)=>c.name === newColumn.name);
                    primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
                    // update column in table
                    const column = clonedTable.columns.find((column)=>column.name === newColumn.name);
                    column.isPrimary = false;
                    // if we have another primary keys, we must recreate constraint.
                    if (primaryColumns.length > 0) {
                        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                        const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                    }
                }
            }
            if (newColumn.isUnique !== oldColumn.isUnique) {
                if (newColumn.isUnique === true) {
                    const uniqueConstraint = new TableUnique_1.TableUnique({
                        name: this.connection.namingStrategy.uniqueConstraintName(table, [
                            newColumn.name
                        ]),
                        columnNames: [
                            newColumn.name
                        ]
                    });
                    clonedTable.uniques.push(uniqueConstraint);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
                } else {
                    const uniqueConstraint = clonedTable.uniques.find((unique)=>{
                        return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName)=>columnName === newColumn.name);
                    });
                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
                }
            }
            if (oldColumn.isGenerated !== newColumn.isGenerated) {
                // if old column was "generated", we should clear defaults
                if (oldColumn.isGenerated) {
                    if (oldColumn.generationStrategy === "uuid") {
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
                    } else if (oldColumn.generationStrategy === "increment") {
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
                        upQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
                        downQueries.push(new Query_1.Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
                    }
                }
                if (newColumn.generationStrategy === "uuid") {
                    if (newColumn.isGenerated === true) {
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                    } else {
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
                    }
                } else if (newColumn.generationStrategy === "increment") {
                    if (newColumn.isGenerated === true) {
                        upQueries.push(new Query_1.Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
                        downQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                    } else {
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
                        upQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
                        downQueries.push(new Query_1.Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
                    }
                }
            }
            // the default might have changed when the enum changed
            if (newColumn.default !== oldColumn.default && !defaultValueChanged) {
                if (newColumn.default !== null && newColumn.default !== undefined) {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
                    if (oldColumn.default !== null && oldColumn.default !== undefined) {
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
                    } else {
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                    }
                } else if (oldColumn.default !== null && oldColumn.default !== undefined) {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
                }
            }
            if ((newColumn.spatialFeatureType || "").toLowerCase() !== (oldColumn.spatialFeatureType || "").toLowerCase() || newColumn.srid !== oldColumn.srid) {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
            }
            // update column collation
            if (newColumn.collation !== oldColumn.collation) {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${newColumn.type} COLLATE "${newColumn.collation}"`));
                const oldCollation = oldColumn.collation ? `"${oldColumn.collation}"` : `pg_catalog."default"`; // if there's no old collation, use default
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${newColumn.type} COLLATE ${oldCollation}`));
            }
            if (newColumn.generatedType !== oldColumn.generatedType) {
                // Convert generated column data to normal column
                if (!newColumn.generatedType || newColumn.generatedType === "VIRTUAL") {
                    // We can copy the generated data to the new column
                    const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
                    const tableName = tableNameWithSchema[1];
                    const schema = tableNameWithSchema[0];
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "TEMP_OLD_${oldColumn.name}"`));
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, newColumn)}`));
                    upQueries.push(new Query_1.Query(`UPDATE ${this.escapePath(table)} SET "${newColumn.name}" = "TEMP_OLD_${oldColumn.name}"`));
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "TEMP_OLD_${oldColumn.name}"`));
                    upQueries.push(this.deleteTypeormMetadataSql({
                        database: this.driver.database,
                        schema,
                        table: tableName,
                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                        name: oldColumn.name
                    }));
                    // However, we can't copy it back on downgrade. It needs to regenerate.
                    downQueries.push(this.insertTypeormMetadataSql({
                        database: this.driver.database,
                        schema,
                        table: tableName,
                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                        name: oldColumn.name,
                        value: oldColumn.asExpression
                    }));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, oldColumn)}`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${newColumn.name}"`));
                // downQueries.push(
                //     this.deleteTypeormMetadataSql({
                //         database: this.driver.database,
                //         schema,
                //         table: tableName,
                //         type: MetadataTableType.GENERATED_COLUMN,
                //         name: newColumn.name,
                //     }),
                // )
                }
            }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Changes a column in the table.
     */ async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns){
            await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
    }
    /**
     * Drops column in the table.
     */ async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column) throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        // drop primary key constraint
        if (column.isPrimary) {
            const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column)=>column.name));
            const columnNames = clonedTable.primaryColumns.map((primaryColumn)=>`"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            // update column in table
            const tableColumn = clonedTable.findColumnByName(column.name);
            tableColumn.isPrimary = false;
            // if primary key have multiple columns, we must recreate it without dropped column
            if (clonedTable.primaryColumns.length > 0) {
                const pkName = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column)=>column.name));
                const columnNames = clonedTable.primaryColumns.map((primaryColumn)=>`"${primaryColumn.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
            }
        }
        // drop column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
            upQueries.push(this.dropIndexSql(table, columnIndex));
            downQueries.push(this.createIndexSql(table, columnIndex));
        }
        // drop column check
        const columnCheck = clonedTable.checks.find((check)=>!!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
            clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
            upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
            downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        // drop column unique
        const columnUnique = clonedTable.uniques.find((unique)=>unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
        if (columnUnique) {
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
            downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
        // drop enum type
        if (column.type === "enum" || column.type === "simple-enum") {
            const hasEnum = await this.hasEnumType(table, column);
            if (hasEnum) {
                const enumType = await this.getUserDefinedTypeName(table, column);
                const escapedEnumName = `"${enumType.schema}"."${enumType.name}"`;
                upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));
                downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));
            }
        }
        if (column.generatedType === "STORED") {
            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
            const tableName = tableNameWithSchema[1];
            const schema = tableNameWithSchema[0];
            const deleteQuery = this.deleteTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops the columns in the table.
     */ async dropColumns(tableOrName, columns) {
        for (const column of [
            ...columns
        ]){
            await this.dropColumn(tableOrName, column);
        }
    }
    /**
     * Creates a new primary key.
     */ async createPrimaryKey(tableOrName, columnNames, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.
        clonedTable.columns.forEach((column)=>{
            if (columnNames.find((columnName)=>columnName === column.name)) column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column)=>column.name);
        const upQueries = [];
        const downQueries = [];
        // if table already have primary columns, we must drop them.
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
            const columnNamesString = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        }
        // update columns in table.
        clonedTable.columns.filter((column)=>columnNames.indexOf(column.name) !== -1).forEach((column)=>column.isPrimary = true);
        const pkName = primaryColumns[0]?.primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops a primary key.
     */ async dropPrimaryKey(tableOrName, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column)=>column.name), constraintName);
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column)=>{
            column.isPrimary = false;
        });
    }
    /**
     * Creates new unique constraint.
     */ async createUniqueConstraint(tableOrName, uniqueConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new unique constraint may be passed without name. In this case we generate unique name manually.
        if (!uniqueConstraint.name) uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.addUniqueConstraint(uniqueConstraint);
    }
    /**
     * Creates new unique constraints.
     */ async createUniqueConstraints(tableOrName, uniqueConstraints) {
        for (const uniqueConstraint of uniqueConstraints){
            await this.createUniqueConstraint(tableOrName, uniqueConstraint);
        }
    }
    /**
     * Drops unique constraint.
     */ async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u)=>u.name === uniqueOrName);
        if (!uniqueConstraint) throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.removeUniqueConstraint(uniqueConstraint);
    }
    /**
     * Drops unique constraints.
     */ async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        for (const uniqueConstraint of [
            ...uniqueConstraints
        ]){
            await this.dropUniqueConstraint(tableOrName, uniqueConstraint);
        }
    }
    /**
     * Creates new check constraint.
     */ async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new unique constraint may be passed without name. In this case we generate unique name manually.
        if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
    }
    /**
     * Creates new check constraints.
     */ async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint)=>this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
    }
    /**
     * Drops check constraint.
     */ async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c)=>c.name === checkOrName);
        if (!checkConstraint) throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
    }
    /**
     * Drops check constraints.
     */ async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint)=>this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
    }
    /**
     * Creates new exclusion constraint.
     */ async createExclusionConstraint(tableOrName, exclusionConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new unique constraint may be passed without name. In this case we generate unique name manually.
        if (!exclusionConstraint.name) exclusionConstraint.name = this.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);
        const up = this.createExclusionConstraintSql(table, exclusionConstraint);
        const down = this.dropExclusionConstraintSql(table, exclusionConstraint);
        await this.executeQueries(up, down);
        table.addExclusionConstraint(exclusionConstraint);
    }
    /**
     * Creates new exclusion constraints.
     */ async createExclusionConstraints(tableOrName, exclusionConstraints) {
        const promises = exclusionConstraints.map((exclusionConstraint)=>this.createExclusionConstraint(tableOrName, exclusionConstraint));
        await Promise.all(promises);
    }
    /**
     * Drops exclusion constraint.
     */ async dropExclusionConstraint(tableOrName, exclusionOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const exclusionConstraint = InstanceChecker_1.InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName : table.exclusions.find((c)=>c.name === exclusionOrName);
        if (!exclusionConstraint) throw new error_1.TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);
        const up = this.dropExclusionConstraintSql(table, exclusionConstraint);
        const down = this.createExclusionConstraintSql(table, exclusionConstraint);
        await this.executeQueries(up, down);
        table.removeExclusionConstraint(exclusionConstraint);
    }
    /**
     * Drops exclusion constraints.
     */ async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        const promises = exclusionConstraints.map((exclusionConstraint)=>this.dropExclusionConstraint(tableOrName, exclusionConstraint));
        await Promise.all(promises);
    }
    /**
     * Creates a new foreign key.
     */ async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new FK may be passed without name. In this case we generate FK name manually.
        if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
    }
    /**
     * Creates a new foreign keys.
     */ async createForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of foreignKeys){
            await this.createForeignKey(tableOrName, foreignKey);
        }
    }
    /**
     * Drops a foreign key from the table.
     */ async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk)=>fk.name === foreignKeyOrName);
        if (!foreignKey) throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        if (!foreignKey.name) {
            foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        }
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
    }
    /**
     * Drops a foreign keys from the table.
     */ async dropForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of [
            ...foreignKeys
        ]){
            await this.dropForeignKey(tableOrName, foreignKey);
        }
    }
    /**
     * Creates a new index.
     */ async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index);
    }
    /**
     * Create a new view index.
     */ async createViewIndex(viewOrName, index) {
        const view = InstanceChecker_1.InstanceChecker.isView(viewOrName) ? viewOrName : await this.getCachedView(viewOrName);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(view, index);
        const up = this.createViewIndexSql(view, index);
        const down = this.dropIndexSql(view, index);
        await this.executeQueries(up, down);
        view.addIndex(index);
    }
    /**
     * Creates a new indices
     */ async createIndices(tableOrName, indices) {
        for (const index of indices){
            await this.createIndex(tableOrName, index);
        }
    }
    /**
     * Creates new view indices
     */ async createViewIndices(viewOrName, indices) {
        for (const index of indices){
            await this.createViewIndex(viewOrName, index);
        }
    }
    /**
     * Drops an index from the table.
     */ async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i)=>i.name === indexOrName);
        if (!index) throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        // old index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
    }
    /**
     * Drops an index from a view.
     */ async dropViewIndex(viewOrName, indexOrName) {
        const view = InstanceChecker_1.InstanceChecker.isView(viewOrName) ? viewOrName : await this.getCachedView(viewOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : view.indices.find((i)=>i.name === indexOrName);
        if (!index) throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in view ${view.name}`);
        // old index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(view, index);
        const up = this.dropIndexSql(view, index);
        const down = this.createViewIndexSql(view, index);
        await this.executeQueries(up, down);
        view.removeIndex(index);
    }
    /**
     * Drops an indices from the table.
     */ async dropIndices(tableOrName, indices) {
        for (const index of [
            ...indices
        ]){
            await this.dropIndex(tableOrName, index);
        }
    }
    /**
     * Clears all table contents.
     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
     */ async clearTable(tableName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);
    }
    /**
     * Removes all tables from the currently connected database.
     */ async clearDatabase() {
        const schemas = [];
        this.connection.entityMetadatas.filter((metadata)=>metadata.schema).forEach((metadata)=>{
            const isSchemaExist = !!schemas.find((schema)=>schema === metadata.schema);
            if (!isSchemaExist) schemas.push(metadata.schema);
        });
        schemas.push(this.driver.options.schema || "current_schema()");
        const schemaNamesString = schemas.map((name)=>{
            return name === "current_schema()" ? name : "'" + name + "'";
        }).join(", ");
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive) await this.startTransaction();
        try {
            // drop views
            const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS "' || schemaname || '"."' || viewname || '" CASCADE;' as "query" ` + `FROM "pg_views" WHERE "schemaname" IN (${schemaNamesString}) AND "viewname" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;
            const dropViewQueries = await this.query(selectViewDropsQuery);
            await Promise.all(dropViewQueries.map((q)=>this.query(q["query"])));
            // drop materialized views
            // Note: materialized views introduced in Postgres 9.3
            if (DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(this.driver, "9.3")) {
                const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS "' || schemaname || '"."' || matviewname || '" CASCADE;' as "query" ` + `FROM "pg_matviews" WHERE "schemaname" IN (${schemaNamesString})`;
                const dropMatViewQueries = await this.query(selectMatViewDropsQuery);
                await Promise.all(dropMatViewQueries.map((q)=>this.query(q["query"])));
            }
            // ignore spatial_ref_sys; it's a special table supporting PostGIS
            // TODO generalize this as this.driver.ignoreTables
            // drop tables
            const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS "' || schemaname || '"."' || tablename || '" CASCADE;' as "query" FROM "pg_tables" WHERE "schemaname" IN (${schemaNamesString}) AND "tablename" NOT IN ('spatial_ref_sys')`;
            const dropTableQueries = await this.query(selectTableDropsQuery);
            await Promise.all(dropTableQueries.map((q)=>this.query(q["query"])));
            // drop enum types
            await this.dropEnumTypes(schemaNamesString);
            if (!isAnotherTransactionActive) {
                await this.commitTransaction();
            }
        } catch (error) {
            try {
                // we throw original error even if rollback thrown an error
                if (!isAnotherTransactionActive) {
                    await this.rollbackTransaction();
                }
            } catch  {
            // no-op
            }
            throw error;
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) return [];
        if (!viewNames) {
            viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const currentSchema = await this.getCurrentSchema();
        const viewsCondition = viewNames.length === 0 ? "1=1" : viewNames.map((tableName)=>this.driver.parseTableName(tableName)).map(({ schema, tableName })=>{
            if (!schema) {
                schema = this.driver.options.schema || currentSchema;
            }
            return `("t"."schema" = '${schema}' AND "t"."name" = '${tableName}')`;
        }).join(" OR ");
        const constraintsCondition = viewNames.length === 0 ? "1=1" : viewNames.map((tableName)=>this.driver.parseTableName(tableName)).map(({ schema, tableName })=>{
            if (!schema) {
                schema = this.driver.options.schema || currentSchema;
            }
            return `("ns"."nspname" = '${schema}' AND "t"."relname" = '${tableName}')`;
        }).join(" OR ");
        const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", ` + `CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", ` + `"types"."typname" AS "type_name" ` + `FROM "pg_class" "t" ` + `INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" ` + `INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") ` + `INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" ` + `INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" ` + `INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" ` + `LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" ` + `WHERE "t"."relkind" IN ('m') AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
        const query = `SELECT "t".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" ` + `INNER JOIN "pg_catalog"."pg_class" "c" ON "c"."relname" = "t"."name" ` + `INNER JOIN "pg_namespace" "n" ON "n"."oid" = "c"."relnamespace" AND "n"."nspname" = "t"."schema" ` + `WHERE "t"."type" IN ('${MetadataTableType_1.MetadataTableType.VIEW}', '${MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        const dbIndices = await this.query(indicesSql);
        return dbViews.map((dbView)=>{
            // find index constraints of table, group them by constraint name and build TableIndex.
            const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex)=>{
                return dbIndex["table_name"] === dbView["name"] && dbIndex["table_schema"] === dbView["schema"];
            }), (dbIndex)=>dbIndex["constraint_name"]);
            const view = new View_1.View();
            const schema = dbView["schema"] === currentSchema && !this.driver.options.schema ? undefined : dbView["schema"];
            view.database = currentDatabase;
            view.schema = dbView["schema"];
            view.name = this.driver.buildTableName(dbView["name"], schema);
            view.expression = dbView["value"];
            view.materialized = dbView["type"] === MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW;
            view.indices = tableIndexConstraints.map((constraint)=>{
                const indices = dbIndices.filter((index)=>{
                    return index["table_schema"] === constraint["table_schema"] && index["table_name"] === constraint["table_name"] && index["constraint_name"] === constraint["constraint_name"];
                });
                return new TableIndex_1.TableIndex({
                    view: view,
                    name: constraint["constraint_name"],
                    columnNames: indices.map((i)=>i["column_name"]),
                    isUnique: constraint["is_unique"] === "TRUE",
                    where: constraint["condition"],
                    isFulltext: false
                });
            });
            return view;
        });
    }
    /**
     * Loads all tables (with given names) from the database and creates a Table from them.
     */ async loadTables(tableNames) {
        // if no tables given then no need to proceed
        if (tableNames && tableNames.length === 0) {
            return [];
        }
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        const dbTables = [];
        if (!tableNames) {
            const tablesSql = `SELECT "table_schema", "table_name", obj_description(('"' || "table_schema" || '"."' || "table_name" || '"')::regclass, 'pg_class') AS table_comment FROM "information_schema"."tables"`;
            dbTables.push(...await this.query(tablesSql));
        } else {
            const tablesCondition = tableNames.map((tableName)=>this.driver.parseTableName(tableName)).map(({ schema, tableName })=>{
                return `("table_schema" = '${schema || currentSchema}' AND "table_name" = '${tableName}')`;
            }).join(" OR ");
            const tablesSql = `SELECT "table_schema", "table_name", obj_description(('"' || "table_schema" || '"."' || "table_name" || '"')::regclass, 'pg_class') AS table_comment FROM "information_schema"."tables" WHERE ` + tablesCondition;
            dbTables.push(...await this.query(tablesSql));
        }
        // if tables were not found in the db, no need to proceed
        if (dbTables.length === 0) {
            return [];
        }
        /**
         * Uses standard SQL information_schema.columns table and postgres-specific
         * pg_catalog.pg_attribute table to get column information.
         * @see https://stackoverflow.com/a/19541865
         */ const columnsCondition = dbTables.map(({ table_schema, table_name })=>{
            return `("table_schema" = '${table_schema}' AND "table_name" = '${table_name}')`;
        }).join(" OR ");
        const columnsSql = `SELECT columns.*, pg_catalog.col_description(('"' || table_catalog || '"."' || table_schema || '"."' || table_name || '"')::regclass::oid, ordinal_position) AS description, ` + `('"' || "udt_schema" || '"."' || "udt_name" || '"')::"regtype"::text AS "regtype", pg_catalog.format_type("col_attr"."atttypid", "col_attr"."atttypmod") AS "format_type" ` + `FROM "information_schema"."columns" ` + `LEFT JOIN "pg_catalog"."pg_attribute" AS "col_attr" ON "col_attr"."attname" = "columns"."column_name" ` + `AND "col_attr"."attrelid" = ( ` + `SELECT "cls"."oid" FROM "pg_catalog"."pg_class" AS "cls" ` + `LEFT JOIN "pg_catalog"."pg_namespace" AS "ns" ON "ns"."oid" = "cls"."relnamespace" ` + `WHERE "cls"."relname" = "columns"."table_name" ` + `AND "ns"."nspname" = "columns"."table_schema" ` + `) ` + `WHERE ` + columnsCondition;
        const constraintsCondition = dbTables.map(({ table_schema, table_name })=>{
            return `("ns"."nspname" = '${table_schema}' AND "t"."relname" = '${table_name}')`;
        }).join(" OR ");
        const constraintsSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "cnst"."conname" AS "constraint_name", ` + `pg_get_constraintdef("cnst"."oid") AS "expression", ` + `CASE "cnst"."contype" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS "constraint_type", "a"."attname" AS "column_name" ` + `FROM "pg_constraint" "cnst" ` + `INNER JOIN "pg_class" "t" ON "t"."oid" = "cnst"."conrelid" ` + `INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "cnst"."connamespace" ` + `LEFT JOIN "pg_attribute" "a" ON "a"."attrelid" = "cnst"."conrelid" AND "a"."attnum" = ANY ("cnst"."conkey") ` + `WHERE "t"."relkind" IN ('r', 'p') AND (${constraintsCondition})`;
        const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", ` + `CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", ` + `"types"."typname" AS "type_name", "am"."amname" AS "index_type" ` + `FROM "pg_class" "t" ` + `INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" ` + `INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") ` + `INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" ` + `INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" ` + `INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" ` + `INNER JOIN "pg_am" "am" ON "i"."relam" = "am"."oid" ` + `LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" ` + `WHERE "t"."relkind" IN ('r', 'p') AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
        const foreignKeysCondition = dbTables.map(({ table_schema, table_name })=>{
            return `("ns"."nspname" = '${table_schema}' AND "cl"."relname" = '${table_name}')`;
        }).join(" OR ");
        const hasRelispartitionColumn = await this.hasSupportForPartitionedTables();
        const isPartitionCondition = hasRelispartitionColumn ? ` AND "cl"."relispartition" = 'f'` : "";
        const foreignKeysSql = `SELECT "con"."conname" AS "constraint_name", "con"."nspname" AS "table_schema", "con"."relname" AS "table_name", "att2"."attname" AS "column_name", ` + `"ns"."nspname" AS "referenced_table_schema", "cl"."relname" AS "referenced_table_name", "att"."attname" AS "referenced_column_name", "con"."confdeltype" AS "on_delete", ` + `"con"."confupdtype" AS "on_update", "con"."condeferrable" AS "deferrable", "con"."condeferred" AS "deferred" ` + `FROM ( ` + `SELECT UNNEST ("con1"."conkey") AS "parent", UNNEST ("con1"."confkey") AS "child", "con1"."confrelid", "con1"."conrelid", "con1"."conname", "con1"."contype", "ns"."nspname", ` + `"cl"."relname", "con1"."condeferrable", ` + `CASE WHEN "con1"."condeferred" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` + `CASE "con1"."confdeltype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confdeltype", ` + `CASE "con1"."confupdtype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confupdtype" ` + `FROM "pg_class" "cl" ` + `INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" ` + `INNER JOIN "pg_constraint" "con1" ON "con1"."conrelid" = "cl"."oid" ` + `WHERE "con1"."contype" = 'f' AND (${foreignKeysCondition}) ` + `) "con" ` + `INNER JOIN "pg_attribute" "att" ON "att"."attrelid" = "con"."confrelid" AND "att"."attnum" = "con"."child" ` + `INNER JOIN "pg_class" "cl" ON "cl"."oid" = "con"."confrelid" ${isPartitionCondition}` + `INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" ` + `INNER JOIN "pg_attribute" "att2" ON "att2"."attrelid" = "con"."conrelid" AND "att2"."attnum" = "con"."parent"`;
        const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = await Promise.all([
            this.query(columnsSql),
            this.query(constraintsSql),
            this.query(indicesSql),
            this.query(foreignKeysSql)
        ]);
        // create tables for loaded tables
        return Promise.all(dbTables.map(async (dbTable)=>{
            const table = new Table_1.Table();
            const getSchemaFromKey = (dbObject, key)=>{
                return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? undefined : dbObject[key];
            };
            // We do not need to join schema name, when database is by default.
            const schema = getSchemaFromKey(dbTable, "table_schema");
            table.database = currentDatabase;
            table.schema = dbTable["table_schema"];
            table.comment = dbTable["table_comment"];
            table.name = this.driver.buildTableName(dbTable["table_name"], schema);
            // create columns from the loaded columns
            table.columns = await Promise.all(dbColumns.filter((dbColumn)=>dbColumn["table_name"] === dbTable["table_name"] && dbColumn["table_schema"] === dbTable["table_schema"]).map(async (dbColumn)=>{
                const columnConstraints = dbConstraints.filter((dbConstraint)=>{
                    return dbConstraint["table_name"] === dbColumn["table_name"] && dbConstraint["table_schema"] === dbColumn["table_schema"] && dbConstraint["column_name"] === dbColumn["column_name"];
                });
                const tableColumn = new TableColumn_1.TableColumn();
                tableColumn.name = dbColumn["column_name"];
                tableColumn.type = dbColumn["regtype"].toLowerCase();
                if (tableColumn.type === "vector" || tableColumn.type === "halfvec") {
                    const lengthMatch = dbColumn["format_type"].match(/^(?:vector|halfvec)\((\d+)\)$/);
                    if (lengthMatch && lengthMatch[1]) {
                        tableColumn.length = lengthMatch[1];
                    }
                }
                if (tableColumn.type === "numeric" || tableColumn.type === "numeric[]" || tableColumn.type === "decimal" || tableColumn.type === "float") {
                    let numericPrecision = dbColumn["numeric_precision"];
                    let numericScale = dbColumn["numeric_scale"];
                    if (dbColumn["data_type"] === "ARRAY") {
                        const numericSize = dbColumn["format_type"].match(/^numeric\(([0-9]+),([0-9]+)\)\[\]$/);
                        if (numericSize) {
                            numericPrecision = +numericSize[1];
                            numericScale = +numericSize[2];
                        }
                    }
                    // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property
                    // we set 'undefined' in to unspecified property to avoid changing column on sync
                    if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {
                        tableColumn.precision = numericPrecision;
                    } else if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {
                        tableColumn.precision = undefined;
                    }
                    if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {
                        tableColumn.scale = numericScale;
                    } else if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {
                        tableColumn.scale = undefined;
                    }
                }
                if (tableColumn.type === "interval" || tableColumn.type === "time without time zone" || tableColumn.type === "time with time zone" || tableColumn.type === "timestamp without time zone" || tableColumn.type === "timestamp with time zone") {
                    tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["datetime_precision"]) ? dbColumn["datetime_precision"] : undefined;
                }
                // check if column has user-defined data type.
                // NOTE: if ENUM type defined with "array:true" it comes with ARRAY type instead of USER-DEFINED
                if (dbColumn["data_type"] === "USER-DEFINED" || dbColumn["data_type"] === "ARRAY") {
                    const { name } = await this.getUserDefinedTypeName(table, tableColumn);
                    // check if `enumName` is specified by user
                    const builtEnumName = this.buildEnumName(table, tableColumn, false, true);
                    const enumName = builtEnumName !== name ? name : undefined;
                    // check if type is ENUM
                    const sql = `SELECT "e"."enumlabel" AS "value" FROM "pg_enum" "e" ` + `INNER JOIN "pg_type" "t" ON "t"."oid" = "e"."enumtypid" ` + `INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" ` + `WHERE "n"."nspname" = '${dbTable["table_schema"]}' AND "t"."typname" = '${enumName || name}'`;
                    const results = await this.query(sql);
                    if (results.length) {
                        tableColumn.type = "enum";
                        tableColumn.enum = results.map((result)=>result["value"]);
                        tableColumn.enumName = enumName;
                    }
                    if (dbColumn["data_type"] === "ARRAY") {
                        tableColumn.isArray = true;
                        const type = tableColumn.type.replace("[]", "");
                        tableColumn.type = this.connection.driver.normalizeType({
                            type: type
                        });
                    }
                }
                if (tableColumn.type === "geometry" || tableColumn.type === "geography") {
                    const sql = `SELECT * FROM (` + `SELECT "f_table_schema" "table_schema", "f_table_name" "table_name", ` + `"f_${tableColumn.type}_column" "column_name", "srid", "type" ` + `FROM "${tableColumn.type}_columns"` + `) AS _ ` + `WHERE "column_name" = '${dbColumn["column_name"]}' AND ` + `"table_schema" = '${dbColumn["table_schema"]}' AND ` + `"table_name" = '${dbColumn["table_name"]}'`;
                    const results = await this.query(sql);
                    if (results.length > 0) {
                        tableColumn.spatialFeatureType = results[0].type;
                        tableColumn.srid = results[0].srid;
                    }
                }
                // check only columns that have length property
                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
                    let length;
                    if (tableColumn.isArray) {
                        const match = /\((\d+)\)/.exec(dbColumn["format_type"]);
                        length = match ? match[1] : undefined;
                    } else if (dbColumn["character_maximum_length"]) {
                        length = dbColumn["character_maximum_length"].toString();
                    }
                    if (length) {
                        tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
                    }
                }
                tableColumn.isNullable = dbColumn["is_nullable"] === "YES";
                const primaryConstraint = columnConstraints.find((constraint)=>constraint["constraint_type"] === "PRIMARY");
                if (primaryConstraint) {
                    tableColumn.isPrimary = true;
                    // find another columns involved in primary key constraint
                    const anotherPrimaryConstraints = dbConstraints.filter((constraint)=>constraint["table_name"] === dbColumn["table_name"] && constraint["table_schema"] === dbColumn["table_schema"] && constraint["column_name"] !== dbColumn["column_name"] && constraint["constraint_type"] === "PRIMARY");
                    // collect all column names
                    const columnNames = anotherPrimaryConstraints.map((constraint)=>constraint["column_name"]);
                    columnNames.push(dbColumn["column_name"]);
                    // build default primary key constraint name
                    const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
                    // if primary key has user-defined constraint name, write it in table column
                    if (primaryConstraint["constraint_name"] !== pkName) {
                        tableColumn.primaryKeyConstraintName = primaryConstraint["constraint_name"];
                    }
                }
                const uniqueConstraints = columnConstraints.filter((constraint)=>constraint["constraint_type"] === "UNIQUE");
                const isConstraintComposite = uniqueConstraints.every((uniqueConstraint)=>{
                    return dbConstraints.some((dbConstraint)=>dbConstraint["constraint_type"] === "UNIQUE" && dbConstraint["constraint_name"] === uniqueConstraint["constraint_name"] && dbConstraint["column_name"] !== dbColumn["column_name"]);
                });
                tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
                if (dbColumn.is_identity === "YES") {
                    // Postgres 10+ Identity column
                    tableColumn.isGenerated = true;
                    tableColumn.generationStrategy = "identity";
                    tableColumn.generatedIdentity = dbColumn.identity_generation;
                } else if (dbColumn["column_default"] !== null && dbColumn["column_default"] !== undefined) {
                    const serialDefaultName = `nextval('${this.buildSequenceName(table, dbColumn["column_name"])}'::regclass)`;
                    const serialDefaultPath = `nextval('${this.buildSequencePath(table, dbColumn["column_name"])}'::regclass)`;
                    const defaultWithoutQuotes = dbColumn["column_default"].replace(/"/g, "");
                    if (defaultWithoutQuotes === serialDefaultName || defaultWithoutQuotes === serialDefaultPath) {
                        tableColumn.isGenerated = true;
                        tableColumn.generationStrategy = "increment";
                    } else if (dbColumn["column_default"] === "gen_random_uuid()" || /^uuid_generate_v\d\(\)/.test(dbColumn["column_default"])) {
                        if (tableColumn.type === "uuid") {
                            tableColumn.isGenerated = true;
                            tableColumn.generationStrategy = "uuid";
                        } else {
                            tableColumn.default = dbColumn["column_default"];
                        }
                    } else if (dbColumn["column_default"] === "now()" || dbColumn["column_default"].indexOf("'now'::text") !== -1) {
                        tableColumn.default = dbColumn["column_default"];
                    } else {
                        tableColumn.default = dbColumn["column_default"].replace(/::[\w\s.[\]\-"]+/g, "");
                        tableColumn.default = tableColumn.default.replace(/^(-?\d+)$/, "'$1'");
                    }
                }
                if (dbColumn["is_generated"] === "ALWAYS" && dbColumn["generation_expression"]) {
                    // In postgres there is no VIRTUAL generated column type
                    tableColumn.generatedType = "STORED";
                    // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.
                    const asExpressionQuery = this.selectTypeormMetadataSql({
                        database: currentDatabase,
                        schema: dbTable["table_schema"],
                        table: dbTable["table_name"],
                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                        name: tableColumn.name
                    });
                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
                    if (results[0] && results[0].value) {
                        tableColumn.asExpression = results[0].value;
                    } else {
                        tableColumn.asExpression = "";
                    }
                }
                tableColumn.comment = dbColumn["description"] ? dbColumn["description"] : undefined;
                if (dbColumn["character_set_name"]) tableColumn.charset = dbColumn["character_set_name"];
                if (dbColumn["collation_name"]) tableColumn.collation = dbColumn["collation_name"];
                return tableColumn;
            }));
            // find unique constraints of table, group them by constraint name and build TableUnique.
            const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint)=>{
                return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "UNIQUE";
            }), (dbConstraint)=>dbConstraint["constraint_name"]);
            table.uniques = tableUniqueConstraints.map((constraint)=>{
                const uniques = dbConstraints.filter((dbC)=>dbC["constraint_name"] === constraint["constraint_name"]);
                return new TableUnique_1.TableUnique({
                    name: constraint["constraint_name"],
                    columnNames: uniques.map((u)=>u["column_name"]),
                    deferrable: constraint["deferrable"] ? constraint["deferred"] : undefined
                });
            });
            // find check constraints of table, group them by constraint name and build TableCheck.
            const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint)=>{
                return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "CHECK";
            }), (dbConstraint)=>dbConstraint["constraint_name"]);
            table.checks = tableCheckConstraints.map((constraint)=>{
                const checks = dbConstraints.filter((dbC)=>dbC["constraint_name"] === constraint["constraint_name"]);
                return new TableCheck_1.TableCheck({
                    name: constraint["constraint_name"],
                    columnNames: checks.map((c)=>c["column_name"]),
                    expression: constraint["expression"].replace(/^\s*CHECK\s*\((.*)\)\s*$/i, "$1")
                });
            });
            // find exclusion constraints of table, group them by constraint name and build TableExclusion.
            const tableExclusionConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint)=>{
                return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "EXCLUDE";
            }), (dbConstraint)=>dbConstraint["constraint_name"]);
            table.exclusions = tableExclusionConstraints.map((constraint)=>{
                return new TableExclusion_1.TableExclusion({
                    name: constraint["constraint_name"],
                    expression: constraint["expression"].substring(8)
                });
            });
            // find foreign key constraints of table, group them by constraint name and build TableForeignKey.
            const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey)=>{
                return dbForeignKey["table_name"] === dbTable["table_name"] && dbForeignKey["table_schema"] === dbTable["table_schema"];
            }), (dbForeignKey)=>dbForeignKey["constraint_name"]);
            table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey)=>{
                const foreignKeys = dbForeignKeys.filter((dbFk)=>dbFk["constraint_name"] === dbForeignKey["constraint_name"]);
                // if referenced table located in currently used schema, we don't need to concat schema name to table name.
                const schema = getSchemaFromKey(dbForeignKey, "referenced_table_schema");
                const referencedTableName = this.driver.buildTableName(dbForeignKey["referenced_table_name"], schema);
                return new TableForeignKey_1.TableForeignKey({
                    name: dbForeignKey["constraint_name"],
                    columnNames: foreignKeys.map((dbFk)=>dbFk["column_name"]),
                    referencedSchema: dbForeignKey["referenced_table_schema"],
                    referencedTableName: referencedTableName,
                    referencedColumnNames: foreignKeys.map((dbFk)=>dbFk["referenced_column_name"]),
                    onDelete: dbForeignKey["on_delete"],
                    onUpdate: dbForeignKey["on_update"],
                    deferrable: dbForeignKey["deferrable"] ? dbForeignKey["deferred"] : undefined
                });
            });
            // find index constraints of table, group them by constraint name and build TableIndex.
            const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex)=>{
                return dbIndex["table_name"] === dbTable["table_name"] && dbIndex["table_schema"] === dbTable["table_schema"];
            }), (dbIndex)=>dbIndex["constraint_name"]);
            table.indices = tableIndexConstraints.map((constraint)=>{
                const indices = dbIndices.filter((index)=>{
                    return index["table_schema"] === constraint["table_schema"] && index["table_name"] === constraint["table_name"] && index["constraint_name"] === constraint["constraint_name"];
                });
                return new TableIndex_1.TableIndex({
                    table: table,
                    name: constraint["constraint_name"],
                    columnNames: indices.map((i)=>i["column_name"]),
                    isUnique: constraint["is_unique"] === "TRUE",
                    where: constraint["condition"],
                    isSpatial: constraint["index_type"] === "gist",
                    isFulltext: false
                });
            });
            return table;
        }));
    }
    /**
     * Builds create table sql.
     */ createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column)=>this.buildCreateColumnSql(table, column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column)=>column.isUnique).forEach((column)=>{
            const isUniqueExist = table.uniques.some((unique)=>unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
            if (!isUniqueExist) table.uniques.push(new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ]
            }));
        });
        if (table.uniques.length > 0) {
            const uniquesSql = table.uniques.map((unique)=>{
                const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
                const columnNames = unique.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
                let constraint = `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
                if (unique.deferrable) constraint += ` DEFERRABLE ${unique.deferrable}`;
                return constraint;
            }).join(", ");
            sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
            const checksSql = table.checks.map((check)=>{
                const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
                return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
            }).join(", ");
            sql += `, ${checksSql}`;
        }
        if (table.exclusions.length > 0) {
            const exclusionsSql = table.exclusions.map((exclusion)=>{
                const exclusionName = exclusion.name ? exclusion.name : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);
                return `CONSTRAINT "${exclusionName}" EXCLUDE ${exclusion.expression}`;
            }).join(", ");
            sql += `, ${exclusionsSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
            const foreignKeysSql = table.foreignKeys.map((fk)=>{
                const columnNames = fk.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
                if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
                const referencedColumnNames = fk.referencedColumnNames.map((columnName)=>`"${columnName}"`).join(", ");
                let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
                if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;
                if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;
                if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;
                return constraint;
            }).join(", ");
            sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column)=>column.isPrimary);
        if (primaryColumns.length > 0) {
            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column)=>column.name));
            const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        table.columns.filter((it)=>it.comment).forEach((it)=>sql += `; COMMENT ON COLUMN ${this.escapePath(table)}."${it.name}" IS ${this.escapeComment(it.comment)}`);
        return new Query_1.Query(sql);
    }
    /**
     * Loads Postgres version.
     */ async getVersion() {
        // we use `SELECT version()` instead of `SHOW server_version` or `SHOW server_version_num`
        // to maintain compatability with Amazon Redshift.
        //
        // see:
        //  - https://github.com/typeorm/typeorm/pull/9319
        //  - https://docs.aws.amazon.com/redshift/latest/dg/c_unsupported-postgresql-functions.html
        const result = await this.query(`SELECT version()`);
        // Examples:
        // Postgres: "PostgreSQL 14.10 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-20), 64-bit"
        // Yugabyte: "PostgreSQL 11.2-YB-2.18.1.0-b0 on x86_64-pc-linux-gnu, compiled by clang version 15.0.3 (https://github.com/yugabyte/llvm-project.git 0b8d1183745fd3998d8beffeec8cbe99c1b20529), 64-bit"
        return result[0].version.replace(/^PostgreSQL ([\d.]+).*$/, "$1");
    }
    /**
     * Builds drop table sql.
     */ dropTableSql(tableOrPath) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
    }
    createViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        const viewName = this.escapePath(view);
        if (typeof view.expression === "string") {
            return new Query_1.Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);
        } else {
            return new Query_1.Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression(this.connection).getQuery()}`);
        }
    }
    async insertViewDefinitionSql(view) {
        const currentSchema = await this.getCurrentSchema();
        let { schema, tableName: name } = this.driver.parseTableName(view);
        if (!schema) {
            schema = currentSchema;
        }
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
            type,
            schema,
            name,
            value: expression
        });
    }
    /**
     * Builds drop view sql.
     */ dropViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        return new Query_1.Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
    }
    /**
     * Builds remove view sql.
     */ async deleteViewDefinitionSql(view) {
        const currentSchema = await this.getCurrentSchema();
        let { schema, tableName: name } = this.driver.parseTableName(view);
        if (!schema) {
            schema = currentSchema;
        }
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        return this.deleteTypeormMetadataSql({
            type,
            schema,
            name
        });
    }
    /**
     * Drops ENUM type from given schemas.
     */ async dropEnumTypes(schemaNames) {
        const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS "' || n.nspname || '"."' || t.typname || '" CASCADE;' as "query" FROM "pg_type" "t" ` + `INNER JOIN "pg_enum" "e" ON "e"."enumtypid" = "t"."oid" ` + `INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" ` + `WHERE "n"."nspname" IN (${schemaNames}) GROUP BY "n"."nspname", "t"."typname"`;
        const dropQueries = await this.query(selectDropsQuery);
        await Promise.all(dropQueries.map((q)=>this.query(q["query"])));
    }
    /**
     * Checks if enum with the given name exist in the database.
     */ async hasEnumType(table, column) {
        let { schema } = this.driver.parseTableName(table);
        if (!schema) {
            schema = await this.getCurrentSchema();
        }
        const enumName = this.buildEnumName(table, column, false, true);
        const sql = `SELECT "n"."nspname", "t"."typname" FROM "pg_type" "t" ` + `INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" ` + `WHERE "n"."nspname" = '${schema}' AND "t"."typname" = '${enumName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Builds create ENUM type sql.
     */ createEnumTypeSql(table, column, enumName) {
        if (!enumName) enumName = this.buildEnumName(table, column);
        const enumValues = column.enum.map((value)=>`'${value.replaceAll("'", "''")}'`).join(", ");
        return new Query_1.Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);
    }
    /**
     * Builds create ENUM type sql.
     */ dropEnumTypeSql(table, column, enumName) {
        if (!enumName) enumName = this.buildEnumName(table, column);
        return new Query_1.Query(`DROP TYPE ${enumName}`);
    }
    /**
     * Builds create index sql.
     */ createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX${index.isConcurrent ? " CONCURRENTLY" : ""} "${index.name}" ON ${this.escapePath(table)} ${index.isSpatial ? "USING GiST " : ""}(${columns}) ${index.where ? "WHERE " + index.where : ""}`);
    }
    /**
     * Builds create view index sql.
     */ createViewIndexSql(view, index) {
        const columns = index.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(view)} (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
    }
    /**
     * Builds drop index sql.
     */ dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        const concurrent = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.isConcurrent : false;
        const { schema } = this.driver.parseTableName(table);
        return schema ? new Query_1.Query(`DROP INDEX ${concurrent ? "CONCURRENTLY " : ""}"${schema}"."${indexName}"`) : new Query_1.Query(`DROP INDEX ${concurrent ? "CONCURRENTLY " : ""}"${indexName}"`);
    }
    /**
     * Builds create primary key sql.
     */ createPrimaryKeySql(table, columnNames, constraintName) {
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
    }
    /**
     * Builds drop primary key sql.
     */ dropPrimaryKeySql(table) {
        if (!table.primaryColumns.length) throw new error_1.TypeORMError(`Table ${table} has no primary keys.`);
        const columnNames = table.primaryColumns.map((column)=>column.name);
        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
    }
    /**
     * Builds create unique constraint sql.
     */ createUniqueConstraintSql(table, uniqueConstraint) {
        const columnNames = uniqueConstraint.columnNames.map((column)=>`"` + column + `"`).join(", ");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`;
        if (uniqueConstraint.deferrable) sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop unique constraint sql.
     */ dropUniqueConstraintSql(table, uniqueOrName) {
        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
    }
    /**
     * Builds create check constraint sql.
     */ createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
    }
    /**
     * Builds drop check constraint sql.
     */ dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
    }
    /**
     * Builds create exclusion constraint sql.
     */ createExclusionConstraintSql(table, exclusionConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${exclusionConstraint.name}" EXCLUDE ${exclusionConstraint.expression}`);
    }
    /**
     * Builds drop exclusion constraint sql.
     */ dropExclusionConstraintSql(table, exclusionOrName) {
        const exclusionName = InstanceChecker_1.InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName.name : exclusionOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${exclusionName}"`);
    }
    /**
     * Builds create foreign key sql.
     */ createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column)=>`"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column)=>`"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`;
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop foreign key sql.
     */ dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
    }
    /**
     * Builds sequence name from given table and column.
     */ buildSequenceName(table, columnOrName) {
        const { tableName } = this.driver.parseTableName(table);
        const columnName = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;
        let seqName = `${tableName}_${columnName}_seq`;
        if (seqName.length > this.connection.driver.maxAliasLength) {
            // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes
            seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;
        }
        return seqName;
    }
    buildSequencePath(table, columnOrName) {
        const { schema } = this.driver.parseTableName(table);
        return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);
    }
    /**
     * Builds ENUM type name from given table and column.
     */ buildEnumName(table, column, withSchema = true, disableEscape, toOld) {
        const { schema, tableName } = this.driver.parseTableName(table);
        let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;
        if (schema && withSchema) enumName = `${schema}.${enumName}`;
        if (toOld) enumName = enumName + "_old";
        return enumName.split(".").map((i)=>{
            return disableEscape ? i : `"${i}"`;
        }).join(".");
    }
    async getUserDefinedTypeName(table, column) {
        let { schema, tableName: name } = this.driver.parseTableName(table);
        if (!schema) {
            schema = await this.getCurrentSchema();
        }
        const result = await this.query(`SELECT "udt_schema", "udt_name" ` + `FROM "information_schema"."columns" WHERE "table_schema" = '${schema}' AND "table_name" = '${name}' AND "column_name"='${column.name}'`);
        // docs: https://www.postgresql.org/docs/current/xtypes.html
        // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.
        // The array type typically has the same name as the base type with the underscore character (_) prepended.
        // ----
        // so, we must remove this underscore character from enum type name
        let udtName = result[0]["udt_name"];
        if (udtName.indexOf("_") === 0) {
            udtName = udtName.substr(1, udtName.length);
        }
        return {
            schema: result[0]["udt_schema"],
            name: udtName
        };
    }
    /**
     * Escapes a given comment so it's safe to include in a query.
     */ escapeComment(comment) {
        if (!comment || comment.length === 0) {
            return "NULL";
        }
        comment = comment.replace(/'/g, "''").replace(/\u0000/g, ""); // Null bytes aren't allowed in comments
        return `'${comment}'`;
    }
    /**
     * Escapes given table or view path.
     */ escapePath(target) {
        const { schema, tableName } = this.driver.parseTableName(target);
        if (schema && schema !== this.driver.searchSchema) {
            return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
    }
    /**
     * Get the table name with table schema
     * Note: Without ' or "
     */ async getTableNameWithSchema(target) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(target) ? target.name : target;
        if (tableName.indexOf(".") === -1) {
            const schemaResult = await this.query(`SELECT current_schema()`);
            const schema = schemaResult[0]["current_schema"];
            return `${schema}.${tableName}`;
        } else {
            return `${tableName.split(".")[0]}.${tableName.split(".")[1]}`;
        }
    }
    /**
     * Builds a query for create column.
     */ buildCreateColumnSql(table, column) {
        let c = '"' + column.name + '"';
        if (column.isGenerated === true && column.generationStrategy !== "uuid") {
            if (column.generationStrategy === "identity") {
                // Postgres 10+ Identity generated column
                const generatedIdentityOrDefault = column.generatedIdentity || "BY DEFAULT";
                c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;
            } else {
                // classic SERIAL primary column
                if (column.type === "integer" || column.type === "int" || column.type === "int4") c += " SERIAL";
                if (column.type === "smallint" || column.type === "int2") c += " SMALLSERIAL";
                if (column.type === "bigint" || column.type === "int8") c += " BIGSERIAL";
            }
        }
        if (column.type === "enum" || column.type === "simple-enum") {
            c += " " + this.buildEnumName(table, column);
            if (column.isArray) c += " array";
        } else if (!column.isGenerated || column.type === "uuid") {
            c += " " + this.connection.driver.createFullType(column);
        }
        // Postgres only supports the stored generated column type
        if (column.generatedType === "STORED" && column.asExpression) {
            c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;
        }
        if (column.charset) c += ' CHARACTER SET "' + column.charset + '"';
        if (column.collation) c += ' COLLATE "' + column.collation + '"';
        if (column.isNullable !== true) c += " NOT NULL";
        if (column.default !== undefined && column.default !== null) c += " DEFAULT " + column.default;
        if (column.isGenerated && column.generationStrategy === "uuid" && !column.default) c += ` DEFAULT ${this.driver.uuidGenerator}`;
        return c;
    }
    /**
     * Checks if the PostgreSQL server has support for partitioned tables
     */ async hasSupportForPartitionedTables() {
        const result = await this.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);
        return result.length ? true : false;
    }
    /**
     * Change table comment.
     */ async changeTableComment(tableOrName, newComment) {
        const upQueries = [];
        const downQueries = [];
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        newComment = this.escapeComment(newComment);
        const comment = this.escapeComment(table.comment);
        if (newComment === comment) {
            return;
        }
        const newTable = table.clone();
        upQueries.push(new Query_1.Query(`COMMENT ON TABLE ${this.escapePath(newTable)} IS ${newComment}`));
        downQueries.push(new Query_1.Query(`COMMENT ON TABLE ${this.escapePath(table)} IS ${comment}`));
        await this.executeQueries(upQueries, downQueries);
        table.comment = newTable.comment;
        this.replaceCachedTable(table, newTable);
    }
}
exports.PostgresQueryRunner = PostgresQueryRunner; //# sourceMappingURL=PostgresQueryRunner.js.map
}),
"[project]/node_modules/typeorm/driver/postgres/PostgresDriver.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PostgresDriver = void 0;
const ConnectionIsNotSetError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionIsNotSetError.js [app-route] (ecmascript)");
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const RdbmsSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const VersionUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/VersionUtils.js [app-route] (ecmascript)");
const PostgresQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/postgres/PostgresQueryRunner.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Organizes communication with PostgreSQL DBMS.
 */ class PostgresDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        /**
         * Pool for slave databases.
         * Used in replication.
         */ this.slaves = [];
        /**
         * We store all created query runners because we need to release them.
         */ this.connectedQueryRunners = [];
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = true;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "nested";
        /**
         * Gets list of supported column data types by a driver.
         *
         * @see https://www.tutorialspoint.com/postgresql/postgresql_data_types.htm
         * @see https://www.postgresql.org/docs/9.2/static/datatype.html
         */ this.supportedDataTypes = [
            "int",
            "int2",
            "int4",
            "int8",
            "smallint",
            "integer",
            "bigint",
            "decimal",
            "numeric",
            "real",
            "float",
            "float4",
            "float8",
            "double precision",
            "money",
            "character varying",
            "varchar",
            "character",
            "char",
            "text",
            "citext",
            "hstore",
            "bytea",
            "bit",
            "varbit",
            "bit varying",
            "timetz",
            "timestamptz",
            "timestamp",
            "timestamp without time zone",
            "timestamp with time zone",
            "date",
            "time",
            "time without time zone",
            "time with time zone",
            "interval",
            "bool",
            "boolean",
            "enum",
            "point",
            "line",
            "lseg",
            "box",
            "path",
            "polygon",
            "circle",
            "cidr",
            "inet",
            "macaddr",
            "macaddr8",
            "tsvector",
            "tsquery",
            "uuid",
            "xml",
            "json",
            "jsonb",
            "int4range",
            "int8range",
            "numrange",
            "tsrange",
            "tstzrange",
            "daterange",
            "int4multirange",
            "int8multirange",
            "nummultirange",
            "tsmultirange",
            "tstzmultirange",
            "datemultirange",
            "geometry",
            "geography",
            "cube",
            "ltree",
            "vector",
            "halfvec"
        ];
        /**
         * Returns type of upsert supported by driver if any
         */ this.supportedUpsertTypes = [
            "on-conflict-do-update"
        ];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [
            "geometry",
            "geography"
        ];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [
            "character varying",
            "varchar",
            "character",
            "char",
            "bit",
            "varbit",
            "bit varying",
            "vector",
            "halfvec"
        ];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [
            "numeric",
            "decimal",
            "interval",
            "time without time zone",
            "time with time zone",
            "timestamp without time zone",
            "timestamp with time zone"
        ];
        /**
         * Gets list of column data types that support scale by a driver.
         */ this.withScaleColumnTypes = [
            "numeric",
            "decimal"
        ];
        /**
         * Orm has special columns and we need to know what database column types should be for those types.
         * Column types are driver dependant.
         */ this.mappedDataTypes = {
            createDate: "timestamp",
            createDateDefault: "now()",
            updateDate: "timestamp",
            updateDateDefault: "now()",
            deleteDate: "timestamp",
            deleteDateNullable: true,
            version: "int4",
            treeLevel: "int4",
            migrationId: "int4",
            migrationName: "varchar",
            migrationTimestamp: "int8",
            cacheId: "int4",
            cacheIdentifier: "varchar",
            cacheTime: "int8",
            cacheDuration: "int4",
            cacheQuery: "text",
            cacheResult: "text",
            metadataType: "varchar",
            metadataDatabase: "varchar",
            metadataSchema: "varchar",
            metadataTable: "varchar",
            metadataName: "varchar",
            metadataValue: "text"
        };
        /**
         * The prefix used for the parameters
         */ this.parametersPrefix = "$";
        /**
         * Default values of length, precision and scale depends on column data type.
         * Used in the cases when length/precision/scale is not specified by user.
         */ this.dataTypeDefaults = {
            character: {
                length: 1
            },
            bit: {
                length: 1
            },
            interval: {
                precision: 6
            },
            "time without time zone": {
                precision: 6
            },
            "time with time zone": {
                precision: 6
            },
            "timestamp without time zone": {
                precision: 6
            },
            "timestamp with time zone": {
                precision: 6
            }
        };
        /**
         * Max length allowed by Postgres for aliases.
         * @see https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS
         */ this.maxAliasLength = 63;
        this.isGeneratedColumnsSupported = false;
        this.cteCapabilities = {
            enabled: true,
            writable: true,
            requiresRecursiveHint: true,
            materializedHint: true
        };
        if (!connection) {
            return;
        }
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = this.options.replication ? true : false;
        if (this.options.useUTC) {
            process.env.PGTZ = "UTC";
        }
        // load postgres package
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
    // ObjectUtils.assign(this.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
    // validate options to make sure everything is set
    // todo: revisit validation with replication in mind
    // if (!this.options.host)
    //     throw new DriverOptionNotSetError("host");
    // if (!this.options.username)
    //     throw new DriverOptionNotSetError("username");
    // if (!this.options.database)
    //     throw new DriverOptionNotSetError("database");
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     * Based on pooling options, it can either create connection immediately,
     * either create a pool and create connection when needed.
     */ async connect() {
        if (this.options.replication) {
            this.slaves = await Promise.all(this.options.replication.slaves.map((slave)=>{
                return this.createPool(this.options, slave);
            }));
            this.master = await this.createPool(this.options, this.options.replication.master);
        } else {
            this.master = await this.createPool(this.options, this.options);
        }
        const queryRunner = this.createQueryRunner("master");
        this.version = await queryRunner.getVersion();
        if (!this.database) {
            this.database = await queryRunner.getCurrentDatabase();
        }
        if (!this.searchSchema) {
            this.searchSchema = await queryRunner.getCurrentSchema();
        }
        await queryRunner.release();
        if (!this.schema) {
            this.schema = this.searchSchema;
        }
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ async afterConnect() {
        const extensionsMetadata = await this.checkMetadataForExtensions();
        const [connection, release] = await this.obtainMasterConnection();
        const installExtensions = this.options.installExtensions === undefined || this.options.installExtensions;
        if (installExtensions && extensionsMetadata.hasExtensions) {
            await this.enableExtensions(extensionsMetadata, connection);
        }
        this.isGeneratedColumnsSupported = VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "12.0");
        await release();
    }
    async enableExtensions(extensionsMetadata, connection) {
        const { logger } = this.connection;
        const { hasUuidColumns, hasCitextColumns, hasHstoreColumns, hasCubeColumns, hasGeometryColumns, hasLtreeColumns, hasVectorColumns, hasExclusionConstraints } = extensionsMetadata;
        if (hasUuidColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "${this.options.uuidExtension || "uuid-ossp"}"`);
        } catch (_) {
            logger.log("warn", `At least one of the entities has uuid column, but the '${this.options.uuidExtension || "uuid-ossp"}' extension cannot be installed automatically. Please install it manually using superuser rights, or select another uuid extension.`);
        }
        if (hasCitextColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "citext"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has citext column, but the 'citext' extension cannot be installed automatically. Please install it manually using superuser rights");
        }
        if (hasHstoreColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "hstore"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has hstore column, but the 'hstore' extension cannot be installed automatically. Please install it manually using superuser rights");
        }
        if (hasGeometryColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "postgis"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has a geometry column, but the 'postgis' extension cannot be installed automatically. Please install it manually using superuser rights");
        }
        if (hasCubeColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "cube"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has a cube column, but the 'cube' extension cannot be installed automatically. Please install it manually using superuser rights");
        }
        if (hasLtreeColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "ltree"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has a ltree column, but the 'ltree' extension cannot be installed automatically. Please install it manually using superuser rights");
        }
        if (hasVectorColumns) try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "vector"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has a vector column, but the 'vector' extension (pgvector) cannot be installed automatically. Please install it manually using superuser rights");
        }
        if (hasExclusionConstraints) try {
            // The btree_gist extension provides operator support in PostgreSQL exclusion constraints
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "btree_gist"`);
        } catch (_) {
            logger.log("warn", "At least one of the entities has an exclusion constraint, but the 'btree_gist' extension cannot be installed automatically. Please install it manually using superuser rights");
        }
    }
    async checkMetadataForExtensions() {
        const hasUuidColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.generatedColumns.filter((column)=>column.generationStrategy === "uuid").length > 0;
        });
        const hasCitextColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.columns.filter((column)=>column.type === "citext").length > 0;
        });
        const hasHstoreColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.columns.filter((column)=>column.type === "hstore").length > 0;
        });
        const hasCubeColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.columns.filter((column)=>column.type === "cube").length > 0;
        });
        const hasGeometryColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.columns.filter((column)=>this.spatialTypes.indexOf(column.type) >= 0).length > 0;
        });
        const hasLtreeColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.columns.filter((column)=>column.type === "ltree").length > 0;
        });
        const hasVectorColumns = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.columns.some((column)=>column.type === "vector" || column.type === "halfvec");
        });
        const hasExclusionConstraints = this.connection.entityMetadatas.some((metadata)=>{
            return metadata.exclusions.length > 0;
        });
        return {
            hasUuidColumns,
            hasCitextColumns,
            hasHstoreColumns,
            hasCubeColumns,
            hasGeometryColumns,
            hasLtreeColumns,
            hasVectorColumns,
            hasExclusionConstraints,
            hasExtensions: hasUuidColumns || hasCitextColumns || hasHstoreColumns || hasGeometryColumns || hasCubeColumns || hasLtreeColumns || hasVectorColumns || hasExclusionConstraints
        };
    }
    /**
     * Closes connection with database.
     */ async disconnect() {
        if (!this.master) {
            throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("postgres");
        }
        await this.closePool(this.master);
        await Promise.all(this.slaves.map((slave)=>this.closePool(slave)));
        this.master = undefined;
        this.slaves = [];
    }
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        return new PostgresQueryRunner_1.PostgresQueryRunner(this, mode);
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === undefined) return value;
        if (columnMetadata.type === Boolean) {
            return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
            return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp without time zone") {
            return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if ([
            "json",
            "jsonb",
            ...this.spatialTypes
        ].indexOf(columnMetadata.type) >= 0) {
            return JSON.stringify(value);
        } else if (columnMetadata.type === "vector" || columnMetadata.type === "halfvec") {
            if (Array.isArray(value)) {
                return `[${value.join(",")}]`;
            } else {
                return value;
            }
        } else if (columnMetadata.type === "hstore") {
            if (typeof value === "string") {
                return value;
            } else {
                // https://www.postgresql.org/docs/9.0/hstore.html
                const quoteString = (value)=>{
                    // If a string to be quoted is `null` or `undefined`, we return a literal unquoted NULL.
                    // This way, NULL values can be stored in the hstore object.
                    if (value === null || typeof value === "undefined") {
                        return "NULL";
                    }
                    // Convert non-null values to string since HStore only stores strings anyway.
                    // To include a double quote or a backslash in a key or value, escape it with a backslash.
                    return `"${`${value}`.replace(/(?=["\\])/g, "\\")}"`;
                };
                return Object.keys(value).map((key)=>quoteString(key) + "=>" + quoteString(value[key])).join(",");
            }
        } else if (columnMetadata.type === "simple-array") {
            return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
            return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "cube") {
            if (columnMetadata.isArray) {
                return `{${value.map((cube)=>`"(${cube.join(",")})"`).join(",")}}`;
            }
            return `(${value.join(",")})`;
        } else if (columnMetadata.type === "ltree") {
            return value.split(".").filter(Boolean).join(".").replace(/[\s]+/g, "_");
        } else if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && !columnMetadata.isArray) {
            return "" + value;
        }
        return value;
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean) {
            value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp without time zone") {
            value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "vector" || columnMetadata.type === "halfvec") {
            if (typeof value === "string" && value.startsWith("[") && value.endsWith("]")) {
                if (value === "[]") return [];
                return value.slice(1, -1).split(",").map(Number);
            }
        } else if (columnMetadata.type === "hstore") {
            if (columnMetadata.hstoreType === "object") {
                const unescapeString = (str)=>str.replace(/\\./g, (m)=>m[1]);
                const regexp = /"([^"\\]*(?:\\.[^"\\]*)*)"=>(?:(NULL)|"([^"\\]*(?:\\.[^"\\]*)*)")(?:,|$)/g;
                const object = {};
                `${value}`.replace(regexp, (_, key, nullValue, stringValue)=>{
                    object[unescapeString(key)] = nullValue ? null : unescapeString(stringValue);
                    return "";
                });
                value = object;
            }
        } else if (columnMetadata.type === "simple-array") {
            value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
            value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "cube") {
            value = value.replace(/[()\s]+/g, ""); // remove whitespace
            if (columnMetadata.isArray) {
                /**
                 * Strips these groups from `{"1,2,3","",NULL}`:
                 * 1. ["1,2,3", undefined]  <- cube of arity 3
                 * 2. ["", undefined]         <- cube of arity 0
                 * 3. [undefined, "NULL"]     <- NULL
                 */ const regexp = /(?:"((?:[\d\s.,])*)")|(?:(NULL))/g;
                const unparsedArrayString = value;
                value = [];
                let cube = null;
                // Iterate through all regexp matches for cubes/null in array
                while((cube = regexp.exec(unparsedArrayString)) !== null){
                    if (cube[1] !== undefined) {
                        value.push(cube[1].split(",").filter(Boolean).map(Number));
                    } else {
                        value.push(undefined);
                    }
                }
            } else {
                value = value.split(",").filter(Boolean).map(Number);
            }
        } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
            if (columnMetadata.isArray) {
                if (value === "{}") return [];
                // manually convert enum array to array of values (pg does not support, see https://github.com/brianc/node-pg-types/issues/56)
                value = value.slice(1, -1).split(",").map((val)=>{
                    // replace double quotes from the beginning and from the end
                    if (val.startsWith(`"`) && val.endsWith(`"`)) val = val.slice(1, -1);
                    // replace escaped backslash and double quotes
                    return val.replace(/\\(\\|")/g, "$1");
                });
                // convert to number if that exists in possible enum options
                value = value.map((val)=>{
                    return !isNaN(+val) && columnMetadata.enum.indexOf(parseInt(val)) >= 0 ? parseInt(val) : val;
                });
            } else {
                // convert to number if that exists in possible enum options
                value = !isNaN(+value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0 ? parseInt(value) : value;
            }
        } else if (columnMetadata.type === Number) {
            // convert to number if number
            value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key)=>nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length) return [
            sql,
            escapedParameters
        ];
        const parameterIndexMap = new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            if (parameterIndexMap.has(key)) {
                return this.parametersPrefix + parameterIndexMap.get(key);
            }
            const value = parameters[key];
            if (isArray) {
                return value.map((v)=>{
                    escapedParameters.push(v);
                    return this.createParameter(key, escapedParameters.length - 1);
                }).join(", ");
            }
            if (typeof value === "function") {
                return value();
            }
            escapedParameters.push(value);
            parameterIndexMap.set(key, escapedParameters.length);
            return this.createParameter(key, escapedParameters.length - 1);
        }); // todo: make replace only in value statements, otherwise problems
        return [
            sql,
            escapedParameters
        ];
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return '"' + columnName + '"';
    }
    /**
     * Build full table name with schema name and table name.
     * E.g. myDB.mySchema.myTable
     */ buildTableName(tableName, schema) {
        const tablePath = [
            tableName
        ];
        if (schema) {
            tablePath.unshift(schema);
        }
        return tablePath.join(".");
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
            const parsed = this.parseTableName(target.name);
            return {
                database: target.database || parsed.database || driverDatabase,
                schema: target.schema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
            const parsed = this.parseTableName(target.referencedTableName);
            return {
                database: target.referencedDatabase || parsed.database || driverDatabase,
                schema: target.referencedSchema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
            // EntityMetadata tableName is never a path
            return {
                database: target.database || driverDatabase,
                schema: target.schema || driverSchema,
                tableName: target.tableName
            };
        }
        const parts = target.split(".");
        return {
            database: driverDatabase,
            schema: (parts.length > 1 ? parts[0] : undefined) || driverSchema,
            tableName: parts.length > 1 ? parts[1] : parts[0]
        };
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        if (column.type === Number || column.type === "int" || column.type === "int4") {
            return "integer";
        } else if (column.type === String || column.type === "varchar") {
            return "character varying";
        } else if (column.type === Date || column.type === "timestamp") {
            return "timestamp without time zone";
        } else if (column.type === "timestamptz") {
            return "timestamp with time zone";
        } else if (column.type === "time") {
            return "time without time zone";
        } else if (column.type === "timetz") {
            return "time with time zone";
        } else if (column.type === Boolean || column.type === "bool") {
            return "boolean";
        } else if (column.type === "simple-array") {
            return "text";
        } else if (column.type === "simple-json") {
            return "text";
        } else if (column.type === "simple-enum") {
            return "enum";
        } else if (column.type === "int2") {
            return "smallint";
        } else if (column.type === "int8") {
            return "bigint";
        } else if (column.type === "decimal") {
            return "numeric";
        } else if (column.type === "float8" || column.type === "float") {
            return "double precision";
        } else if (column.type === "float4") {
            return "real";
        } else if (column.type === "char") {
            return "character";
        } else if (column.type === "varbit") {
            return "bit varying";
        } else {
            return column.type || "";
        }
    }
    /**
     * Normalizes "default" value of the column.
     */ normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (defaultValue === null || defaultValue === undefined) {
            return undefined;
        }
        if (columnMetadata.isArray && Array.isArray(defaultValue)) {
            return `'{${defaultValue.map((val)=>String(val)).join(",")}}'`;
        }
        if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum" || typeof defaultValue === "number" || typeof defaultValue === "string") && defaultValue !== undefined) {
            return `'${defaultValue}'`;
        }
        if (typeof defaultValue === "boolean") {
            return defaultValue ? "true" : "false";
        }
        if (typeof defaultValue === "function") {
            const value = defaultValue();
            return this.normalizeDatetimeFunction(value);
        }
        if (typeof defaultValue === "object") {
            return `'${JSON.stringify(defaultValue)}'`;
        }
        return `${defaultValue}`;
    }
    /**
     * Compares "default" value of the column.
     * Postgres sorts json values before it is saved, so in that case a deep comparison has to be performed to see if has changed.
     */ defaultEqual(columnMetadata, tableColumn) {
        if ([
            "json",
            "jsonb"
        ].includes(columnMetadata.type) && ![
            "function",
            "undefined"
        ].includes(typeof columnMetadata.default)) {
            const tableColumnDefault = typeof tableColumn.default === "string" ? JSON.parse(tableColumn.default.substring(1, tableColumn.default.length - 1)) : tableColumn.default;
            return OrmUtils_1.OrmUtils.deepCompare(columnMetadata.default, tableColumnDefault);
        }
        const columnDefault = this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata));
        return columnDefault === tableColumn.default;
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq)=>uq.columns.length === 1 && uq.columns[0] === column);
    }
    /**
     * Returns default column lengths, which is required on column creation.
     */ getColumnLength(column) {
        return column.length ? column.length.toString() : "";
    }
    /**
     * Creates column type definition including length, precision and scale
     */ createFullType(column) {
        let type = column.type;
        if (column.length) {
            type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {
            type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== undefined) {
            type += "(" + column.precision + ")";
        }
        if (column.type === "time without time zone") {
            type = "TIME" + (column.precision !== null && column.precision !== undefined ? "(" + column.precision + ")" : "");
        } else if (column.type === "time with time zone") {
            type = "TIME" + (column.precision !== null && column.precision !== undefined ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
        } else if (column.type === "timestamp without time zone") {
            type = "TIMESTAMP" + (column.precision !== null && column.precision !== undefined ? "(" + column.precision + ")" : "");
        } else if (column.type === "timestamp with time zone") {
            type = "TIMESTAMP" + (column.precision !== null && column.precision !== undefined ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
        } else if (this.spatialTypes.indexOf(column.type) >= 0) {
            if (column.spatialFeatureType != null && column.srid != null) {
                type = `${column.type}(${column.spatialFeatureType},${column.srid})`;
            } else if (column.spatialFeatureType != null) {
                type = `${column.type}(${column.spatialFeatureType})`;
            } else {
                type = column.type;
            }
        } else if (column.type === "vector" || column.type === "halfvec") {
            type = column.type + (column.length ? "(" + column.length + ")" : "");
        }
        if (column.isArray) type += " array";
        return type;
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ async obtainMasterConnection() {
        if (!this.master) {
            throw new error_1.TypeORMError("Driver not Connected");
        }
        return new Promise((ok, fail)=>{
            this.master.connect((err, connection, release)=>{
                err ? fail(err) : ok([
                    connection,
                    release
                ]);
            });
        });
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ async obtainSlaveConnection() {
        if (!this.slaves.length) {
            return this.obtainMasterConnection();
        }
        const random = Math.floor(Math.random() * this.slaves.length);
        return new Promise((ok, fail)=>{
            this.slaves[random].connect((err, connection, release)=>{
                err ? fail(err) : ok([
                    connection,
                    release
                ]);
            });
        });
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     *
     * todo: slow. optimize Object.keys(), OrmUtils.mergeDeep and column.createValueMap parts
     */ createGeneratedMap(metadata, insertResult) {
        if (!insertResult) return undefined;
        return Object.keys(insertResult).reduce((map, key)=>{
            const column = metadata.findColumnWithDatabaseName(key);
            if (column) {
                OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));
            // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later
            }
            return map;
        }, {});
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata)=>{
            const tableColumn = tableColumns.find((c)=>c.name === columnMetadata.databaseName);
            if (!tableColumn) return false; // we don't need new columns, we only need exist and changed
            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.isArray !== columnMetadata.isArray || tableColumn.precision !== columnMetadata.precision || columnMetadata.scale !== undefined && tableColumn.scale !== columnMetadata.scale || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !tableColumn.isGenerated && !this.defaultEqual(columnMetadata, tableColumn) || // we included check for generated here, because generated columns already can have default values
            tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enumName !== columnMetadata.enumName || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val)=>val + "")) || // enums in postgres are always strings
            tableColumn.isGenerated !== columnMetadata.isGenerated || (tableColumn.spatialFeatureType || "").toLowerCase() !== (columnMetadata.spatialFeatureType || "").toLowerCase() || tableColumn.srid !== columnMetadata.srid || tableColumn.generatedType !== columnMetadata.generatedType || (tableColumn.asExpression || "").trim() !== (columnMetadata.asExpression || "").trim() || tableColumn.collation !== columnMetadata.collation;
            // DEBUG SECTION
            // if (isColumnChanged) {
            //     console.log("table:", columnMetadata.entityMetadata.tableName)
            //     console.log(
            //         "name:",
            //         tableColumn.name,
            //         columnMetadata.databaseName,
            //     )
            //     console.log(
            //         "type:",
            //         tableColumn.type,
            //         this.normalizeType(columnMetadata),
            //     )
            //     console.log(
            //         "length:",
            //         tableColumn.length,
            //         columnMetadata.length,
            //     )
            //     console.log(
            //         "isArray:",
            //         tableColumn.isArray,
            //         columnMetadata.isArray,
            //     )
            //     console.log(
            //         "precision:",
            //         tableColumn.precision,
            //         columnMetadata.precision,
            //     )
            //     console.log("scale:", tableColumn.scale, columnMetadata.scale)
            //     console.log(
            //         "comment:",
            //         tableColumn.comment,
            //         this.escapeComment(columnMetadata.comment),
            //     )
            //     console.log(
            //         "enumName:",
            //         tableColumn.enumName,
            //         columnMetadata.enumName,
            //     )
            //     console.log(
            //         "enum:",
            //         tableColumn.enum &&
            //             columnMetadata.enum &&
            //             !OrmUtils.isArraysEqual(
            //                 tableColumn.enum,
            //                 columnMetadata.enum.map((val) => val + ""),
            //             ),
            //     )
            //     console.log(
            //         "isPrimary:",
            //         tableColumn.isPrimary,
            //         columnMetadata.isPrimary,
            //     )
            //     console.log(
            //         "isNullable:",
            //         tableColumn.isNullable,
            //         columnMetadata.isNullable,
            //     )
            //     console.log(
            //         "isUnique:",
            //         tableColumn.isUnique,
            //         this.normalizeIsUnique(columnMetadata),
            //     )
            //     console.log(
            //         "isGenerated:",
            //         tableColumn.isGenerated,
            //         columnMetadata.isGenerated,
            //     )
            //     console.log(
            //         "generatedType:",
            //         tableColumn.generatedType,
            //         columnMetadata.generatedType,
            //     )
            //     console.log(
            //         "asExpression:",
            //         (tableColumn.asExpression || "").trim(),
            //         (columnMetadata.asExpression || "").trim(),
            //     )
            //     console.log(
            //         "collation:",
            //         tableColumn.collation,
            //         columnMetadata.collation,
            //     )
            //     console.log(
            //         "isGenerated 2:",
            //         !tableColumn.isGenerated &&
            //             this.lowerDefaultValueIfNecessary(
            //                 this.normalizeDefault(columnMetadata),
            //             ) !== tableColumn.default,
            //     )
            //     console.log(
            //         "spatialFeatureType:",
            //         (tableColumn.spatialFeatureType || "").toLowerCase(),
            //         (columnMetadata.spatialFeatureType || "").toLowerCase(),
            //     )
            //     console.log("srid", tableColumn.srid, columnMetadata.srid)
            //     console.log("==========================================")
            // }
            return isColumnChanged;
        });
    }
    lowerDefaultValueIfNecessary(value) {
        // Postgres saves function calls in default value as lowercase #2733
        if (!value) {
            return value;
        }
        return value.split(`'`).map((v, i)=>{
            return i % 2 === 1 ? v : v.toLowerCase();
        }).join(`'`);
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return true;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return true;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return false;
    }
    get uuidGenerator() {
        return this.options.uuidExtension === "pgcrypto" ? "gen_random_uuid()" : "uuid_generate_v4()";
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        return this.parametersPrefix + (index + 1);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Loads postgres query stream package.
     */ loadStreamDependency() {
        try {
            return PlatformTools_1.PlatformTools.load("pg-query-stream");
        } catch  {
            // todo: better error for browser env
            throw new error_1.TypeORMError(`To use streams you should install pg-query-stream package. Please run "npm i pg-query-stream".`);
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        try {
            const postgres = this.options.driver || PlatformTools_1.PlatformTools.load("pg");
            this.postgres = postgres;
            try {
                const pgNative = this.options.nativeDriver || PlatformTools_1.PlatformTools.load("pg-native");
                if (pgNative && this.postgres.native) this.postgres = this.postgres.native;
            } catch (e) {}
        } catch (e) {
            // todo: better error for browser env
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Postgres", "pg");
        }
    }
    /**
     * Creates a new connection pool for a given database credentials.
     */ async createPool(options, credentials) {
        const { logger } = this.connection;
        credentials = Object.assign({}, credentials);
        // build connection options for the driver
        // See: https://github.com/brianc/node-postgres/tree/master/packages/pg-pool#create
        const connectionOptions = Object.assign({}, {
            connectionString: credentials.url,
            host: credentials.host,
            user: credentials.username,
            password: credentials.password,
            database: credentials.database,
            port: credentials.port,
            ssl: credentials.ssl,
            connectionTimeoutMillis: options.connectTimeoutMS,
            application_name: options.applicationName ?? credentials.applicationName,
            max: options.poolSize
        }, options.extra || {});
        if (options.parseInt8 !== undefined) {
            if (this.postgres.defaults && Object.getOwnPropertyDescriptor(this.postgres.defaults, "parseInt8")?.set) {
                this.postgres.defaults.parseInt8 = options.parseInt8;
            } else {
                logger.log("warn", "Attempted to set parseInt8 option, but the postgres driver does not support setting defaults.parseInt8. This option will be ignored.");
            }
        }
        // create a connection pool
        const pool = new this.postgres.Pool(connectionOptions);
        const poolErrorHandler = options.poolErrorHandler || ((error)=>logger.log("warn", `Postgres pool raised an error. ${error}`));
        /*
          Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and
          cause the hosting app to crash.
         */ pool.on("error", poolErrorHandler);
        return new Promise((ok, fail)=>{
            pool.connect((err, connection, release)=>{
                if (err) return fail(err);
                if (options.logNotifications) {
                    connection.on("notice", (msg)=>{
                        msg && this.connection.logger.log("info", msg.message);
                    });
                    connection.on("notification", (msg)=>{
                        msg && this.connection.logger.log("info", `Received NOTIFY on channel ${msg.channel}: ${msg.payload}.`);
                    });
                }
                release();
                ok(pool);
            });
        });
    }
    /**
     * Closes connection pool.
     */ async closePool(pool) {
        while(this.connectedQueryRunners.length){
            await this.connectedQueryRunners[0].release();
        }
        return new Promise((ok, fail)=>{
            pool.end((err)=>err ? fail(err) : ok());
        });
    }
    /**
     * Executes given query.
     */ executeQuery(connection, query) {
        this.connection.logger.logQuery(query);
        return new Promise((ok, fail)=>{
            connection.query(query, (err, result)=>err ? fail(err) : ok(result));
        });
    }
    /**
     * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
     * Otherwise returns original input.
     */ normalizeDatetimeFunction(value) {
        // check if input is datetime function
        const upperCaseValue = value.toUpperCase();
        const isDatetimeFunction = upperCaseValue.indexOf("CURRENT_TIMESTAMP") !== -1 || upperCaseValue.indexOf("CURRENT_DATE") !== -1 || upperCaseValue.indexOf("CURRENT_TIME") !== -1 || upperCaseValue.indexOf("LOCALTIMESTAMP") !== -1 || upperCaseValue.indexOf("LOCALTIME") !== -1;
        if (isDatetimeFunction) {
            // extract precision, e.g. "(3)"
            const precision = value.match(/\(\d+\)/);
            if (upperCaseValue.indexOf("CURRENT_TIMESTAMP") !== -1) {
                return precision ? `('now'::text)::timestamp${precision[0]} with time zone` : "now()";
            } else if (upperCaseValue === "CURRENT_DATE") {
                return "('now'::text)::date";
            } else if (upperCaseValue.indexOf("CURRENT_TIME") !== -1) {
                return precision ? `('now'::text)::time${precision[0]} with time zone` : "('now'::text)::time with time zone";
            } else if (upperCaseValue.indexOf("LOCALTIMESTAMP") !== -1) {
                return precision ? `('now'::text)::timestamp${precision[0]} without time zone` : "('now'::text)::timestamp without time zone";
            } else if (upperCaseValue.indexOf("LOCALTIME") !== -1) {
                return precision ? `('now'::text)::time${precision[0]} without time zone` : "('now'::text)::time without time zone";
            }
        }
        return value;
    }
    /**
     * Escapes a given comment.
     */ escapeComment(comment) {
        if (!comment) return comment;
        comment = comment.replace(/\u0000/g, ""); // Null bytes aren't allowed in comments
        return comment;
    }
}
exports.PostgresDriver = PostgresDriver; //# sourceMappingURL=PostgresDriver.js.map
}),
];

//# sourceMappingURL=node_modules_typeorm_driver_postgres_871089a1._.js.map