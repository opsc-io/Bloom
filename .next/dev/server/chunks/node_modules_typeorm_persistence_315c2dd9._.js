module.exports = [
"[project]/node_modules/typeorm/persistence/SubjectTopologicalSorter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubjectTopologicalSorter = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Orders insert or remove subjects in proper order (using topological sorting)
 * to make sure insert or remove operations are executed in a proper order.
 */ class SubjectTopologicalSorter {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(subjects){
        this.subjects = [
            ...subjects
        ]; // copy subjects to prevent changing of sent array
        this.metadatas = this.getUniqueMetadatas(this.subjects);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Sorts (orders) subjects in their topological order.
     */ sort(direction) {
        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here
        if (!this.metadatas.length) return this.subjects;
        const sortedSubjects = [];
        // first if we sort for deletion all junction subjects
        // junction subjects are subjects without entity and database entity set
        if (direction === "delete") {
            const junctionSubjects = this.subjects.filter((subject)=>!subject.entity && !subject.databaseEntity);
            sortedSubjects.push(...junctionSubjects);
            this.removeAlreadySorted(junctionSubjects);
        }
        // next we always insert entities with non-nullable relations, sort them first
        const nonNullableDependencies = this.getNonNullableDependencies();
        let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);
        if (direction === "insert") sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse();
        // so we have a sorted entity targets
        // go thought each of them and find all subjects with sorted entity target
        // add those sorted targets and remove them from original array of targets
        sortedNonNullableEntityTargets.forEach((sortedEntityTarget)=>{
            const entityTargetSubjects = this.subjects.filter((subject)=>subject.metadata.targetName === sortedEntityTarget || subject.metadata.inheritanceTree.some((s)=>s.name === sortedEntityTarget));
            sortedSubjects.push(...entityTargetSubjects);
            this.removeAlreadySorted(entityTargetSubjects);
        });
        // next sort all other entities
        // same process as in above but with other entities
        const otherDependencies = this.getDependencies();
        let sortedOtherEntityTargets = this.toposort(otherDependencies);
        if (direction === "insert") sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();
        sortedOtherEntityTargets.forEach((sortedEntityTarget)=>{
            const entityTargetSubjects = this.subjects.filter((subject)=>subject.metadata.targetName === sortedEntityTarget);
            sortedSubjects.push(...entityTargetSubjects);
            this.removeAlreadySorted(entityTargetSubjects);
        });
        // if we have something left in the subjects add them as well
        sortedSubjects.push(...this.subjects);
        return sortedSubjects;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Removes already sorted subjects from this.subjects list of subjects.
     */ removeAlreadySorted(subjects) {
        subjects.forEach((subject)=>{
            this.subjects.splice(this.subjects.indexOf(subject), 1);
        });
    }
    /**
     * Extracts all unique metadatas from the given subjects.
     */ getUniqueMetadatas(subjects) {
        const metadatas = [];
        subjects.forEach((subject)=>{
            if (metadatas.indexOf(subject.metadata) === -1) metadatas.push(subject.metadata);
        });
        return metadatas;
    }
    /**
     * Gets dependency tree for all entity metadatas with non-nullable relations.
     * We need to execute insertions first for entities which non-nullable relations.
     */ getNonNullableDependencies() {
        return this.metadatas.reduce((dependencies, metadata)=>{
            metadata.relationsWithJoinColumns.forEach((relation)=>{
                if (relation.isNullable) return;
                dependencies.push([
                    metadata.targetName,
                    relation.inverseEntityMetadata.targetName
                ]);
            });
            return dependencies;
        }, []);
    }
    /**
     * Gets dependency tree for all entity metadatas with non-nullable relations.
     * We need to execute insertions first for entities which non-nullable relations.
     */ getDependencies() {
        return this.metadatas.reduce((dependencies, metadata)=>{
            metadata.relationsWithJoinColumns.forEach((relation)=>{
                // if relation is self-referenced we skip it
                if (relation.inverseEntityMetadata === metadata) return;
                dependencies.push([
                    metadata.targetName,
                    relation.inverseEntityMetadata.targetName
                ]);
            });
            return dependencies;
        }, []);
    }
    /**
     * Sorts given graph using topological sorting algorithm.
     *
     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.
     */ toposort(edges) {
        function uniqueNodes(arr) {
            const res = [];
            for(let i = 0, len = arr.length; i < len; i++){
                const edge = arr[i];
                if (res.indexOf(edge[0]) < 0) res.push(edge[0]);
                if (res.indexOf(edge[1]) < 0) res.push(edge[1]);
            }
            return res;
        }
        const nodes = uniqueNodes(edges);
        let cursor = nodes.length, i = cursor;
        const sorted = new Array(cursor), visited = new Set();
        while(i--){
            if (!visited.has(i)) visit(nodes[i], i, []);
        }
        function visit(node, i, predecessors) {
            if (predecessors.indexOf(node) >= 0) {
                throw new error_1.TypeORMError("Cyclic dependency: " + JSON.stringify(node)); // todo: better error
            }
            if (!~nodes.indexOf(node)) {
                throw new error_1.TypeORMError("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
            }
            if (visited.has(i)) return;
            visited.add(i);
            // outgoing edges
            const outgoing = edges.filter(function(edge) {
                return edge[0] === node;
            });
            if (i = outgoing.length) {
                const preds = predecessors.concat(node);
                do {
                    const child = outgoing[--i][1];
                    visit(child, nodes.indexOf(child), preds);
                }while (i)
            }
            sorted[--cursor] = node;
        }
        return sorted;
    }
}
exports.SubjectTopologicalSorter = SubjectTopologicalSorter; //# sourceMappingURL=SubjectTopologicalSorter.js.map
}),
"[project]/node_modules/typeorm/persistence/SubjectChangedColumnsComputer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubjectChangedColumnsComputer = void 0;
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Finds what columns are changed in the subject entities.
 */ class SubjectChangedColumnsComputer {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Finds what columns are changed in the subject entities.
     */ compute(subjects) {
        subjects.forEach((subject)=>{
            this.computeDiffColumns(subject);
            this.computeDiffRelationalColumns(subjects, subject);
        });
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Differentiate columns from the updated entity and entity stored in the database.
     */ computeDiffColumns(subject) {
        // if there is no persisted entity then nothing to compute changed in it
        if (!subject.entity) return;
        subject.metadata.columns.forEach((column)=>{
            // ignore special columns
            if (column.isVirtual || column.isDiscriminator // ||
            ) return;
            const changeMap = subject.changeMaps.find((changeMap)=>changeMap.column === column);
            if (changeMap) {
                subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);
            }
            // get user provided value - column value from the user provided persisted entity
            const entityValue = column.getEntityValue(subject.entity);
            // we don't perform operation over undefined properties (but we DO need null properties!)
            if (entityValue === undefined) return;
            // if there is no database entity then all columns are treated as new, e.g. changed
            if (subject.databaseEntity) {
                // skip transform database value for json / jsonb for comparison later on
                const shouldTransformDatabaseEntity = column.type !== "json" && column.type !== "jsonb";
                // get database value of the column
                let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);
                // filter out "relational columns" only in the case if there is a relation object in entity
                if (column.relationMetadata) {
                    const value = column.relationMetadata.getEntityValue(subject.entity);
                    if (value !== null && value !== undefined) return;
                }
                let normalizedValue = entityValue;
                // if both values are not null, normalize special values to make proper comparision
                if (entityValue !== null && databaseValue !== null) {
                    switch(column.type){
                        case "date":
                            normalizedValue = column.isArray ? entityValue.map((date)=>DateUtils_1.DateUtils.mixedDateToDateString(date)) : DateUtils_1.DateUtils.mixedDateToDateString(entityValue);
                            databaseValue = column.isArray ? databaseValue.map((date)=>DateUtils_1.DateUtils.mixedDateToDateString(date)) : DateUtils_1.DateUtils.mixedDateToDateString(databaseValue);
                            break;
                        case "time":
                        case "time with time zone":
                        case "time without time zone":
                        case "timetz":
                            normalizedValue = column.isArray ? entityValue.map((date)=>DateUtils_1.DateUtils.mixedDateToTimeString(date)) : DateUtils_1.DateUtils.mixedDateToTimeString(entityValue);
                            databaseValue = column.isArray ? databaseValue.map((date)=>DateUtils_1.DateUtils.mixedDateToTimeString(date)) : DateUtils_1.DateUtils.mixedDateToTimeString(databaseValue);
                            break;
                        case "datetime":
                        case "datetime2":
                        case Date:
                        case "timestamp":
                        case "timestamp without time zone":
                        case "timestamp with time zone":
                        case "timestamp with local time zone":
                        case "timestamptz":
                            normalizedValue = column.isArray ? entityValue.map((date)=>DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date)) : DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(entityValue);
                            databaseValue = column.isArray ? databaseValue.map((date)=>DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date)) : DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(databaseValue);
                            break;
                        case "json":
                        case "jsonb":
                            // JSON.stringify doesn't work because postgresql sorts jsonb before save.
                            // If you try to save json '[{"messages": "", "attribute Key": "", "level":""}] ' as jsonb,
                            // then postgresql will save it as '[{"level": "", "message":"", "attributeKey": ""}]'
                            if (OrmUtils_1.OrmUtils.deepCompare(entityValue, databaseValue)) return;
                            break;
                        case "simple-array":
                            normalizedValue = DateUtils_1.DateUtils.simpleArrayToString(entityValue);
                            databaseValue = DateUtils_1.DateUtils.simpleArrayToString(databaseValue);
                            break;
                        case "simple-enum":
                            normalizedValue = DateUtils_1.DateUtils.simpleEnumToString(entityValue);
                            databaseValue = DateUtils_1.DateUtils.simpleEnumToString(databaseValue);
                            break;
                        case "simple-json":
                            normalizedValue = DateUtils_1.DateUtils.simpleJsonToString(entityValue);
                            databaseValue = DateUtils_1.DateUtils.simpleJsonToString(databaseValue);
                            break;
                    }
                    if (column.transformer) {
                        normalizedValue = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(column.transformer, entityValue);
                    }
                }
                // if value is not changed - then do nothing
                if (column.isArray) {
                    if (OrmUtils_1.OrmUtils.deepCompare(normalizedValue, databaseValue)) return;
                } else if (Buffer.isBuffer(normalizedValue) && Buffer.isBuffer(databaseValue)) {
                    if (normalizedValue.equals(databaseValue)) {
                        return;
                    }
                } else {
                    if (normalizedValue === databaseValue) return;
                }
            }
            if (!subject.diffColumns.includes(column)) subject.diffColumns.push(column);
            subject.changeMaps.push({
                column: column,
                value: entityValue
            });
        });
    }
    /**
     * Difference columns of the owning one-to-one and many-to-one columns.
     */ computeDiffRelationalColumns(allSubjects, subject) {
        // if there is no persisted entity then nothing to compute changed in it
        if (!subject.entity) return;
        subject.metadata.relationsWithJoinColumns.forEach((relation)=>{
            // get the related entity from the persisted entity
            let relatedEntity = relation.getEntityValue(subject.entity);
            // we don't perform operation over undefined properties (but we DO need null properties!)
            if (relatedEntity === undefined) return;
            // if there is no database entity then all relational columns are treated as new, e.g. changed
            if (subject.databaseEntity) {
                // here we cover two scenarios:
                // 1. related entity can be another entity which is natural way
                // 2. related entity can be just an entity id
                // if relation entity is just a relation id set (for example post.tag = 1)
                // then we create an id map from it to make a proper comparision
                let relatedEntityRelationIdMap = relatedEntity;
                if (relatedEntityRelationIdMap !== null && ObjectUtils_1.ObjectUtils.isObject(relatedEntityRelationIdMap)) relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap);
                // get database related entity. Since loadRelationIds are used on databaseEntity
                // related entity will contain only its relation ids
                const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);
                // if relation ids are equal then we don't need to update anything
                const areRelatedIdsEqual = OrmUtils_1.OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);
                if (areRelatedIdsEqual) {
                    return;
                } else {
                    subject.diffRelations.push(relation);
                }
            }
            // if there is an inserted subject for the related entity of the persisted entity then use it as related entity
            // this code is used for related entities without ids to be properly inserted (and then updated if needed)
            const valueSubject = allSubjects.find((subject)=>subject.mustBeInserted && subject.entity === relatedEntity);
            if (valueSubject) relatedEntity = valueSubject;
            // find if there is already a relation to be changed
            const changeMap = subject.changeMaps.find((changeMap)=>changeMap.relation === relation);
            if (changeMap) {
                // and update its value if it was found
                changeMap.value = relatedEntity;
            } else {
                // if it wasn't found add a new relation for change
                subject.changeMaps.push({
                    relation: relation,
                    value: relatedEntity
                });
            }
        });
    }
}
exports.SubjectChangedColumnsComputer = SubjectChangedColumnsComputer; //# sourceMappingURL=SubjectChangedColumnsComputer.js.map
}),
"[project]/node_modules/typeorm/persistence/tree/NestedSetSubjectExecutor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NestedSetSubjectExecutor = void 0;
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const NestedSetMultipleRootError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/NestedSetMultipleRootError.js [app-route] (ecmascript)");
class NestedSetIds {
}
/**
 * Executes subject operations for nested set tree entities.
 */ class NestedSetSubjectExecutor {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryRunner){
        this.queryRunner = queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Executes operations when subject is being inserted.
     */ async insert(subject) {
        const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(subject.metadata.tablePath);
        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);
        const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent
        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children
        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
        const parentId = subject.metadata.getEntityIdMap(parent);
        let parentNsRight = undefined;
        if (parentId) {
            parentNsRight = await this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + "." + subject.metadata.nestedSetRightColumn.propertyPath, "right").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then((result)=>{
                const value = result ? result["right"] : undefined;
                // CockroachDB returns numeric types as string
                return typeof value === "string" ? parseInt(value) : value;
            });
        }
        if (parentNsRight !== undefined) {
            await this.queryRunner.query(`UPDATE ${tableName} SET ` + `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` + `${rightColumnName} = ${rightColumnName} + 2 ` + `WHERE ${rightColumnName} >= ${parentNsRight}`);
            OrmUtils_1.OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));
        } else {
            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);
            // Validate if a root entity already exits and throw an exception
            if (!isUniqueRoot) throw new NestedSetMultipleRootError_1.NestedSetMultipleRootError();
            OrmUtils_1.OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));
        }
    }
    /**
     * Executes operations when subject is being updated.
     */ async update(subject) {
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent
        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children
        parent = subject.parentSubject.entity;
        let entity = subject.databaseEntity; // if entity was attached via parent
        if (!entity && parent) // if entity was attached via children
        entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find((child)=>{
            return Object.entries(subject.identifier).every(([key, value])=>child[key] === value);
        });
        // Exit if the parent or the entity where never set
        if (entity === undefined || parent === undefined) {
            return;
        }
        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
        const oldParentId = subject.metadata.getEntityIdMap(oldParent);
        const parentId = subject.metadata.getEntityIdMap(parent);
        // Exit if the new and old parents are the same
        if (OrmUtils_1.OrmUtils.compareIds(oldParentId, parentId)) {
            return;
        }
        if (parent) {
            const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
            const tableName = this.getTableName(subject.metadata.tablePath);
            const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);
            const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);
            const entityId = subject.metadata.getEntityIdMap(entity);
            let entityNs = undefined;
            if (entityId) {
                entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];
            }
            let parentNs = undefined;
            if (parentId) {
                parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];
            }
            if (entityNs !== undefined && parentNs !== undefined) {
                const isMovingUp = parentNs.left > entityNs.left;
                const treeSize = entityNs.right - entityNs.left + 1;
                let entitySize;
                if (isMovingUp) {
                    entitySize = parentNs.left - entityNs.right;
                } else {
                    entitySize = parentNs.right - entityNs.left;
                }
                // Moved entity logic
                const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ` + `${leftColumnName} < ${entityNs.right} ` + `THEN ${leftColumnName} + ${entitySize} `;
                const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ` + `${rightColumnName} <= ${entityNs.right} ` + `THEN ${rightColumnName} + ${entitySize} `;
                // Update the surrounding entities
                if (isMovingUp) {
                    await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entityNs.right} AND ` + `${leftColumnName} <= ${parentNs.left} ` + `THEN ${leftColumnName} - ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entityNs.right} AND ` + `${rightColumnName} < ${parentNs.left} ` + `THEN ${rightColumnName} - ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);
                } else {
                    await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} < ${entityNs.left} AND ` + `${leftColumnName} > ${parentNs.right} ` + `THEN ${leftColumnName} + ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} < ${entityNs.left} AND ` + `${rightColumnName} >= ${parentNs.right} ` + `THEN ${rightColumnName} + ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);
                }
            }
        } else {
            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);
            // Validate if a root entity already exits and throw an exception
            if (!isUniqueRoot) throw new NestedSetMultipleRootError_1.NestedSetMultipleRootError();
        }
    }
    /**
     * Executes operations when subject is being removed.
     */ async remove(subjects) {
        if (!Array.isArray(subjects)) subjects = [
            subjects
        ];
        const metadata = subjects[0].metadata;
        const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(metadata.tablePath);
        const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);
        const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);
        const entitiesIds = [];
        for (const subject of subjects){
            const entityId = metadata.getEntityIdMap(subject.entity);
            if (entityId) {
                entitiesIds.push(entityId);
            }
        }
        const entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);
        for (const entity of entitiesNs){
            const treeSize = entity.right - entity.left + 1;
            await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` + `ELSE ${rightColumnName} ` + `END`);
        }
    }
    /**
     * Get the nested set ids for a given entity
     */ getNestedSetIds(metadata, ids) {
        const select = {
            left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,
            right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`
        };
        const queryBuilder = this.queryRunner.manager.createQueryBuilder();
        Object.entries(select).forEach(([key, value])=>{
            queryBuilder.addSelect(value, key);
        });
        return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, "DESC").getRawMany().then((results)=>{
            const data = [];
            for (const result of results){
                const entry = {};
                for (const key of Object.keys(select)){
                    const value = result ? result[key] : undefined;
                    // CockroachDB returns numeric types as string
                    entry[key] = typeof value === "string" ? parseInt(value) : value;
                }
                data.push(entry);
            }
            return data;
        });
    }
    async isUniqueRootEntity(subject, parent) {
        const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(subject.metadata.tablePath);
        const parameters = [];
        const whereCondition = subject.metadata.treeParentRelation.joinColumns.map((column)=>{
            const columnName = escape(column.databaseName);
            const parameter = column.getEntityValue(parent);
            if (parameter == null) {
                return `${columnName} IS NULL`;
            }
            parameters.push(parameter);
            const parameterName = this.queryRunner.connection.driver.createParameter("entity_" + column.databaseName, parameters.length - 1);
            return `${columnName} = ${parameterName}`;
        }).join(" AND ");
        const countAlias = "count";
        const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);
        return parseInt(result.records[0][countAlias]) === 0;
    }
    /**
     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
     * schema name, otherwise returns escaped table name.
     */ getTableName(tablePath) {
        return tablePath.split(".").map((i)=>{
            // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string
            return i === "" ? i : this.queryRunner.connection.driver.escape(i);
        }).join(".");
    }
}
exports.NestedSetSubjectExecutor = NestedSetSubjectExecutor; //# sourceMappingURL=NestedSetSubjectExecutor.js.map
}),
"[project]/node_modules/typeorm/persistence/tree/ClosureSubjectExecutor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClosureSubjectExecutor = void 0;
const CannotAttachTreeChildrenEntityError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/CannotAttachTreeChildrenEntityError.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Executes subject operations for closure entities.
 */ class ClosureSubjectExecutor {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryRunner){
        this.queryRunner = queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Executes operations when subject is being inserted.
     */ async insert(subject) {
        // create values to be inserted into the closure junction
        const closureJunctionInsertMap = {};
        subject.metadata.closureJunctionTable.ancestorColumns.forEach((column)=>{
            closureJunctionInsertMap[column.databaseName] = subject.identifier;
        });
        subject.metadata.closureJunctionTable.descendantColumns.forEach((column)=>{
            closureJunctionInsertMap[column.databaseName] = subject.identifier;
        });
        // insert values into the closure junction table
        await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute();
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent
        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children
        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
        if (parent) {
            const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
            const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);
            const queryParams = [];
            const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map((column)=>{
                return escape(column.databaseName);
            });
            const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map((column)=>{
                return escape(column.databaseName);
            });
            const childEntityIds1 = subject.metadata.primaryColumns.map((column)=>{
                queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));
                return this.queryRunner.connection.driver.createParameter("child_entity_" + column.databaseName, queryParams.length - 1);
            });
            const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column)=>{
                const columnName = escape(column.databaseName);
                const parentId = column.referencedColumn.getEntityValue(parent);
                if (!parentId) throw new CannotAttachTreeChildrenEntityError_1.CannotAttachTreeChildrenEntityError(subject.metadata.name);
                queryParams.push(parentId);
                const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
                return `${columnName} = ${parameterName}`;
            });
            await this.queryRunner.query(`INSERT INTO ${tableName} (${[
                ...ancestorColumnNames,
                ...descendantColumnNames
            ].join(", ")}) ` + `SELECT ${ancestorColumnNames.join(", ")}, ${childEntityIds1.join(", ")} FROM ${tableName} WHERE ${whereCondition.join(" AND ")}`, queryParams);
        }
    }
    /**
     * Executes operations when subject is being updated.
     */ async update(subject) {
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent
        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children
        parent = subject.parentSubject.entity;
        let entity = subject.databaseEntity; // if entity was attached via parent
        if (!entity && parent) // if entity was attached via children
        entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find((child)=>{
            return Object.entries(subject.identifier).every(([key, value])=>child[key] === value);
        });
        // Exit if the parent or the entity where never set
        if (entity === undefined || parent === undefined) {
            return;
        }
        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
        const oldParentId = subject.metadata.getEntityIdMap(oldParent);
        const parentId = subject.metadata.getEntityIdMap(parent);
        // Exit if the new and old parents are the same
        if (OrmUtils_1.OrmUtils.compareIds(oldParentId, parentId)) {
            return;
        }
        const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
        const closureTable = subject.metadata.closureJunctionTable;
        const ancestorColumnNames = closureTable.ancestorColumns.map((column)=>{
            return escape(column.databaseName);
        });
        const descendantColumnNames = closureTable.descendantColumns.map((column)=>{
            return escape(column.databaseName);
        });
        // Delete logic
        const createSubQuery = (qb, alias)=>{
            const subAlias = `sub${alias}`;
            const subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(", ")).from(closureTable.tablePath, subAlias);
            // Create where conditions e.g. (WHERE "subdescendant"."id_ancestor" = :value_id)
            for (const column of closureTable.ancestorColumns){
                subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);
            }
            return qb.createQueryBuilder().select(descendantColumnNames.join(", ")).from(`(${subSelect.getQuery()})`, alias).setParameters(subSelect.getParameters()).getQuery();
        };
        const parameters = {};
        for (const column of subject.metadata.primaryColumns){
            parameters[`value_${column.databaseName}`] = entity[column.databaseName];
        }
        await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where((qb)=>`(${descendantColumnNames.join(", ")}) IN (${createSubQuery(qb, "descendant")})`).andWhere((qb)=>`(${ancestorColumnNames.join(", ")}) NOT IN (${createSubQuery(qb, "ancestor")})`).setParameters(parameters).execute();
        /**
         * Only insert new parent if it exits
         *
         * This only happens if the entity doesn't become a root entity
         */ if (parent) {
            // Insert logic
            const queryParams = [];
            const tableName = this.getTableName(closureTable.tablePath);
            const superAlias = escape("supertree");
            const subAlias = escape("subtree");
            const select = [
                ...ancestorColumnNames.map((columnName)=>`${superAlias}.${columnName}`),
                ...descendantColumnNames.map((columnName)=>`${subAlias}.${columnName}`)
            ];
            const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map((column)=>{
                const columnName = escape(column.databaseName);
                const entityId = column.referencedColumn.getEntityValue(entity);
                queryParams.push(entityId);
                const parameterName = this.queryRunner.connection.driver.createParameter("entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
                return `${subAlias}.${columnName} = ${parameterName}`;
            });
            const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column)=>{
                const columnName = escape(column.databaseName);
                const parentId = column.referencedColumn.getEntityValue(parent);
                if (!parentId) throw new CannotAttachTreeChildrenEntityError_1.CannotAttachTreeChildrenEntityError(subject.metadata.name);
                queryParams.push(parentId);
                const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
                return `${superAlias}.${columnName} = ${parameterName}`;
            });
            await this.queryRunner.query(`INSERT INTO ${tableName} (${[
                ...ancestorColumnNames,
                ...descendantColumnNames
            ].join(", ")}) ` + `SELECT ${select.join(", ")} ` + `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` + `WHERE ${[
                ...entityWhereCondition,
                ...parentWhereCondition
            ].join(" AND ")}`, queryParams);
        }
    }
    /**
     * Executes operations when subject is being removed.
     */ async remove(subjects) {
        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.
        if (!(this.queryRunner.connection.driver.options.type === "mssql")) {
            return;
        }
        if (!Array.isArray(subjects)) subjects = [
            subjects
        ];
        const escape = (alias)=>this.queryRunner.connection.driver.escape(alias);
        const identifiers = subjects.map((subject)=>subject.identifier);
        const closureTable = subjects[0].metadata.closureJunctionTable;
        const generateWheres = (columns)=>{
            return columns.map((column)=>{
                const data = identifiers.map((identifier)=>identifier[column.referencedColumn.databaseName]);
                return `${escape(column.databaseName)} IN (${data.join(", ")})`;
            }).join(" AND ");
        };
        const ancestorWhere = generateWheres(closureTable.ancestorColumns);
        const descendantWhere = generateWheres(closureTable.descendantColumns);
        await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute();
    }
    /**
     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
     * schema name, otherwise returns escaped table name.
     */ getTableName(tablePath) {
        return tablePath.split(".").map((i)=>{
            // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string
            return i === "" ? i : this.queryRunner.connection.driver.escape(i);
        }).join(".");
    }
}
exports.ClosureSubjectExecutor = ClosureSubjectExecutor; //# sourceMappingURL=ClosureSubjectExecutor.js.map
}),
"[project]/node_modules/typeorm/persistence/tree/MaterializedPathSubjectExecutor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MaterializedPathSubjectExecutor = void 0;
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
const Brackets_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/Brackets.js [app-route] (ecmascript)");
/**
 * Executes subject operations for materialized-path tree entities.
 */ class MaterializedPathSubjectExecutor {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryRunner){
        this.queryRunner = queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Executes operations when subject is being inserted.
     */ async insert(subject) {
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent
        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children
        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
        const parentId = subject.metadata.getEntityIdMap(parent);
        let parentPath = "";
        if (parentId) {
            parentPath = await this.getEntityPath(subject, parentId);
        }
        const insertedEntityId = subject.metadata.treeParentRelation.joinColumns.map((joinColumn)=>{
            return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);
        }).join("_");
        await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({
            [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + "."
        }).where(subject.identifier).execute();
    }
    /**
     * Executes operations when subject is being updated.
     */ async update(subject) {
        let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent
        if (!newParent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children
        newParent = subject.parentSubject.entity;
        let entity = subject.databaseEntity; // if entity was attached via parent
        if (!entity && newParent) // if entity was attached via children
        entity = subject.metadata.treeChildrenRelation.getEntityValue(newParent).find((child)=>{
            return Object.entries(subject.identifier).every(([key, value])=>child[key] === value);
        });
        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
        const oldParentId = this.getEntityParentReferencedColumnMap(subject, oldParent);
        const newParentId = this.getEntityParentReferencedColumnMap(subject, newParent);
        // Exit if the new and old parents are the same
        if (OrmUtils_1.OrmUtils.compareIds(oldParentId, newParentId)) {
            return;
        }
        let newParentPath = "";
        if (newParentId) {
            newParentPath = await this.getEntityPath(subject, newParentId);
        }
        let oldParentPath = "";
        if (oldParentId) {
            oldParentPath = await this.getEntityPath(subject, oldParentId) || "";
        }
        const entityPath = subject.metadata.treeParentRelation.joinColumns.map((joinColumn)=>{
            return joinColumn.referencedColumn.getEntityValue(entity);
        }).join("_");
        const propertyPath = subject.metadata.materializedPathColumn.propertyPath;
        await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({
            [propertyPath]: ()=>`REPLACE(${this.queryRunner.connection.driver.escape(propertyPath)}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`
        }).where(`${propertyPath} LIKE :path`, {
            path: `${oldParentPath}${entityPath}.%`
        }).execute();
    }
    getEntityParentReferencedColumnMap(subject, entity) {
        if (!entity) return undefined;
        return EntityMetadata_1.EntityMetadata.getValueMap(entity, subject.metadata.treeParentRelation.joinColumns.map((column)=>column.referencedColumn).filter((v)=>v != null), {
            skipNulls: true
        });
    }
    getEntityPath(subject, id) {
        const metadata = subject.metadata;
        const normalized = (Array.isArray(id) ? id : [
            id
        ]).map((id)=>metadata.ensureEntityIdMap(id));
        return this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + "." + subject.metadata.materializedPathColumn.propertyPath, "path").from(subject.metadata.target, subject.metadata.targetName).where(new Brackets_1.Brackets((qb)=>{
            for (const data of normalized){
                qb.orWhere(new Brackets_1.Brackets((qb)=>qb.where(data)));
            }
        })).getRawOne().then((result)=>result ? result["path"] : "");
    }
}
exports.MaterializedPathSubjectExecutor = MaterializedPathSubjectExecutor; //# sourceMappingURL=MaterializedPathSubjectExecutor.js.map
}),
"[project]/node_modules/typeorm/persistence/SubjectExecutor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubjectExecutor = void 0;
const SubjectTopologicalSorter_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/SubjectTopologicalSorter.js [app-route] (ecmascript)");
const SubjectChangedColumnsComputer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/SubjectChangedColumnsComputer.js [app-route] (ecmascript)");
const SubjectWithoutIdentifierError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/SubjectWithoutIdentifierError.js [app-route] (ecmascript)");
const SubjectRemovedAndUpdatedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/SubjectRemovedAndUpdatedError.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const NestedSetSubjectExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/tree/NestedSetSubjectExecutor.js [app-route] (ecmascript)");
const ClosureSubjectExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/tree/ClosureSubjectExecutor.js [app-route] (ecmascript)");
const MaterializedPathSubjectExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/tree/MaterializedPathSubjectExecutor.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Executes all database operations (inserts, updated, deletes) that must be executed
 * with given persistence subjects.
 */ class SubjectExecutor {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryRunner, subjects, options){
        // -------------------------------------------------------------------------
        // Public Properties
        // -------------------------------------------------------------------------
        /**
         * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).
         */ this.hasExecutableOperations = false;
        /**
         * Subjects that must be inserted.
         */ this.insertSubjects = [];
        /**
         * Subjects that must be updated.
         */ this.updateSubjects = [];
        /**
         * Subjects that must be removed.
         */ this.removeSubjects = [];
        /**
         * Subjects that must be soft-removed.
         */ this.softRemoveSubjects = [];
        /**
         * Subjects that must be recovered.
         */ this.recoverSubjects = [];
        this.queryRunner = queryRunner;
        this.allSubjects = subjects;
        this.options = options;
        this.validate();
        this.recompute();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Executes all operations over given array of subjects.
     * Executes queries using given query runner.
     */ async execute() {
        // console.time("SubjectExecutor.execute");
        // broadcast "before" events before we start insert / update / remove operations
        let broadcasterResult = undefined;
        if (!this.options || this.options.listeners !== false) {
            // console.time(".broadcastBeforeEventsForAll");
            broadcasterResult = this.broadcastBeforeEventsForAll();
            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);
        // console.timeEnd(".broadcastBeforeEventsForAll");
        }
        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects
        // recompute only in the case if any listener or subscriber was really executed
        if (broadcasterResult && broadcasterResult.count > 0) {
            // console.time(".recompute");
            this.insertSubjects.forEach((subject)=>subject.recompute());
            this.updateSubjects.forEach((subject)=>subject.recompute());
            this.removeSubjects.forEach((subject)=>subject.recompute());
            this.softRemoveSubjects.forEach((subject)=>subject.recompute());
            this.recoverSubjects.forEach((subject)=>subject.recompute());
            this.recompute();
        // console.timeEnd(".recompute");
        }
        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly
        // console.timeEnd("prepare");
        // execute all insert operations
        // console.time(".insertion");
        this.insertSubjects = new SubjectTopologicalSorter_1.SubjectTopologicalSorter(this.insertSubjects).sort("insert");
        await this.executeInsertOperations();
        // console.timeEnd(".insertion");
        // recompute update operations since insertion can create updation operations for the
        // properties it wasn't able to handle on its own (referenced columns)
        this.updateSubjects = this.allSubjects.filter((subject)=>subject.mustBeUpdated);
        // execute update operations
        // console.time(".updation");
        await this.executeUpdateOperations();
        // console.timeEnd(".updation");
        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal
        // console.time(".removal");
        this.removeSubjects = new SubjectTopologicalSorter_1.SubjectTopologicalSorter(this.removeSubjects).sort("delete");
        await this.executeRemoveOperations();
        // console.timeEnd(".removal");
        // recompute soft-remove operations
        this.softRemoveSubjects = this.allSubjects.filter((subject)=>subject.mustBeSoftRemoved);
        // execute soft-remove operations
        await this.executeSoftRemoveOperations();
        // recompute recover operations
        this.recoverSubjects = this.allSubjects.filter((subject)=>subject.mustBeRecovered);
        // execute recover operations
        await this.executeRecoverOperations();
        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
        // console.time(".updateSpecialColumnsInPersistedEntities");
        this.updateSpecialColumnsInPersistedEntities();
        // console.timeEnd(".updateSpecialColumnsInPersistedEntities");
        // finally broadcast "after" events after we finish insert / update / remove operations
        if (!this.options || this.options.listeners !== false) {
            // console.time(".broadcastAfterEventsForAll");
            broadcasterResult = this.broadcastAfterEventsForAll();
            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);
        // console.timeEnd(".broadcastAfterEventsForAll");
        }
    // console.timeEnd("SubjectExecutor.execute");
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Validates all given subjects.
     */ validate() {
        this.allSubjects.forEach((subject)=>{
            if (subject.mustBeUpdated && subject.mustBeRemoved) throw new SubjectRemovedAndUpdatedError_1.SubjectRemovedAndUpdatedError(subject);
        });
    }
    /**
     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.
     */ recompute() {
        new SubjectChangedColumnsComputer_1.SubjectChangedColumnsComputer().compute(this.allSubjects);
        this.insertSubjects = this.allSubjects.filter((subject)=>subject.mustBeInserted);
        this.updateSubjects = this.allSubjects.filter((subject)=>subject.mustBeUpdated);
        this.removeSubjects = this.allSubjects.filter((subject)=>subject.mustBeRemoved);
        this.softRemoveSubjects = this.allSubjects.filter((subject)=>subject.mustBeSoftRemoved);
        this.recoverSubjects = this.allSubjects.filter((subject)=>subject.mustBeRecovered);
        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;
    }
    /**
     * Broadcasts "BEFORE_INSERT", "BEFORE_UPDATE", "BEFORE_REMOVE", "BEFORE_SOFT_REMOVE", "BEFORE_RECOVER" events for all given subjects.
     */ broadcastBeforeEventsForAll() {
        const result = new BroadcasterResult_1.BroadcasterResult();
        if (this.insertSubjects.length) this.insertSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));
        if (this.updateSubjects.length) this.updateSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));
        if (this.removeSubjects.length) this.removeSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.recoverSubjects.length) this.recoverSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        return result;
    }
    /**
     * Broadcasts "AFTER_INSERT", "AFTER_UPDATE", "AFTER_REMOVE", "AFTER_SOFT_REMOVE", "AFTER_RECOVER" events for all given subjects.
     * Returns void if there wasn't any listener or subscriber executed.
     * Note: this method has a performance-optimized code organization.
     */ broadcastAfterEventsForAll() {
        const result = new BroadcasterResult_1.BroadcasterResult();
        if (this.insertSubjects.length) this.insertSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity, subject.identifier));
        if (this.updateSubjects.length) this.updateSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));
        if (this.removeSubjects.length) this.removeSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.recoverSubjects.length) this.recoverSubjects.forEach((subject)=>this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        return result;
    }
    /**
     * Executes insert operations.
     */ async executeInsertOperations() {
        // group insertion subjects to make bulk insertions
        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, "insert");
        // then we run insertion in the sequential order which is important since we have an ordered subjects
        for (const groupName of groupedInsertSubjectKeys){
            const subjects = groupedInsertSubjects[groupName];
            // we must separately insert entities which does not have any values to insert
            // because its not possible to insert multiple entities with only default values in bulk
            const bulkInsertMaps = [];
            const bulkInsertSubjects = [];
            const singleInsertSubjects = [];
            if (this.queryRunner.connection.driver.options.type === "mongodb") {
                subjects.forEach((subject)=>{
                    if (subject.metadata.createDateColumn && subject.entity) {
                        subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();
                    }
                    if (subject.metadata.updateDateColumn && subject.entity) {
                        subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();
                    }
                    subject.createValueSetAndPopChangeMap();
                    bulkInsertSubjects.push(subject);
                    bulkInsertMaps.push(subject.entity);
                });
            } else if (this.queryRunner.connection.driver.options.type === "oracle") {
                subjects.forEach((subject)=>{
                    singleInsertSubjects.push(subject);
                });
            } else {
                subjects.forEach((subject)=>{
                    // we do not insert in bulk in following cases:
                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows
                    // - when entity is a tree table, since tree tables require extra operation per each inserted row
                    // - when oracle is used, since oracle's bulk insertion is very bad
                    if (subject.changeMaps.length === 0 || subject.metadata.treeType || this.queryRunner.connection.driver.options.type === "oracle" || this.queryRunner.connection.driver.options.type === "sap") {
                        singleInsertSubjects.push(subject);
                    } else {
                        bulkInsertSubjects.push(subject);
                        bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());
                    }
                });
            }
            // for mongodb we have a bit different insertion logic
            if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
                const insertResult = await this.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);
                subjects.forEach((subject, index)=>{
                    subject.identifier = insertResult.identifiers[index];
                    subject.generatedMap = insertResult.generatedMaps[index];
                    subject.insertedValueSet = bulkInsertMaps[index];
                });
            } else {
                // here we execute our insertion query
                // we need to enable entity updation because we DO need to have updated insertedMap
                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty
                // also, we disable listeners because we call them on our own in persistence layer
                if (bulkInsertMaps.length > 0) {
                    const insertResult = await this.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute();
                    bulkInsertSubjects.forEach((subject, index)=>{
                        subject.identifier = insertResult.identifiers[index];
                        subject.generatedMap = insertResult.generatedMaps[index];
                        subject.insertedValueSet = bulkInsertMaps[index];
                    });
                }
                // insert subjects which must be inserted in separate requests (all default values)
                if (singleInsertSubjects.length > 0) {
                    for (const subject of singleInsertSubjects){
                        subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it
                        // for nested set we execute additional queries
                        if (subject.metadata.treeType === "nested-set") await new NestedSetSubjectExecutor_1.NestedSetSubjectExecutor(this.queryRunner).insert(subject);
                        await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute().then((insertResult)=>{
                            subject.identifier = insertResult.identifiers[0];
                            subject.generatedMap = insertResult.generatedMaps[0];
                        });
                        // for tree tables we execute additional queries
                        if (subject.metadata.treeType === "closure-table") {
                            await new ClosureSubjectExecutor_1.ClosureSubjectExecutor(this.queryRunner).insert(subject);
                        } else if (subject.metadata.treeType === "materialized-path") {
                            await new MaterializedPathSubjectExecutor_1.MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);
                        }
                    }
                }
            }
            subjects.forEach((subject)=>{
                if (subject.generatedMap) {
                    subject.metadata.columns.forEach((column)=>{
                        const value = column.getEntityValue(subject.generatedMap);
                        if (value !== undefined && value !== null) {
                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                            column.setEntityValue(subject.generatedMap, preparedValue);
                        }
                    });
                }
            });
        }
    }
    /**
     * Updates all given subjects in the database.
     */ async executeUpdateOperations() {
        const updateSubject = async (subject)=>{
            if (!subject.identifier) throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
            // for mongodb we have a bit different updation logic
            if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
                const partialEntity = this.cloneMongoSubjectEntity(subject);
                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];
                }
                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
                    delete partialEntity[subject.metadata.createDateColumn.propertyName];
                }
                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();
                }
                const manager = this.queryRunner.manager;
                await manager.update(subject.metadata.target, subject.identifier, partialEntity);
            } else {
                const updateMap = subject.createValueSetAndPopChangeMap();
                // for tree tables we execute additional queries
                switch(subject.metadata.treeType){
                    case "nested-set":
                        await new NestedSetSubjectExecutor_1.NestedSetSubjectExecutor(this.queryRunner).update(subject);
                        break;
                    case "closure-table":
                        await new ClosureSubjectExecutor_1.ClosureSubjectExecutor(this.queryRunner).update(subject);
                        break;
                    case "materialized-path":
                        await new MaterializedPathSubjectExecutor_1.MaterializedPathSubjectExecutor(this.queryRunner).update(subject);
                        break;
                }
                // here we execute our updation query
                // we need to enable entity updation because we update a subject identifier
                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty
                // also, we disable listeners because we call them on our own in persistence layer
                const updateQueryBuilder = this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
                if (subject.entity) {
                    updateQueryBuilder.whereEntity(subject.identifier);
                } else {
                    // in this case identifier is just conditions object to update by
                    updateQueryBuilder.where(subject.identifier);
                }
                const updateResult = await updateQueryBuilder.execute();
                const updateGeneratedMap = updateResult.generatedMaps[0];
                if (updateGeneratedMap) {
                    subject.metadata.columns.forEach((column)=>{
                        const value = column.getEntityValue(updateGeneratedMap);
                        if (value !== undefined && value !== null) {
                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                            column.setEntityValue(updateGeneratedMap, preparedValue);
                        }
                    });
                    if (!subject.generatedMap) {
                        subject.generatedMap = {};
                    }
                    Object.assign(subject.generatedMap, updateGeneratedMap);
                }
            }
        };
        // Nested sets need to be updated one by one
        // Split array in two, one with nested set subjects and the other with the remaining subjects
        const nestedSetSubjects = [];
        const remainingSubjects = [];
        for (const subject of this.updateSubjects){
            if (subject.metadata.treeType === "nested-set") {
                nestedSetSubjects.push(subject);
            } else {
                remainingSubjects.push(subject);
            }
        }
        // Run nested set updates one by one
        const updateNestSetSubjects = async ()=>{
            for (const subject of nestedSetSubjects){
                await updateSubject(subject);
            }
        };
        // Run all remaining subjects in parallel
        await Promise.all([
            ...remainingSubjects.map(updateSubject),
            updateNestSetSubjects()
        ]);
    }
    /**
     * Removes all given subjects from the database.
     *
     * todo: we need to apply topological sort here as well
     */ async executeRemoveOperations() {
        // group insertion subjects to make bulk insertions
        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, "delete");
        for (const groupName of groupedRemoveSubjectKeys){
            const subjects = groupedRemoveSubjects[groupName];
            const deleteMaps = subjects.map((subject)=>{
                if (!subject.identifier) throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
                return subject.identifier;
            });
            // for mongodb we have a bit different updation logic
            if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
                const manager = this.queryRunner.manager;
                await manager.delete(subjects[0].metadata.target, deleteMaps);
            } else {
                // for tree tables we execute additional queries
                switch(subjects[0].metadata.treeType){
                    case "nested-set":
                        await new NestedSetSubjectExecutor_1.NestedSetSubjectExecutor(this.queryRunner).remove(subjects);
                        break;
                    case "closure-table":
                        await new ClosureSubjectExecutor_1.ClosureSubjectExecutor(this.queryRunner).remove(subjects);
                        break;
                }
                // here we execute our deletion query
                // we don't need to specify entities and set update entity to true since the only thing query builder
                // will do for use is a primary keys deletion which is handled by us later once persistence is finished
                // also, we disable listeners because we call them on our own in persistence layer
                await this.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute();
            }
        }
    }
    cloneMongoSubjectEntity(subject) {
        const target = {};
        if (subject.entity) {
            for (const column of subject.metadata.columns){
                OrmUtils_1.OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));
            }
        }
        return target;
    }
    /**
     * Soft-removes all given subjects in the database.
     */ async executeSoftRemoveOperations() {
        await Promise.all(this.softRemoveSubjects.map(async (subject)=>{
            if (!subject.identifier) throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
            let updateResult;
            // for mongodb we have a bit different updation logic
            if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
                const partialEntity = this.cloneMongoSubjectEntity(subject);
                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];
                }
                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
                    delete partialEntity[subject.metadata.createDateColumn.propertyName];
                }
                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();
                }
                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {
                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();
                }
                const manager = this.queryRunner.manager;
                updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);
            } else {
                // here we execute our soft-deletion query
                // we need to enable entity soft-deletion because we update a subject identifier
                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty
                // also, we disable listeners because we call them on our own in persistence layer
                const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
                if (subject.entity) {
                    softDeleteQueryBuilder.whereEntity(subject.identifier);
                } else {
                    // in this case identifier is just conditions object to update by
                    softDeleteQueryBuilder.where(subject.identifier);
                }
                updateResult = await softDeleteQueryBuilder.execute();
            }
            subject.generatedMap = updateResult.generatedMaps[0];
            if (subject.generatedMap) {
                subject.metadata.columns.forEach((column)=>{
                    const value = column.getEntityValue(subject.generatedMap);
                    if (value !== undefined && value !== null) {
                        const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                        column.setEntityValue(subject.generatedMap, preparedValue);
                    }
                });
            }
        // experiments, remove probably, need to implement tree tables children removal
        // if (subject.updatedRelationMaps.length > 0) {
        //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {
        //         if (!updatedRelation.relation.isTreeParent) return;
        //         if (!updatedRelation.value !== null) return;
        //
        //         if (subject.metadata.treeType === "closure-table") {
        //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);
        //         }
        //     }));
        // }
        }));
    }
    /**
     * Recovers all given subjects in the database.
     */ async executeRecoverOperations() {
        await Promise.all(this.recoverSubjects.map(async (subject)=>{
            if (!subject.identifier) throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
            let updateResult;
            // for mongodb we have a bit different updation logic
            if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
                const partialEntity = this.cloneMongoSubjectEntity(subject);
                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];
                }
                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
                    delete partialEntity[subject.metadata.createDateColumn.propertyName];
                }
                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();
                }
                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {
                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;
                }
                const manager = this.queryRunner.manager;
                updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);
            } else {
                // here we execute our restory query
                // we need to enable entity restory because we update a subject identifier
                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty
                // also, we disable listeners because we call them on our own in persistence layer
                const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
                if (subject.entity) {
                    softDeleteQueryBuilder.whereEntity(subject.identifier);
                } else {
                    // in this case identifier is just conditions object to update by
                    softDeleteQueryBuilder.where(subject.identifier);
                }
                updateResult = await softDeleteQueryBuilder.execute();
            }
            subject.generatedMap = updateResult.generatedMaps[0];
            if (subject.generatedMap) {
                subject.metadata.columns.forEach((column)=>{
                    const value = column.getEntityValue(subject.generatedMap);
                    if (value !== undefined && value !== null) {
                        const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                        column.setEntityValue(subject.generatedMap, preparedValue);
                    }
                });
            }
        // experiments, remove probably, need to implement tree tables children removal
        // if (subject.updatedRelationMaps.length > 0) {
        //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {
        //         if (!updatedRelation.relation.isTreeParent) return;
        //         if (!updatedRelation.value !== null) return;
        //
        //         if (subject.metadata.treeType === "closure-table") {
        //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);
        //         }
        //     }));
        // }
        }));
    }
    /**
     * Updates all special columns of the saving entities (create date, update date, version, etc.).
     * Also updates nullable columns and columns with default values.
     */ updateSpecialColumnsInPersistedEntities() {
        // update inserted entity properties
        if (this.insertSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);
        // update updated entity properties
        if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);
        // update soft-removed entity properties
        if (this.softRemoveSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);
        // update recovered entity properties
        if (this.recoverSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);
        // remove ids from the entities that were removed
        if (this.removeSubjects.length) {
            this.removeSubjects.forEach((subject)=>{
                if (!subject.entity) return;
                subject.metadata.primaryColumns.forEach((primaryColumn)=>{
                    primaryColumn.setEntityValue(subject.entity, undefined);
                });
            });
        }
        // other post-persist updations
        this.allSubjects.forEach((subject)=>{
            if (!subject.entity) return;
            subject.metadata.relationIds.forEach((relationId)=>{
                relationId.setValue(subject.entity);
            });
            // mongo _id remove
            if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {
                    delete subject.entity[subject.metadata.objectIdColumn.databaseName];
                }
            }
        });
    }
    /**
     * Updates all special columns of the saving entities (create date, update date, version, etc.).
     * Also updates nullable columns and columns with default values.
     */ updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {
        subjects.forEach((subject)=>{
            if (!subject.entity) return;
            // set values to "null" for nullable columns that did not have values
            subject.metadata.columns.forEach((column)=>{
                // if table inheritance is used make sure this column is not child's column
                if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map((metadata)=>metadata.target).indexOf(column.target) !== -1) return;
                // entities does not have virtual columns
                if (column.isVirtual) return;
                // if column is deletedAt
                if (column.isDeleteDate) return;
                // update nullable columns
                if (column.isNullable) {
                    const columnValue = column.getEntityValue(subject.entity);
                    if (columnValue === undefined) column.setEntityValue(subject.entity, null);
                }
                // update relational columns
                if (subject.updatedRelationMaps.length > 0) {
                    subject.updatedRelationMaps.forEach((updatedRelationMap)=>{
                        updatedRelationMap.relation.joinColumns.forEach((column)=>{
                            if (column.isVirtual === true) return;
                            column.setEntityValue(subject.entity, ObjectUtils_1.ObjectUtils.isObject(updatedRelationMap.value) ? column.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);
                        });
                    });
                }
            });
            // merge into entity all generated values returned by a database
            if (subject.generatedMap) this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);
        });
    }
    /**
     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.
     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns
     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns
     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,
     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.
     * That's why we only support bulking in junction tables for those drivers.
     *
     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated
     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.
     */ groupBulkSubjects(subjects, type) {
        const group = {};
        const keys = [];
        const hasReturningDependColumns = subjects.some((subject)=>{
            return subject.metadata.getInsertionReturningColumns().length > 0;
        });
        const groupingAllowed = type === "delete" || this.queryRunner.connection.driver.isReturningSqlSupported("insert") || hasReturningDependColumns === false;
        subjects.forEach((subject, index)=>{
            const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + "_" + index;
            if (!group[key]) {
                group[key] = [
                    subject
                ];
                keys.push(key);
            } else {
                group[key].push(subject);
            }
        });
        return [
            group,
            keys
        ];
    }
}
exports.SubjectExecutor = SubjectExecutor; //# sourceMappingURL=SubjectExecutor.js.map
}),
"[project]/node_modules/typeorm/persistence/Subject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Subject = void 0;
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Subject is a subject of persistence.
 * It holds information about each entity that needs to be persisted:
 * - what entity should be persisted
 * - what is database representation of the persisted entity
 * - what entity metadata of the persisted entity
 * - what is allowed to with persisted entity (insert/update/remove)
 *
 * Having this collection of subjects we can perform database queries.
 */ class Subject {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("Subject");
        /**
         * Subject identifier.
         * This identifier is not limited to table entity primary columns.
         * This can be entity id or ids as well as some unique entity properties, like name or title.
         * Insert / Update / Remove operation will be executed by a given identifier.
         */ this.identifier = undefined;
        /**
         * Copy of entity but with relational ids fulfilled.
         */ this.entityWithFulfilledIds = undefined;
        /**
         * Indicates if database entity was loaded.
         * No matter if it was found or not, it indicates the fact of loading.
         */ this.databaseEntityLoaded = false;
        /**
         * Changes needs to be applied in the database for the given subject.
         */ this.changeMaps = [];
        /**
         * Indicates if this subject can be inserted into the database.
         * This means that this subject either is newly persisted, either can be inserted by cascades.
         */ this.canBeInserted = false;
        /**
         * Indicates if this subject can be updated in the database.
         * This means that this subject either was persisted, either can be updated by cascades.
         */ this.canBeUpdated = false;
        /**
         * Indicates if this subject MUST be removed from the database.
         * This means that this subject either was removed, either was removed by cascades.
         */ this.mustBeRemoved = false;
        /**
         * Indicates if this subject can be soft-removed from the database.
         * This means that this subject either was soft-removed, either was soft-removed by cascades.
         */ this.canBeSoftRemoved = false;
        /**
         * Indicates if this subject can be recovered from the database.
         * This means that this subject either was recovered, either was recovered by cascades.
         */ this.canBeRecovered = false;
        /**
         * Relations updated by the change maps.
         */ this.updatedRelationMaps = [];
        /**
         * List of updated columns
         */ this.diffColumns = [];
        /**
         * List of updated relations
         */ this.diffRelations = [];
        this.metadata = options.metadata;
        this.entity = options.entity;
        this.parentSubject = options.parentSubject;
        if (options.canBeInserted !== undefined) this.canBeInserted = options.canBeInserted;
        if (options.canBeUpdated !== undefined) this.canBeUpdated = options.canBeUpdated;
        if (options.mustBeRemoved !== undefined) this.mustBeRemoved = options.mustBeRemoved;
        if (options.canBeSoftRemoved !== undefined) this.canBeSoftRemoved = options.canBeSoftRemoved;
        if (options.canBeRecovered !== undefined) this.canBeRecovered = options.canBeRecovered;
        if (options.identifier !== undefined) this.identifier = options.identifier;
        if (options.changeMaps !== undefined) this.changeMaps.push(...options.changeMaps);
        this.recompute();
    }
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    /**
     * Checks if this subject must be inserted into the database.
     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)
     * and if it does not have database entity set.
     */ get mustBeInserted() {
        return this.canBeInserted && !this.databaseEntity;
    }
    /**
     * Checks if this subject must be updated into the database.
     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)
     * and if it does have differentiated columns or relations.
     */ get mustBeUpdated() {
        return this.canBeUpdated && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity) && // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&
        // ensure there are one or more changes for updatable columns
        this.changeMaps.some((change)=>!change.column || change.column.isUpdate);
    }
    /**
     * Checks if this subject must be soft-removed into the database.
     * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)
     * and if it does have differentiated columns or relations.
     */ get mustBeSoftRemoved() {
        return this.canBeSoftRemoved && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);
    }
    /**
     * Checks if this subject must be recovered into the database.
     * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)
     * and if it does have differentiated columns or relations.
     */ get mustBeRecovered() {
        return this.canBeRecovered && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a value set needs to be inserted / updated in the database.
     * Value set is based on the entity and change maps of the subject.
     * Important note: this method pops data from this subject's change maps.
     */ createValueSetAndPopChangeMap() {
        const changeMapsWithoutValues = [];
        const changeSet = this.changeMaps.reduce((updateMap, changeMap)=>{
            let value = changeMap.value;
            if (InstanceChecker_1.InstanceChecker.isSubject(value)) {
                // referenced columns can refer on values both which were just inserted and which were present in the model
                // if entity was just inserted valueSets must contain all values from the entity and values just inserted in the database
                // so, here we check if we have a value set then we simply use it as value to get our reference column values
                // otherwise simply use an entity which cannot be just inserted at the moment and have all necessary data
                value = value.insertedValueSet ? value.insertedValueSet : value.entity;
            }
            // value = changeMap.valueFactory ? changeMap.valueFactory(value) : changeMap.column.createValueMap(value);
            let valueMap;
            if (this.metadata.isJunction && changeMap.column) {
                valueMap = changeMap.column.createValueMap(changeMap.column.referencedColumn.getEntityValue(value));
            } else if (changeMap.column) {
                valueMap = changeMap.column.createValueMap(value);
            } else if (changeMap.relation) {
                // value can be a related object, for example: post.question = { id: 1 }
                // or value can be a null or direct relation id, e.g. post.question = 1
                // if its a direction relation id then we just set it to the valueMap,
                // however if its an object then we need to extract its relation id map and set it to the valueMap
                if (ObjectUtils_1.ObjectUtils.isObject(value) && !Buffer.isBuffer(value)) {
                    // get relation id, e.g. referenced column name and its value,
                    // for example: { id: 1 } which then will be set to relation, e.g. post.category = { id: 1 }
                    const relationId = changeMap.relation.getRelationIdMap(value);
                    // but relation id can be empty, for example in the case when you insert a new post with category
                    // and both post and category are newly inserted objects (by cascades) and in this case category will not have id
                    // this means we need to insert post without question id and update post's questionId once question be inserted
                    // that's why we create a new changeMap operation for future updation of the post entity
                    if (relationId === undefined) {
                        changeMapsWithoutValues.push(changeMap);
                        this.canBeUpdated = true;
                        return updateMap;
                    }
                    valueMap = changeMap.relation.createValueMap(relationId);
                    this.updatedRelationMaps.push({
                        relation: changeMap.relation,
                        value: relationId
                    });
                } else {
                    // value can be "null" or direct relation id here
                    valueMap = changeMap.relation.createValueMap(value);
                    this.updatedRelationMaps.push({
                        relation: changeMap.relation,
                        value: value
                    });
                }
            }
            OrmUtils_1.OrmUtils.mergeDeep(updateMap, valueMap);
            return updateMap;
        }, {});
        this.changeMaps = changeMapsWithoutValues;
        return changeSet;
    }
    /**
     * Recomputes entityWithFulfilledIds and identifier when entity changes.
     */ recompute() {
        if (this.entity) {
            this.entityWithFulfilledIds = Object.assign({}, this.entity);
            if (this.parentSubject) {
                this.metadata.primaryColumns.forEach((primaryColumn)=>{
                    if (primaryColumn.relationMetadata && primaryColumn.relationMetadata.inverseEntityMetadata === this.parentSubject.metadata) {
                        const value = primaryColumn.referencedColumn.getEntityValue(this.parentSubject.entity);
                        primaryColumn.setEntityValue(this.entityWithFulfilledIds, value);
                    }
                });
            }
            this.identifier = this.metadata.getEntityIdMap(this.entityWithFulfilledIds);
        } else if (this.databaseEntity) {
            this.identifier = this.metadata.getEntityIdMap(this.databaseEntity);
        }
    }
}
exports.Subject = Subject; //# sourceMappingURL=Subject.js.map
}),
"[project]/node_modules/typeorm/persistence/subject-builder/OneToManySubjectBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OneToManySubjectBuilder = void 0;
const Subject_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/Subject.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
/**
 * Builds operations needs to be executed for one-to-many relations of the given subjects.
 *
 * by example: post contains one-to-many relation with category in the property called "categories", e.g.
 *             @OneToMany(type => Category, category => category.post) categories: Category[]
 *             If user adds categories into the post and saves post we need to bind them.
 *             This operation requires updation of category table since its owner of the relation and contains a join column.
 *
 * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class
 *       make sure to reflect changes there as well.
 */ class OneToManySubjectBuilder {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(subjects){
        this.subjects = subjects;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Builds all required operations.
     */ build() {
        this.subjects.forEach((subject)=>{
            subject.metadata.oneToManyRelations.forEach((relation)=>{
                // skip relations for which persistence is disabled
                if (relation.persistenceEnabled === false) return;
                this.buildForSubjectRelation(subject, relation);
            });
        });
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Builds operations for a given subject and relation.
     *
     * by example: subject is "post" entity we are saving here and relation is "categories" inside it here.
     */ buildForSubjectRelation(subject, relation) {
        // prepare objects (relation id maps) for the database entity
        // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,
        //             particularly their relation ids, e.g. category ids stored in the database
        // in most cases relatedEntityDatabaseValues will contain only the entity key properties.
        // this is because subject.databaseEntity contains relations with loaded relation ids only.
        // however if the entity uses the afterLoad hook to calculate any properties, the fetched "key object" might include ADDITIONAL properties.
        // to handle such situations, we pass the data to relation.inverseEntityMetadata.getEntityIdMap to extract the key without any other properties.
        let relatedEntityDatabaseRelationIds = [];
        if (subject.databaseEntity) {
            // related entities in the database can exist only if this entity (post) is saved
            const relatedEntityDatabaseRelation = relation.getEntityValue(subject.databaseEntity);
            if (relatedEntityDatabaseRelation) {
                relatedEntityDatabaseRelationIds = relatedEntityDatabaseRelation.map((entity)=>relation.inverseEntityMetadata.getEntityIdMap(entity));
            }
        }
        // get related entities of persisted entity
        // by example: get categories from the passed to persist post entity
        let relatedEntities = relation.getEntityValue(subject.entity);
        if (relatedEntities === null) // we treat relations set to null as removed, so we don't skip it
        relatedEntities = [];
        if (relatedEntities === undefined) // if relation is undefined then nothing to update
        return;
        // extract only relation ids from the related entities, since we only need them for comparison
        // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)
        const relatedPersistedEntityRelationIds = [];
        relatedEntities.forEach((relatedEntity)=>{
            // by example: relatedEntity is a category here
            let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }
            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence
            let relatedEntitySubject = this.subjects.find((subject)=>{
                return subject.entity === relatedEntity;
            });
            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved
            if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier;
            // if relationIdMap is undefined then it means user binds object which is not saved in the database yet
            // by example: if post contains categories which does not have ids yet (because they are new)
            //             it means they are always newly inserted and relation update operation always must be created for them
            //             it does not make sense to perform difference operation for them for both add and remove actions
            if (!relationIdMap) {
                // we decided to remove this error because it brings complications when saving object with non-saved entities
                // if (!relatedEntitySubject)
                //     throw new TypeORMError(`One-to-many relation "${relation.entityMetadata.name}.${relation.propertyPath}" contains ` +
                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +
                //         `Please setup cascade insertion or save entities before binding it.`);
                if (!relatedEntitySubject) return;
                // okay, so related subject exist and its marked for insertion, then add a new change map
                // by example: this will tell category to insert into its post relation our post we are working with
                //             relatedEntitySubject is newly inserted CategorySubject
                //             relation.inverseRelation is ManyToOne relation inside Category
                //             subject is Post needs to be inserted into Category
                relatedEntitySubject.changeMaps.push({
                    relation: relation.inverseRelation,
                    value: subject
                });
                return;
            }
            // check if this binding really exist in the database
            // by example: find our category if its already bind in the database
            const relationIdInDatabaseSubjectRelation = relatedEntityDatabaseRelationIds.find((relatedDatabaseEntityRelationId)=>{
                return OrmUtils_1.OrmUtils.compareIds(relationIdMap, relatedDatabaseEntityRelationId);
            });
            // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to "bind" them
            // by example: this will tell category to insert into its post relation our post we are working with
            //             relatedEntitySubject is newly inserted CategorySubject
            //             relation.inverseRelation is ManyToOne relation inside Category
            //             subject is Post needs to be inserted into Category
            if (!relationIdInDatabaseSubjectRelation) {
                // if there is no relatedEntitySubject then it means "category" wasn't persisted,
                // but since we are going to update "category" table (since its an owning side of relation with join column)
                // we create a new subject here:
                if (!relatedEntitySubject) {
                    relatedEntitySubject = new Subject_1.Subject({
                        metadata: relation.inverseEntityMetadata,
                        parentSubject: subject,
                        canBeUpdated: true,
                        identifier: relationIdMap
                    });
                    this.subjects.push(relatedEntitySubject);
                }
                relatedEntitySubject.changeMaps.push({
                    relation: relation.inverseRelation,
                    value: subject
                });
            }
            // if related entity has relation id then we add it to the list of relation ids
            // this list will be used later to compare with database relation ids to find a difference
            // what exist in this array and does not exist in the database are newly inserted relations
            // what does not exist in this array, but exist in the database are removed relations
            // removed relations are set to null from inverse side of relation
            relatedPersistedEntityRelationIds.push(relationIdMap);
        });
        // find what related entities were added and what were removed based on difference between what we save and what database has
        if (relation.inverseRelation?.orphanedRowAction !== "disable") {
            EntityMetadata_1.EntityMetadata.difference(relatedEntityDatabaseRelationIds, relatedPersistedEntityRelationIds).forEach((removedRelatedEntityRelationId)=>{
                // by example: removedRelatedEntityRelationId is category that was bind in the database before, but now its unbind
                // todo: probably we can improve this in the future by finding entity with column those values,
                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns
                // we create a new subject which operations will be executed in subject operation executor
                const removedRelatedEntitySubject = new Subject_1.Subject({
                    metadata: relation.inverseEntityMetadata,
                    parentSubject: subject,
                    identifier: removedRelatedEntityRelationId
                });
                if (!relation.inverseRelation || relation.inverseRelation.orphanedRowAction === "nullify") {
                    removedRelatedEntitySubject.canBeUpdated = true;
                    removedRelatedEntitySubject.changeMaps = [
                        {
                            relation: relation.inverseRelation,
                            value: null
                        }
                    ];
                } else if (relation.inverseRelation.orphanedRowAction === "delete") {
                    removedRelatedEntitySubject.mustBeRemoved = true;
                } else if (relation.inverseRelation.orphanedRowAction === "soft-delete") {
                    removedRelatedEntitySubject.canBeSoftRemoved = true;
                }
                this.subjects.push(removedRelatedEntitySubject);
            });
        }
    }
}
exports.OneToManySubjectBuilder = OneToManySubjectBuilder; //# sourceMappingURL=OneToManySubjectBuilder.js.map
}),
"[project]/node_modules/typeorm/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OneToOneInverseSideSubjectBuilder = void 0;
const Subject_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/Subject.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Builds operations needs to be executed for one-to-one non-owner relations of the given subjects.
 *
 * by example: post contains one-to-one non-owner relation with category in the property called "category", e.g.
 *             @OneToOne(type => Category, category => category.post) category: Category
 *             If user sets a category into the post and saves post we need to bind them.
 *             This operation requires updation of category table since its owner of the relation and contains a join column.
 *
 * note: this class shares lot of things with OneToManyUpdateBuilder, so when you change this class
 *       make sure to reflect changes there as well.
 */ class OneToOneInverseSideSubjectBuilder {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(subjects){
        this.subjects = subjects;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Builds all required operations.
     */ build() {
        this.subjects.forEach((subject)=>{
            subject.metadata.oneToOneRelations.forEach((relation)=>{
                // we don't need owning relations, this operation is only for inverse side of one-to-one relations
                // skip relations for which persistence is disabled
                if (relation.isOwning || relation.persistenceEnabled === false) return;
                this.buildForSubjectRelation(subject, relation);
            });
        });
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Builds operations for a given subject and relation.
     *
     * by example: subject is "post" entity we are saving here and relation is "category" inside it here.
     */ buildForSubjectRelation(subject, relation) {
        // prepare objects (relation id map) for the database entity
        // note: subject.databaseEntity contains relation with loaded relation id only (id map)
        // by example: since subject is a post, we are expecting to get post's category saved in the database here,
        //             particularly its relation id, e.g. category id stored in the database
        let relatedEntityDatabaseRelationId = undefined;
        if (subject.databaseEntity) // related entity in the database can exist only if this entity (post) is saved
        relatedEntityDatabaseRelationId = relation.getEntityValue(subject.databaseEntity);
        // get related entities of persisted entity
        // by example: get category from the passed to persist post entity
        const relatedEntity = relation.getEntityValue(subject.entity); // by example: relatedEntity is a category here
        if (relatedEntity === undefined) // if relation is undefined then nothing to update
        return;
        // if related entity is null then we need to check if there a bind in the database and unset it
        // if there is no bind in the entity then we don't need to do anything
        // by example: if post.category = null and category has this post in the database then we unset it
        if (relatedEntity === null) {
            // it makes sense to update database only there is a previously set value in the database
            if (relatedEntityDatabaseRelationId) {
                // todo: probably we can improve this in the future by finding entity with column those values,
                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns
                // we create a new subject which operations will be executed in subject operation executor
                const removedRelatedEntitySubject = new Subject_1.Subject({
                    metadata: relation.inverseEntityMetadata,
                    parentSubject: subject,
                    canBeUpdated: true,
                    identifier: relatedEntityDatabaseRelationId,
                    changeMaps: [
                        {
                            relation: relation.inverseRelation,
                            value: null
                        }
                    ]
                });
                this.subjects.push(removedRelatedEntitySubject);
            }
            return;
        } // else means entity is bind in the database
        // extract only relation id from the related entities, since we only need it for comparison
        // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)
        let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }
        // try to find a subject of this related entity, maybe it was loaded or was marked for persistence
        let relatedEntitySubject = this.subjects.find((operateSubject)=>{
            return !!operateSubject.entity && operateSubject.entity === relatedEntity;
        });
        // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved
        if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier;
        // if relationIdMap is undefined then it means user binds object which is not saved in the database yet
        // by example: if post contains category which does not have id(s) yet (because its a new category)
        //             it means its always newly inserted and relation update operation always must be created for it
        //             it does not make sense to perform difference operation for it for both add and remove actions
        if (!relationIdMap) {
            // we decided to remove this error because it brings complications when saving object with non-saved entities
            // if related entity does not have a subject then it means user tries to bind entity which wasn't saved
            // in this persistence because he didn't pass this entity for save or he did not set cascades
            // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here
            // if (!relatedEntitySubject)
            //     throw new TypeORMError(`One-to-one inverse relation "${relation.entityMetadata.name}.${relation.propertyPath}" contains ` +
            //         `entity which does not exist in the database yet, thus cannot be bind in the database. ` +
            //         `Please setup cascade insertion or save entity before binding it.`);
            if (!relatedEntitySubject) return;
            // okay, so related subject exist and its marked for insertion, then add a new change map
            // by example: this will tell category to insert into its post relation our post we are working with
            //             relatedEntitySubject is newly inserted CategorySubject
            //             relation.inverseRelation is OneToOne owner relation inside Category
            //             subject is Post needs to be inserted into Category
            relatedEntitySubject.changeMaps.push({
                relation: relation.inverseRelation,
                value: subject
            });
        }
        // check if this binding really exist in the database
        // by example: find our post if its already bind to category in the database and its not equal to what user tries to set
        const areRelatedIdEqualWithDatabase = relatedEntityDatabaseRelationId && OrmUtils_1.OrmUtils.compareIds(relationIdMap, relatedEntityDatabaseRelationId);
        // if they aren't equal it means its a new relation and we need to "bind" them
        // by example: this will tell category to insert into its post relation our post we are working with
        //             relatedEntitySubject is newly inserted CategorySubject
        //             relation.inverseRelation is ManyToOne relation inside Category
        //             subject is Post needs to be inserted into Category
        if (!areRelatedIdEqualWithDatabase) {
            // if there is no relatedEntitySubject then it means "category" wasn't persisted,
            // but since we are going to update "category" table (since its an owning side of relation with join column)
            // we create a new subject here:
            if (!relatedEntitySubject) {
                relatedEntitySubject = new Subject_1.Subject({
                    metadata: relation.inverseEntityMetadata,
                    canBeUpdated: true,
                    identifier: relationIdMap
                });
                this.subjects.push(relatedEntitySubject);
            }
            relatedEntitySubject.changeMaps.push({
                relation: relation.inverseRelation,
                value: subject
            });
        }
    }
}
exports.OneToOneInverseSideSubjectBuilder = OneToOneInverseSideSubjectBuilder; //# sourceMappingURL=OneToOneInverseSideSubjectBuilder.js.map
}),
"[project]/node_modules/typeorm/persistence/subject-builder/ManyToManySubjectBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ManyToManySubjectBuilder = void 0;
const Subject_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/Subject.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Builds operations needs to be executed for many-to-many relations of the given subjects.
 *
 * by example: post contains owner many-to-many relation with categories in the property called "categories", e.g.
 *             @ManyToMany(type => Category, category => category.posts) categories: Category[]
 *             If user adds categories into the post and saves post we need to bind them.
 *             This operation requires updation of junction table.
 */ class ManyToManySubjectBuilder {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(subjects){
        this.subjects = subjects;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Builds operations for any changes in the many-to-many relations of the subjects.
     */ build() {
        this.subjects.forEach((subject)=>{
            // if subject doesn't have entity then no need to find something that should be inserted or removed
            if (!subject.entity) return;
            // go through all persistence enabled many-to-many relations and build subject operations for them
            subject.metadata.manyToManyRelations.forEach((relation)=>{
                // skip relations for which persistence is disabled
                if (relation.persistenceEnabled === false) return;
                this.buildForSubjectRelation(subject, relation);
            });
        });
    }
    /**
     * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.
     */ buildForAllRemoval(subject) {
        // if subject does not have a database entity then it means it does not exist in the database
        // if it does not exist in the database then we don't have anything for deletion
        if (!subject.databaseEntity) return;
        // go through all persistence enabled many-to-many relations and build subject operations for them
        subject.metadata.manyToManyRelations.forEach((relation)=>{
            // skip relations for which persistence is disabled
            if (relation.persistenceEnabled === false) return;
            // get all related entities (actually related entity relation ids) bind to this subject entity
            // by example: returns category ids of the post we are currently working with (subject.entity is post)
            const relatedEntityRelationIdsInDatabase = relation.getEntityValue(subject.databaseEntity);
            // go through all related entities and create a new junction subject for each row in junction table
            relatedEntityRelationIdsInDatabase.forEach((relationId)=>{
                const junctionSubject = new Subject_1.Subject({
                    metadata: relation.junctionEntityMetadata,
                    parentSubject: subject,
                    mustBeRemoved: true,
                    identifier: this.buildJunctionIdentifier(subject, relation, relationId)
                });
                // we use unshift because we need to perform those operations before post deletion is performed
                // but post deletion was already added as an subject
                // this is temporary solution, later we need to implement proper sorting of subjects before their removal
                this.subjects.push(junctionSubject);
            });
        });
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Builds operations for a given subject and relation.
     *
     * by example: subject is "post" entity we are saving here and relation is "categories" inside it here.
     */ buildForSubjectRelation(subject, relation) {
        // load from db all relation ids of inverse entities that are "bind" to the subject's entity
        // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)
        let databaseRelatedEntityIds = [];
        // if subject don't have database entity it means all related entities in persisted subject are new and must be bind
        // and we don't need to remove something that is not exist
        if (subject.databaseEntity) {
            const databaseRelatedEntityValue = relation.getEntityValue(subject.databaseEntity);
            if (databaseRelatedEntityValue) {
                databaseRelatedEntityIds = databaseRelatedEntityValue.map((e)=>relation.inverseEntityMetadata.getEntityIdMap(e));
            }
        }
        // extract entity's relation value
        // by example: categories inside our post (subject.entity is post)
        let relatedEntities = relation.getEntityValue(subject.entity);
        if (relatedEntities === null) // if value set to null its equal if we set it to empty array - all items must be removed from the database
        relatedEntities = [];
        if (!Array.isArray(relatedEntities)) return;
        // from all related entities find only those which aren't found in the db - for them we will create operation subjects
        relatedEntities.forEach((relatedEntity)=>{
            // by example: relatedEntity is category from categories saved with post
            // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet
            // extract only relation id from the related entities, since we only need it for comparison
            // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)
            let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence
            const relatedEntitySubject = this.subjects.find((subject)=>{
                return subject.entity === relatedEntity;
            });
            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved
            if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;
            // if related entity relation id map is empty it means related entity is newly persisted
            if (!relatedEntityRelationIdMap) {
                // we decided to remove this error because it brings complications when saving object with non-saved entities
                // if related entity does not have a subject then it means user tries to bind entity which wasn't saved
                // in this persistence because he didn't pass this entity for save or he did not set cascades
                // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here
                // we decided to remove this error because it brings complications when saving object with non-saved entities
                // if (!relatedEntitySubject)
                //     throw new TypeORMError(`Many-to-many relation "${relation.entityMetadata.name}.${relation.propertyPath}" contains ` +
                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +
                //         `Please setup cascade insertion or save entities before binding it.`);
                if (!relatedEntitySubject) return;
            }
            // try to find related entity in the database
            // by example: find post's category in the database post's categories
            const relatedEntityExistInDatabase = databaseRelatedEntityIds.find((databaseRelatedEntityRelationId)=>{
                return OrmUtils_1.OrmUtils.compareIds(databaseRelatedEntityRelationId, relatedEntityRelationIdMap);
            });
            // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything
            if (relatedEntityExistInDatabase) return;
            const ownerValue = relation.isOwning ? subject : relatedEntitySubject || relatedEntity; // by example: ownerEntityMap is post from subject here
            const inverseValue = relation.isOwning ? relatedEntitySubject || relatedEntity : subject; // by example: inverseEntityMap is category from categories array here
            // create a new subject for insert operation of junction rows
            const junctionSubject = new Subject_1.Subject({
                metadata: relation.junctionEntityMetadata,
                parentSubject: subject,
                canBeInserted: true
            });
            this.subjects.push(junctionSubject);
            relation.junctionEntityMetadata.ownerColumns.forEach((column)=>{
                junctionSubject.changeMaps.push({
                    column: column,
                    value: ownerValue
                });
            });
            relation.junctionEntityMetadata.inverseColumns.forEach((column)=>{
                junctionSubject.changeMaps.push({
                    column: column,
                    value: inverseValue
                });
            });
        });
        // get all inverse entities relation ids that are "bind" to the currently persisted entity
        const changedInverseEntityRelationIds = [];
        relatedEntities.forEach((relatedEntity)=>{
            // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)
            let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence
            const relatedEntitySubject = this.subjects.find((subject)=>{
                return subject.entity === relatedEntity;
            });
            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved
            if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;
            if (relatedEntityRelationIdMap !== undefined && relatedEntityRelationIdMap !== null) changedInverseEntityRelationIds.push(relatedEntityRelationIdMap);
        });
        // now from all entities in the persisted entity find only those which aren't found in the db
        const removedJunctionEntityIds = databaseRelatedEntityIds.filter((existRelationId)=>{
            return !changedInverseEntityRelationIds.find((changedRelationId)=>{
                return OrmUtils_1.OrmUtils.compareIds(changedRelationId, existRelationId);
            });
        });
        // finally create a new junction remove operations for missing related entities
        removedJunctionEntityIds.forEach((removedEntityRelationId)=>{
            const junctionSubject = new Subject_1.Subject({
                metadata: relation.junctionEntityMetadata,
                parentSubject: subject,
                mustBeRemoved: true,
                identifier: this.buildJunctionIdentifier(subject, relation, removedEntityRelationId)
            });
            this.subjects.push(junctionSubject);
        });
    }
    /**
     * Creates identifiers for junction table.
     * Example: { postId: 1, categoryId: 2 }
     */ buildJunctionIdentifier(subject, relation, relationId) {
        const ownerEntityMap = relation.isOwning ? subject.entity : relationId;
        const inverseEntityMap = relation.isOwning ? relationId : subject.entity;
        const identifier = {};
        relation.junctionEntityMetadata.ownerColumns.forEach((column)=>{
            OrmUtils_1.OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(ownerEntityMap)));
        });
        relation.junctionEntityMetadata.inverseColumns.forEach((column)=>{
            OrmUtils_1.OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(inverseEntityMap)));
        });
        return identifier;
    }
}
exports.ManyToManySubjectBuilder = ManyToManySubjectBuilder; //# sourceMappingURL=ManyToManySubjectBuilder.js.map
}),
"[project]/node_modules/typeorm/persistence/SubjectDatabaseEntityLoader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubjectDatabaseEntityLoader = void 0;
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Loads database entities for all operate subjects which do not have database entity set.
 * All entities that we load database entities for are marked as updated or inserted.
 * To understand which of them really needs to be inserted or updated we need to load
 * their original representations from the database.
 */ class SubjectDatabaseEntityLoader {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(queryRunner, subjects){
        this.queryRunner = queryRunner;
        this.subjects = subjects;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Loads database entities for all subjects.
     *
     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.
     * This option is used for deletion.
     */ async load(operationType) {
        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator
        // go through the groups and perform loading of database entities of each subject in the group
        const promises = this.groupByEntityTargets().map(async (subjectGroup)=>{
            // prepare entity ids of the subjects we need to load
            const allIds = [];
            const allSubjects = [];
            subjectGroup.subjects.forEach((subject)=>{
                // we don't load if subject already has a database entity loaded
                if (subject.databaseEntity || !subject.identifier) return;
                allIds.push(subject.identifier);
                allSubjects.push(subject);
            });
            // if there no ids found (means all entities are new and have generated ids) - then nothing to load there
            if (!allIds.length) return;
            const loadRelationPropertyPaths = [];
            // for the save, soft-remove and recover operation
            // extract all property paths of the relations we need to load relation ids for
            // this is for optimization purpose - this way we don't load relation ids for entities
            // whose relations are undefined, and since they are undefined its really pointless to
            // load something for them, since undefined properties are skipped by the orm
            if (operationType === "save" || operationType === "soft-remove" || operationType === "recover") {
                subjectGroup.subjects.forEach((subject)=>{
                    // gets all relation property paths that exist in the persisted entity.
                    subject.metadata.relations.forEach((relation)=>{
                        const value = relation.getEntityValue(subject.entityWithFulfilledIds);
                        if (value === undefined) return;
                        if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1) loadRelationPropertyPaths.push(relation.propertyPath);
                    });
                });
            } else {
                // remove
                // for remove operation
                // we only need to load junction relation ids since only they are removed by cascades
                loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map((relation)=>relation.propertyPath));
            }
            const findOptions = {
                loadEagerRelations: false,
                loadRelationIds: {
                    relations: loadRelationPropertyPaths,
                    disableMixedMap: true
                },
                // the soft-deleted entities should be included in the loaded entities for recover operation
                withDeleted: true
            };
            // load database entities for all given ids
            let entities = [];
            if (this.queryRunner.connection.driver.options.type === "mongodb") {
                const mongoRepo = this.queryRunner.manager.getRepository(subjectGroup.target);
                entities = await mongoRepo.findByIds(allIds, findOptions);
            } else {
                entities = await this.queryRunner.manager.getRepository(subjectGroup.target).createQueryBuilder().setFindOptions(findOptions).whereInIds(allIds).getMany();
            }
            // Now when we have entities we need to find subject of each entity
            // and insert that entity into database entity of the found subjects.
            // A single entity can be applied to many subjects as there might be duplicates.
            // This will likely result in the same row being updated multiple times during a transaction.
            entities.forEach((entity)=>{
                const entityId = allSubjects[0].metadata.getEntityIdMap(entity);
                allSubjects.forEach((subject)=>{
                    if (subject.databaseEntity) return;
                    if (OrmUtils_1.OrmUtils.compareIds(subject.identifier, entityId)) subject.databaseEntity = entity;
                });
            });
            // this way we tell what subjects we tried to load database entities of
            for (const subject of allSubjects){
                subject.databaseEntityLoaded = true;
            }
        });
        await Promise.all(promises);
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Groups given Subject objects into groups separated by entity targets.
     */ groupByEntityTargets() {
        return this.subjects.reduce((groups, operatedEntity)=>{
            let group = groups.find((group)=>group.target === operatedEntity.metadata.target);
            if (!group) {
                group = {
                    target: operatedEntity.metadata.target,
                    subjects: []
                };
                groups.push(group);
            }
            group.subjects.push(operatedEntity);
            return groups;
        }, []);
    }
}
exports.SubjectDatabaseEntityLoader = SubjectDatabaseEntityLoader; //# sourceMappingURL=SubjectDatabaseEntityLoader.js.map
}),
"[project]/node_modules/typeorm/persistence/subject-builder/CascadesSubjectBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CascadesSubjectBuilder = void 0;
const Subject_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/Subject.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,
 * e.g. builds a cascade tree and creates a subjects for them.
 */ class CascadesSubjectBuilder {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(allSubjects){
        this.allSubjects = allSubjects;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Builds a cascade subjects tree and pushes them in into the given array of subjects.
     */ build(subject, operationType) {
        subject.metadata.extractRelationValuesFromEntity(subject.entity, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations
        .forEach(([relation, relationEntity, relationEntityMetadata])=>{
            // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set
            if (relationEntity === undefined || relationEntity === null || !relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover) return;
            // if relation entity is just a relation id set (for example post.tag = 1)
            // then we don't really need to check cascades since there is no object to insert or update
            if (!ObjectUtils_1.ObjectUtils.isObject(relationEntity)) return;
            // if we already has this entity in list of operated subjects then skip it to avoid recursion
            const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);
            if (alreadyExistRelationEntitySubject) {
                if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet
                alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === "save";
                if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet
                alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === "save";
                if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false) // if its not marked for removal yet
                alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === "soft-remove";
                if (alreadyExistRelationEntitySubject.canBeRecovered === false) // if its not marked for recovery yet
                alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === "recover";
                return;
            }
            // mark subject with what we can do with it
            // and add to the array of subjects to load only if there is no same entity there already
            const relationEntitySubject = new Subject_1.Subject({
                metadata: relationEntityMetadata,
                parentSubject: subject,
                entity: relationEntity,
                canBeInserted: relation.isCascadeInsert === true && operationType === "save",
                canBeUpdated: relation.isCascadeUpdate === true && operationType === "save",
                canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === "soft-remove",
                canBeRecovered: relation.isCascadeRecover === true && operationType === "recover"
            });
            this.allSubjects.push(relationEntitySubject);
            // go recursively and find other entities we need to insert/update
            this.build(relationEntitySubject, operationType);
        });
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Finds subject where entity like given subject's entity.
     * Comparison made by entity id.
     */ findByPersistEntityLike(entityTarget, entity) {
        return this.allSubjects.find((subject)=>{
            if (!subject.entity) return false;
            if (subject.entity === entity) return true;
            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);
        });
    }
}
exports.CascadesSubjectBuilder = CascadesSubjectBuilder; //# sourceMappingURL=CascadesSubjectBuilder.js.map
}),
"[project]/node_modules/typeorm/persistence/EntityPersistExecutor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityPersistExecutor = void 0;
const MustBeEntityError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/MustBeEntityError.js [app-route] (ecmascript)");
const SubjectExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/SubjectExecutor.js [app-route] (ecmascript)");
const CannotDetermineEntityError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/CannotDetermineEntityError.js [app-route] (ecmascript)");
const Subject_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/Subject.js [app-route] (ecmascript)");
const OneToManySubjectBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/subject-builder/OneToManySubjectBuilder.js [app-route] (ecmascript)");
const OneToOneInverseSideSubjectBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.js [app-route] (ecmascript)");
const ManyToManySubjectBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/subject-builder/ManyToManySubjectBuilder.js [app-route] (ecmascript)");
const SubjectDatabaseEntityLoader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/SubjectDatabaseEntityLoader.js [app-route] (ecmascript)");
const CascadesSubjectBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/subject-builder/CascadesSubjectBuilder.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Persists a single entity or multiple entities - saves or removes them.
 */ class EntityPersistExecutor {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner, mode, target, entity, options){
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.mode = mode;
        this.target = target;
        this.entity = entity;
        this.options = options;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Executes persistence operation ob given entity or entities.
     */ async execute() {
        // check if entity we are going to save is valid and is an object
        if (!this.entity || typeof this.entity !== "object") return Promise.reject(new MustBeEntityError_1.MustBeEntityError(this.mode, this.entity));
        // we MUST call "fake" resolve here to make sure all properties of lazily loaded relations are resolved
        await Promise.resolve();
        // if query runner is already defined in this class, it means this entity manager was already created for a single connection
        // if its not defined we create a new query runner - single connection where we'll execute all our operations
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        // save data in the query runner - this is useful functionality to share data from outside of the world
        // with third classes - like subscribers and listener methods
        const oldQueryRunnerData = queryRunner.data;
        if (this.options && this.options.data) {
            queryRunner.data = this.options.data;
        }
        try {
            // collect all operate subjects
            const entities = Array.isArray(this.entity) ? this.entity : [
                this.entity
            ];
            const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils_1.OrmUtils.chunk(entities, this.options.chunk) : [
                entities
            ];
            // console.time("building subject executors...");
            const executors = await Promise.all(entitiesInChunks.map(async (entities)=>{
                const subjects = [];
                // create subjects for all entities we received for the persistence
                entities.forEach((entity)=>{
                    const entityTarget = this.target ? this.target : entity.constructor;
                    if (entityTarget === Object) throw new CannotDetermineEntityError_1.CannotDetermineEntityError(this.mode);
                    const metadata = this.connection.getMetadata(entityTarget).findInheritanceMetadata(entity);
                    subjects.push(new Subject_1.Subject({
                        metadata,
                        entity: entity,
                        canBeInserted: this.mode === "save",
                        canBeUpdated: this.mode === "save",
                        mustBeRemoved: this.mode === "remove",
                        canBeSoftRemoved: this.mode === "soft-remove",
                        canBeRecovered: this.mode === "recover"
                    }));
                });
                // console.time("building cascades...");
                // go through each entity with metadata and create subjects and subjects by cascades for them
                const cascadesSubjectBuilder = new CascadesSubjectBuilder_1.CascadesSubjectBuilder(subjects);
                subjects.forEach((subject)=>{
                    // next step we build list of subjects we will operate with
                    // these subjects are subjects that we need to insert or update alongside with main persisted entity
                    cascadesSubjectBuilder.build(subject, this.mode);
                });
                // console.timeEnd("building cascades...");
                // load database entities for all subjects we have
                // next step is to load database entities for all operate subjects
                // console.time("loading...");
                await new SubjectDatabaseEntityLoader_1.SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode);
                // console.timeEnd("loading...");
                // console.time("other subjects...");
                // build all related subjects and change maps
                if (this.mode === "save" || this.mode === "soft-remove" || this.mode === "recover") {
                    new OneToManySubjectBuilder_1.OneToManySubjectBuilder(subjects).build();
                    new OneToOneInverseSideSubjectBuilder_1.OneToOneInverseSideSubjectBuilder(subjects).build();
                    new ManyToManySubjectBuilder_1.ManyToManySubjectBuilder(subjects).build();
                } else {
                    subjects.forEach((subject)=>{
                        if (subject.mustBeRemoved) {
                            new ManyToManySubjectBuilder_1.ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);
                        }
                    });
                }
                // console.timeEnd("other subjects...");
                // console.timeEnd("building subjects...");
                // console.log("subjects", subjects);
                // create a subject executor
                return new SubjectExecutor_1.SubjectExecutor(queryRunner, subjects, this.options);
            }));
            // console.timeEnd("building subject executors...");
            // make sure we have at least one executable operation before we create a transaction and proceed
            // if we don't have operations it means we don't really need to update or remove something
            const executorsWithExecutableOperations = executors.filter((executor)=>executor.hasExecutableOperations);
            if (executorsWithExecutableOperations.length === 0) return;
            // start execute queries in a transaction
            // if transaction is already opened in this query runner then we don't touch it
            // if its not opened yet then we open it here, and once we finish - we close it
            let isTransactionStartedByUs = false;
            try {
                // open transaction if its not opened yet
                if (!queryRunner.isTransactionActive) {
                    if (this.connection.driver.transactionSupport !== "none" && (!this.options || this.options.transaction !== false)) {
                        // start transaction until it was not explicitly disabled
                        isTransactionStartedByUs = true;
                        await queryRunner.startTransaction();
                    }
                }
                // execute all persistence operations for all entities we have
                // console.time("executing subject executors...");
                for (const executor of executorsWithExecutableOperations){
                    await executor.execute();
                }
                // console.timeEnd("executing subject executors...");
                // commit transaction if it was started by us
                // console.time("commit");
                if (isTransactionStartedByUs === true) await queryRunner.commitTransaction();
            // console.timeEnd("commit");
            } catch (error) {
                // rollback transaction if it was started by us
                if (isTransactionStartedByUs) {
                    try {
                        await queryRunner.rollbackTransaction();
                    } catch (rollbackError) {}
                }
                throw error;
            }
        } finally{
            queryRunner.data = oldQueryRunnerData;
            // release query runner only if its created by us
            if (!this.queryRunner) await queryRunner.release();
        }
    }
}
exports.EntityPersistExecutor = EntityPersistExecutor; //# sourceMappingURL=EntityPersistExecutor.js.map
}),
];

//# sourceMappingURL=node_modules_typeorm_persistence_315c2dd9._.js.map